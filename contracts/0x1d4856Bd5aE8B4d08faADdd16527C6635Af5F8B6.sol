contract main {




// =====================  Runtime code  =====================


#
#  - elkCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4)
#
address stor0;
address stor1;
uint32 stor3;
address stor3;
uint256 stor3;
uint32 stor4;
address stor4;
uint256 stor4;
address stor5;
address stor6;
uint256 stor7;
uint256 stor8;
address stor9;

function _fallback() payable {
    revert
}

function sub_14438d91(?) {
    require calldata.size - 4 >= 288
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg5 == address(arg5)
    require arg6 == arg6
    require arg7 == arg7
    require arg8 == arg8
    require arg9 == arg9
    if stor9 != msg.sender:
        revert with 0, 'Caller is not owner'
    stor0 = msg.sender
    stor1 = address(arg1)
    stor7 = arg6
    stor5 = address(arg4)
    stor6 = address(arg5)
    address(stor4) = address(arg2)
    address(stor3) = address(arg3)
    if block.timestamp > -arg9 - 1:
        revert with 'NH{q', 17
    stor8 = block.timestamp + arg9
    if eth.balance(stor0) > -arg7 - 1:
        revert with 'NH{q', 17
    require ext_code.size(address(arg1))
    staticcall address(arg1).token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(arg1))
    staticcall address(arg1).getReserves() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    if arg6 <= 0:
        revert with 0, 'getAmountOut: INSUFFICIENT_INPUT_AMOUNT'
    if address(ext_call.return_data[0]) == 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83:
        if ext_call.return_data[18 len 14] <= 0:
            revert with 0, 'getAmountOut: INSUFFICIENT_LIQUIDITY'
        if ext_call.return_data[50 len 14] <= 0:
            revert with 0, 'getAmountOut: INSUFFICIENT_LIQUIDITY'
        if arg6 and arg8 > -1 / arg6:
            revert with 'NH{q', 17
        if arg6 * arg8 and ext_call.return_data[50 len 14] > -1 / arg6 * arg8:
            revert with 'NH{q', 17
        if ext_call.return_data[18 len 14] and 1000 > -1 / ext_call.return_data[18 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[18 len 14] > (-1 * arg6 * arg8) - 1:
            revert with 'NH{q', 17
        if not (1000 * ext_call.return_data[18 len 14]) + (arg6 * arg8):
            revert with 'NH{q', 18
        require ext_code.size(stor1)
        if address(ext_call.return_data[0]) == 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83:
            call stor1.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, arg6 * arg8 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (arg6 * arg8), address(this.address), 128, 3, '0x1'
        else:
            call stor1.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args arg6 * arg8 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (arg6 * arg8), 0, address(this.address), 128, 3, '0x1'
    else:
        if ext_call.return_data[50 len 14] <= 0:
            revert with 0, 'getAmountOut: INSUFFICIENT_LIQUIDITY'
        if ext_call.return_data[18 len 14] <= 0:
            revert with 0, 'getAmountOut: INSUFFICIENT_LIQUIDITY'
        if arg6 and arg8 > -1 / arg6:
            revert with 'NH{q', 17
        if arg6 * arg8 and ext_call.return_data[18 len 14] > -1 / arg6 * arg8:
            revert with 'NH{q', 17
        if ext_call.return_data[50 len 14] and 1000 > -1 / ext_call.return_data[50 len 14]:
            revert with 'NH{q', 17
        if 1000 * ext_call.return_data[50 len 14] > (-1 * arg6 * arg8) - 1:
            revert with 'NH{q', 17
        if not (1000 * ext_call.return_data[50 len 14]) + (arg6 * arg8):
            revert with 'NH{q', 18
        require ext_code.size(stor1)
        if address(ext_call.return_data[0]) == 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83:
            call stor1.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, arg6 * arg8 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (arg6 * arg8), address(this.address), 128, 3, '0x1'
        else:
            call stor1.swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args arg6 * arg8 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (arg6 * arg8), 0, address(this.address), 128, 3, '0x1'
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if eth.balance(stor0) <= eth.balance(stor0) + arg7:
        revert with 0, 'Swap is not profitable'
    emit 0x95bc73c4: eth.balance(stor0) + arg7, eth.balance(stor0)
    return eth.balance(stor0) + arg7, eth.balance(stor0)
}

function sub_3aa99232(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    if arg4.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg4.length)) + 97 > test266151307() or ceil32(ceil32(arg4.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg4.length
    require arg4 + arg4.length + 36 <= calldata.size
    mem[128 len arg4.length] = arg4[all]
    if stor1 != msg.sender:
        revert with 0, 'wrong pair address'
    mem[ceil32(ceil32(arg4.length)) + 101] = this.address
    if not address(stor4):
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor3)
        require ext_code.size(stor6)
        staticcall stor6.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor3)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor6)
            staticcall stor6.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor3))
            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _400 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _418 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _400 + (32 * _418) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + (32 * _418) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            if 1 >= _418:
                revert with 'NH{q', 50
            if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 257] <= stor7:
                revert with 0, 'received < initial balance'
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
               value stor7 wei
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1389 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1389] == bool(mem[_1389])
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = stor7
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, stor7
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1477 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1477] == bool(mem[_1477])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor6) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor6 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1428 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1445 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1428 + (32 * _1445) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + (32 * _1445) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1445:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3364 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3364] == bool(mem[_3364])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3495 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3495] == bool(mem[_3495])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1429 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1446 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1429 + (32 * _1446) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + (32 * _1446) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1446:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3365 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3365] == bool(mem[_3365])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3496 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3496] == bool(mem[_3496])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1430 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1447 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1430 + (32 * _1447) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + (32 * _1447) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1447:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3366 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3366] == bool(mem[_3366])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3497 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3497] == bool(mem[_3497])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1431 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1448 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1431 + (32 * _1448) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + (32 * _1448) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1448:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3367 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3367] == bool(mem[_3367])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3498 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3498] == bool(mem[_3498])
    else:
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor4)
        require ext_code.size(stor5)
        staticcall stor5.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor4)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor5)
            staticcall stor5.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor5
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor4))
            call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _403 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _423 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _403 + (32 * _423) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + (32 * _423) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1458 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1458] == mem[_1458]
            mem[mem[64] + 4] = this.address
            if mem[_1458]:
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1556 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1565 = mem[_1556]
                require mem[_1556] == mem[_1556]
                _1593 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 32] = stor6
                if 1 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                mem[_1593 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                mem[_1593 + 100] = _1565
                mem[_1593 + 132] = 1
                mem[_1593 + 164] = 160
                mem[_1593 + 260] = mem[_1593]
                idx = 0
                s = _1593 + 32
                t = _1593 + 292
                while idx < mem[_1593]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1593 + 196] = this.address
                mem[_1593 + 228] = stor8
                require ext_code.size(address(stor3))
                call address(stor3).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _1593 + (32 * mem[_1593]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3407 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3410 = mem[_3407]
                require mem[_3407] <= test266151307()
                require _3407 + mem[_3407] + 31 < _3407 + return_data.size
                _3427 = mem[_3407 + mem[_3407]]
                if mem[_3407 + mem[_3407]] > test266151307():
                    revert with 'NH{q', 65
                if _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1 > test266151307() or floor32(mem[_3407 + mem[_3407]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1
                mem[_3407 + ceil32(return_data.size)] = _3427
                require _3410 + (32 * _3427) + 32 <= return_data.size
                idx = _3407 + _3410 + 32
                s = _3407 + ceil32(return_data.size) + 32
                while idx < _3407 + _3410 + (32 * _3427) + 32:
                    require mem[idx] == mem[idx]
                    mem[s] = mem[idx]
                    idx = idx + 32
                    s = s + 32
                    continue 
                if 1 >= _3427:
                    revert with 'NH{q', 50
                if mem[_3407 + ceil32(return_data.size) + 64] <= stor7:
                    revert with 0, 'received < initial balance'
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                   value stor7 wei
                     gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5830 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_5830] == bool(mem[_5830])
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor7
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, stor7
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6411 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_6411] == bool(mem[_6411])
            else:
                mem[mem[64] + 36] = address(stor3)
                require ext_code.size(stor6)
                staticcall stor6.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(stor3)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1575] == mem[_1575]
                if mem[_1575]:
                    revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                _1613 = mem[64]
                mem[mem[64] + 36] = address(stor3)
                mem[mem[64] + 68] = -1
                _1657 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                mem[64] = mem[64] + 164
                mem[_1613 + 100] = 32
                mem[_1613 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if ext_code.size(stor6) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _1712 = mem[_1657]
                mem[_1613 + 164 len ceil32(mem[_1657])] = mem[_1657 + 32 len ceil32(mem[_1657])]
                if ceil32(_1712) <= _1712:
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6057 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6138 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6057 + (32 * _6138) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6057 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6057 + (32 * _6138) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6138:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8719 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8719] == bool(mem[_8719])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9119] == bool(mem[_9119])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6058 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6139 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6058 + (32 * _6139) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6058 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6058 + (32 * _6139) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6139:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8720 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8720] == bool(mem[_8720])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9120 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9120] == bool(mem[_9120])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6059 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6140 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6140
                            require _6059 + (32 * _6140) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + (32 * _6140) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6140:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8721 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8721] == bool(mem[_8721])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9121 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9121] == bool(mem[_9121])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6060 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6141 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6141
                            require _6060 + (32 * _6141) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + (32 * _6141) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6141:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8722 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8722] == bool(mem[_8722])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9122 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9122] == bool(mem[_9122])
                else:
                    mem[_1613 + _1712 + 164] = 0
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6061 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6142 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6061 + (32 * _6142) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6061 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6061 + (32 * _6142) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6142:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8723 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8723] == bool(mem[_8723])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9123 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9123] == bool(mem[_9123])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6062 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6143 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6062 + (32 * _6143) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6062 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6062 + (32 * _6143) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6143:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8724 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8724] == bool(mem[_8724])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9124 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9124] == bool(mem[_9124])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6063 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6144 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6144
                            require _6063 + (32 * _6144) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + (32 * _6144) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6144:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8725 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8725] == bool(mem[_8725])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9125 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9125] == bool(mem[_9125])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6064 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6145 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6145
                            require _6064 + (32 * _6145) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + (32 * _6145) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6145:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8726 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8726] == bool(mem[_8726])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9126 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9126] == bool(mem[_9126])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor4)
            require ext_code.size(stor5)
            staticcall stor5.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor4)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor5) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor5 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1436 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1453 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1436 + (32 * _1453) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + (32 * _1453) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3444 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3444] == mem[_3444]
                    mem[mem[64] + 4] = this.address
                    if mem[_3444]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3592 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3601 = mem[_3592]
                        require mem[_3592] == mem[_3592]
                        _3655 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 32] = stor6
                        if 1 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3655 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3655 + 100] = _3601
                        mem[_3655 + 132] = 1
                        mem[_3655 + 164] = 160
                        mem[_3655 + 260] = mem[_3655]
                        idx = 0
                        s = _3655 + 32
                        t = _3655 + 292
                        while idx < mem[_3655]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3655 + 196] = this.address
                        mem[_3655 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3655 + (32 * mem[_3655]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6045 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6077 = mem[_6045]
                        require mem[_6045] <= test266151307()
                        require _6045 + mem[_6045] + 31 < _6045 + return_data.size
                        _6166 = mem[_6045 + mem[_6045]]
                        if mem[_6045 + mem[_6045]] > test266151307():
                            revert with 'NH{q', 65
                        if _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1 > test266151307() or floor32(mem[_6045 + mem[_6045]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1
                        mem[_6045 + ceil32(return_data.size)] = _6166
                        require _6077 + (32 * _6166) + 32 <= return_data.size
                        idx = _6045 + _6077 + 32
                        s = _6045 + ceil32(return_data.size) + 32
                        while idx < _6045 + _6077 + (32 * _6166) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6166:
                            revert with 'NH{q', 50
                        if mem[_6045 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8731 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8731] == bool(mem[_8731])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9131 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9131] == bool(mem[_9131])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3620] == mem[_3620]
                        if mem[_3620]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3695 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3744 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3695 + 100] = 32
                        mem[_3695 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3810 = mem[_3744]
                        mem[_3695 + 164 len ceil32(mem[_3744])] = mem[_3744 + 32 len ceil32(mem[_3744])]
                        if ceil32(_3810) <= _3810:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8927 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9007 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8927 + (32 * _9007) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8927 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8927 + (32 * _9007) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9007:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10559 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10559] == bool(mem[_10559])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10879 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10879] == bool(mem[_10879])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8928 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9008 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8928 + (32 * _9008) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8928 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8928 + (32 * _9008) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9008:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10560] == bool(mem[_10560])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10880 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10880] == bool(mem[_10880])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8929 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9009 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9009
                                    require _8929 + (32 * _9009) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + (32 * _9009) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9009:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10561 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10561] == bool(mem[_10561])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10881 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10881] == bool(mem[_10881])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8930 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9010 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9010
                                    require _8930 + (32 * _9010) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + (32 * _9010) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9010:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10562 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10562] == bool(mem[_10562])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10882 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10882] == bool(mem[_10882])
                        else:
                            mem[_3695 + _3810 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8931 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9011 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8931 + (32 * _9011) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8931 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8931 + (32 * _9011) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9011:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10563 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10563] == bool(mem[_10563])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10883 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10883] == bool(mem[_10883])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8932 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9012 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8932 + (32 * _9012) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8932 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8932 + (32 * _9012) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9012:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10564 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10564] == bool(mem[_10564])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10884 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10884] == bool(mem[_10884])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8933 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9013 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9013
                                    require _8933 + (32 * _9013) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + (32 * _9013) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9013:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10565 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10565] == bool(mem[_10565])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10885 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10885] == bool(mem[_10885])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8934 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9014 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9014
                                    require _8934 + (32 * _9014) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + (32 * _9014) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9014:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10566 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10566] == bool(mem[_10566])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10886 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10886] == bool(mem[_10886])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1437 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1454 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1437 + (32 * _1454) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + (32 * _1454) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3445 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3445] == mem[_3445]
                    mem[mem[64] + 4] = this.address
                    if mem[_3445]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3593 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3602 = mem[_3593]
                        require mem[_3593] == mem[_3593]
                        _3656 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 32] = stor6
                        if 1 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3656 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3656 + 100] = _3602
                        mem[_3656 + 132] = 1
                        mem[_3656 + 164] = 160
                        mem[_3656 + 260] = mem[_3656]
                        idx = 0
                        s = _3656 + 32
                        t = _3656 + 292
                        while idx < mem[_3656]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3656 + 196] = this.address
                        mem[_3656 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3656 + (32 * mem[_3656]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6048 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6080 = mem[_6048]
                        require mem[_6048] <= test266151307()
                        require _6048 + mem[_6048] + 31 < _6048 + return_data.size
                        _6171 = mem[_6048 + mem[_6048]]
                        if mem[_6048 + mem[_6048]] > test266151307():
                            revert with 'NH{q', 65
                        if _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1 > test266151307() or floor32(mem[_6048 + mem[_6048]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1
                        mem[_6048 + ceil32(return_data.size)] = _6171
                        require _6080 + (32 * _6171) + 32 <= return_data.size
                        idx = _6048 + _6080 + 32
                        s = _6048 + ceil32(return_data.size) + 32
                        while idx < _6048 + _6080 + (32 * _6171) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6171:
                            revert with 'NH{q', 50
                        if mem[_6048 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8732 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8732] == bool(mem[_8732])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9132 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9132] == bool(mem[_9132])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3621 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3621] == mem[_3621]
                        if mem[_3621]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3697 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3746 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3697 + 100] = 32
                        mem[_3697 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3811 = mem[_3746]
                        mem[_3697 + 164 len ceil32(mem[_3746])] = mem[_3746 + 32 len ceil32(mem[_3746])]
                        if ceil32(_3811) <= _3811:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8935 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9015 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9015
                                    require _8935 + (32 * _9015) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8935 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8935 + (32 * _9015) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9015:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10567 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10567] == bool(mem[_10567])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10887 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10887] == bool(mem[_10887])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8936 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9016 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9016
                                    require _8936 + (32 * _9016) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8936 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8936 + (32 * _9016) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9016:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10568 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10568] == bool(mem[_10568])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10888 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10888] == bool(mem[_10888])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8937 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9017 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9017
                                    require _8937 + (32 * _9017) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + (32 * _9017) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9017:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10569 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10569] == bool(mem[_10569])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10889 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10889] == bool(mem[_10889])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8938 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9018 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9018
                                    require _8938 + (32 * _9018) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + (32 * _9018) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9018:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10570 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10570] == bool(mem[_10570])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10890 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10890] == bool(mem[_10890])
                        else:
                            mem[_3697 + _3811 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8939 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9019 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9019
                                    require _8939 + (32 * _9019) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8939 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8939 + (32 * _9019) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9019:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10571 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10571] == bool(mem[_10571])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10891 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10891] == bool(mem[_10891])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8940 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9020 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9020
                                    require _8940 + (32 * _9020) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8940 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8940 + (32 * _9020) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9020:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10572] == bool(mem[_10572])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10892 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10892] == bool(mem[_10892])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8941 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9021 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9021
                                    require _8941 + (32 * _9021) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + (32 * _9021) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9021:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10573 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10573] == bool(mem[_10573])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10893 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10893] == bool(mem[_10893])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8942 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9022 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9022
                                    require _8942 + (32 * _9022) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + (32 * _9022) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9022:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10574 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10574] == bool(mem[_10574])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10894 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10894] == bool(mem[_10894])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1438 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1455 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1438 + (32 * _1455) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + (32 * _1455) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3446 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3446] == mem[_3446]
                    mem[mem[64] + 4] = this.address
                    if mem[_3446]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3594 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3603 = mem[_3594]
                        require mem[_3594] == mem[_3594]
                        _3657 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 32] = stor6
                        if 1 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3657 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3657 + 100] = _3603
                        mem[_3657 + 132] = 1
                        mem[_3657 + 164] = 160
                        mem[_3657 + 260] = mem[_3657]
                        idx = 0
                        s = _3657 + 32
                        t = _3657 + 292
                        while idx < mem[_3657]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3657 + 196] = this.address
                        mem[_3657 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3657 + (32 * mem[_3657]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6051 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6083 = mem[_6051]
                        require mem[_6051] <= test266151307()
                        require _6051 + mem[_6051] + 31 < _6051 + return_data.size
                        _6176 = mem[_6051 + mem[_6051]]
                        if mem[_6051 + mem[_6051]] > test266151307():
                            revert with 'NH{q', 65
                        if _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1 > test266151307() or floor32(mem[_6051 + mem[_6051]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1
                        mem[_6051 + ceil32(return_data.size)] = _6176
                        require _6083 + (32 * _6176) + 32 <= return_data.size
                        idx = _6051 + _6083 + 32
                        s = _6051 + ceil32(return_data.size) + 32
                        while idx < _6051 + _6083 + (32 * _6176) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6176:
                            revert with 'NH{q', 50
                        if mem[_6051 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8733 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8733] == bool(mem[_8733])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9133 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9133] == bool(mem[_9133])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3622 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3622] == mem[_3622]
                        if mem[_3622]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3699 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3748 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3699 + 100] = 32
                        mem[_3699 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3812 = mem[_3748]
                        mem[_3699 + 164 len ceil32(mem[_3748])] = mem[_3748 + 32 len ceil32(mem[_3748])]
                        if ceil32(_3812) <= _3812:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8943 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9023 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9023
                                    require _8943 + (32 * _9023) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8943 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8943 + (32 * _9023) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9023:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10575 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10575] == bool(mem[_10575])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10895 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10895] == bool(mem[_10895])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8944 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9024 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9024
                                    require _8944 + (32 * _9024) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8944 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8944 + (32 * _9024) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9024:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10576 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10576] == bool(mem[_10576])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10896 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10896] == bool(mem[_10896])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8945 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9025 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9025
                                    require _8945 + (32 * _9025) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + (32 * _9025) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9025:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10577 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10577] == bool(mem[_10577])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10897 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10897] == bool(mem[_10897])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8946 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9026 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9026
                                    require _8946 + (32 * _9026) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + (32 * _9026) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9026:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10578 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10578] == bool(mem[_10578])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10898 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10898] == bool(mem[_10898])
                        else:
                            mem[_3699 + _3812 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8947 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9027 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9027
                                    require _8947 + (32 * _9027) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8947 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8947 + (32 * _9027) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9027:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10579 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10579] == bool(mem[_10579])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10899 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10899] == bool(mem[_10899])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8948 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9028 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9028
                                    require _8948 + (32 * _9028) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8948 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8948 + (32 * _9028) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9028:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10580 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10580] == bool(mem[_10580])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10900 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10900] == bool(mem[_10900])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8949 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9029 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9029
                                    require _8949 + (32 * _9029) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + (32 * _9029) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9029:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10581 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10581] == bool(mem[_10581])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10901 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10901] == bool(mem[_10901])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8950 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9030 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9030
                                    require _8950 + (32 * _9030) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + (32 * _9030) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9030:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10582 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10582] == bool(mem[_10582])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10902 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10902] == bool(mem[_10902])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1439 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1456 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1439 + (32 * _1456) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + (32 * _1456) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3447 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3447] == mem[_3447]
                    mem[mem[64] + 4] = this.address
                    if mem[_3447]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3595 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3604 = mem[_3595]
                        require mem[_3595] == mem[_3595]
                        _3658 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 32] = stor6
                        if 1 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3658 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3658 + 100] = _3604
                        mem[_3658 + 132] = 1
                        mem[_3658 + 164] = 160
                        mem[_3658 + 260] = mem[_3658]
                        idx = 0
                        s = _3658 + 32
                        t = _3658 + 292
                        while idx < mem[_3658]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3658 + 196] = this.address
                        mem[_3658 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3658 + (32 * mem[_3658]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6054 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6086 = mem[_6054]
                        require mem[_6054] <= test266151307()
                        require _6054 + mem[_6054] + 31 < _6054 + return_data.size
                        _6181 = mem[_6054 + mem[_6054]]
                        if mem[_6054 + mem[_6054]] > test266151307():
                            revert with 'NH{q', 65
                        if _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1 > test266151307() or floor32(mem[_6054 + mem[_6054]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1
                        mem[_6054 + ceil32(return_data.size)] = _6181
                        require _6086 + (32 * _6181) + 32 <= return_data.size
                        idx = _6054 + _6086 + 32
                        s = _6054 + ceil32(return_data.size) + 32
                        while idx < _6054 + _6086 + (32 * _6181) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6181:
                            revert with 'NH{q', 50
                        if mem[_6054 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8734 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8734] == bool(mem[_8734])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9134 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9134] == bool(mem[_9134])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3623 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3623] == mem[_3623]
                        if mem[_3623]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3701 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3750 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3701 + 100] = 32
                        mem[_3701 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3813 = mem[_3750]
                        mem[_3701 + 164 len ceil32(mem[_3750])] = mem[_3750 + 32 len ceil32(mem[_3750])]
                        if ceil32(_3813) <= _3813:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8951 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9031 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8951 + (32 * _9031) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8951 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8951 + (32 * _9031) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9031:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10583 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10583] == bool(mem[_10583])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10903 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10903] == bool(mem[_10903])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8952 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9032 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8952 + (32 * _9032) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8952 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8952 + (32 * _9032) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9032:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10584 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10584] == bool(mem[_10584])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10904 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10904] == bool(mem[_10904])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8953 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9033 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8953 + (32 * _9033) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + (32 * _9033) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9033:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10585 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10585] == bool(mem[_10585])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10905 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10905] == bool(mem[_10905])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8954 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9034 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8954 + (32 * _9034) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + (32 * _9034) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9034:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10586 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10586] == bool(mem[_10586])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10906 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10906] == bool(mem[_10906])
                        else:
                            mem[_3701 + _3813 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8955 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9035 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8955 + (32 * _9035) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8955 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8955 + (32 * _9035) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9035:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10587 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10587] == bool(mem[_10587])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10907 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10907] == bool(mem[_10907])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8956 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9036 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8956 + (32 * _9036) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8956 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8956 + (32 * _9036) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9036:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10588 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10588] == bool(mem[_10588])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10908 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10908] == bool(mem[_10908])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8957 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9037 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8957 + (32 * _9037) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + (32 * _9037) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9037:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10589 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10589] == bool(mem[_10589])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10909 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10909] == bool(mem[_10909])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8958 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9038 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8958 + (32 * _9038) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + (32 * _9038) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9038:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10590 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10590] == bool(mem[_10590])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10910 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10910] == bool(mem[_10910])
    call stor0 with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_48c5b27e(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    if arg4.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg4.length)) + 97 > test266151307() or ceil32(ceil32(arg4.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg4.length
    require arg4 + arg4.length + 36 <= calldata.size
    mem[128 len arg4.length] = arg4[all]
    if stor1 != msg.sender:
        revert with 0, 'wrong pair address'
    mem[ceil32(ceil32(arg4.length)) + 101] = this.address
    if not address(stor4):
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor3)
        require ext_code.size(stor6)
        staticcall stor6.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor3)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor6)
            staticcall stor6.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor3))
            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _400 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _418 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _400 + (32 * _418) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + (32 * _418) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            if 1 >= _418:
                revert with 'NH{q', 50
            if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 257] <= stor7:
                revert with 0, 'received < initial balance'
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
               value stor7 wei
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1389 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1389] == bool(mem[_1389])
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = stor7
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, stor7
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1477 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1477] == bool(mem[_1477])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor6) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor6 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1428 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1445 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1428 + (32 * _1445) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + (32 * _1445) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1445:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3364 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3364] == bool(mem[_3364])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3495 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3495] == bool(mem[_3495])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1429 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1446 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1429 + (32 * _1446) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + (32 * _1446) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1446:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3365 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3365] == bool(mem[_3365])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3496 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3496] == bool(mem[_3496])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1430 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1447 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1430 + (32 * _1447) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + (32 * _1447) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1447:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3366 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3366] == bool(mem[_3366])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3497 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3497] == bool(mem[_3497])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1431 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1448 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1431 + (32 * _1448) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + (32 * _1448) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1448:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3367 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3367] == bool(mem[_3367])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3498 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3498] == bool(mem[_3498])
    else:
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor4)
        require ext_code.size(stor5)
        staticcall stor5.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor4)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor5)
            staticcall stor5.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor5
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor4))
            call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _403 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _423 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _403 + (32 * _423) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + (32 * _423) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1458 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1458] == mem[_1458]
            mem[mem[64] + 4] = this.address
            if mem[_1458]:
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1556 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1565 = mem[_1556]
                require mem[_1556] == mem[_1556]
                _1593 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 32] = stor6
                if 1 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                mem[_1593 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                mem[_1593 + 100] = _1565
                mem[_1593 + 132] = 1
                mem[_1593 + 164] = 160
                mem[_1593 + 260] = mem[_1593]
                idx = 0
                s = _1593 + 32
                t = _1593 + 292
                while idx < mem[_1593]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1593 + 196] = this.address
                mem[_1593 + 228] = stor8
                require ext_code.size(address(stor3))
                call address(stor3).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _1593 + (32 * mem[_1593]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3407 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3410 = mem[_3407]
                require mem[_3407] <= test266151307()
                require _3407 + mem[_3407] + 31 < _3407 + return_data.size
                _3427 = mem[_3407 + mem[_3407]]
                if mem[_3407 + mem[_3407]] > test266151307():
                    revert with 'NH{q', 65
                if _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1 > test266151307() or floor32(mem[_3407 + mem[_3407]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1
                mem[_3407 + ceil32(return_data.size)] = _3427
                require _3410 + (32 * _3427) + 32 <= return_data.size
                idx = _3407 + _3410 + 32
                s = _3407 + ceil32(return_data.size) + 32
                while idx < _3407 + _3410 + (32 * _3427) + 32:
                    require mem[idx] == mem[idx]
                    mem[s] = mem[idx]
                    idx = idx + 32
                    s = s + 32
                    continue 
                if 1 >= _3427:
                    revert with 'NH{q', 50
                if mem[_3407 + ceil32(return_data.size) + 64] <= stor7:
                    revert with 0, 'received < initial balance'
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                   value stor7 wei
                     gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5830 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_5830] == bool(mem[_5830])
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor7
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, stor7
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6411 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_6411] == bool(mem[_6411])
            else:
                mem[mem[64] + 36] = address(stor3)
                require ext_code.size(stor6)
                staticcall stor6.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(stor3)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1575] == mem[_1575]
                if mem[_1575]:
                    revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                _1613 = mem[64]
                mem[mem[64] + 36] = address(stor3)
                mem[mem[64] + 68] = -1
                _1657 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                mem[64] = mem[64] + 164
                mem[_1613 + 100] = 32
                mem[_1613 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if ext_code.size(stor6) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _1712 = mem[_1657]
                mem[_1613 + 164 len ceil32(mem[_1657])] = mem[_1657 + 32 len ceil32(mem[_1657])]
                if ceil32(_1712) <= _1712:
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6057 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6138 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6057 + (32 * _6138) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6057 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6057 + (32 * _6138) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6138:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8719 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8719] == bool(mem[_8719])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9119] == bool(mem[_9119])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6058 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6139 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6058 + (32 * _6139) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6058 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6058 + (32 * _6139) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6139:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8720 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8720] == bool(mem[_8720])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9120 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9120] == bool(mem[_9120])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6059 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6140 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6140
                            require _6059 + (32 * _6140) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + (32 * _6140) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6140:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8721 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8721] == bool(mem[_8721])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9121 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9121] == bool(mem[_9121])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6060 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6141 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6141
                            require _6060 + (32 * _6141) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + (32 * _6141) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6141:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8722 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8722] == bool(mem[_8722])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9122 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9122] == bool(mem[_9122])
                else:
                    mem[_1613 + _1712 + 164] = 0
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6061 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6142 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6061 + (32 * _6142) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6061 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6061 + (32 * _6142) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6142:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8723 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8723] == bool(mem[_8723])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9123 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9123] == bool(mem[_9123])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6062 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6143 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6062 + (32 * _6143) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6062 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6062 + (32 * _6143) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6143:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8724 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8724] == bool(mem[_8724])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9124 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9124] == bool(mem[_9124])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6063 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6144 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6144
                            require _6063 + (32 * _6144) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + (32 * _6144) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6144:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8725 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8725] == bool(mem[_8725])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9125 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9125] == bool(mem[_9125])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6064 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6145 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6145
                            require _6064 + (32 * _6145) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + (32 * _6145) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6145:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8726 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8726] == bool(mem[_8726])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9126 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9126] == bool(mem[_9126])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor4)
            require ext_code.size(stor5)
            staticcall stor5.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor4)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor5) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor5 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1436 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1453 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1436 + (32 * _1453) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + (32 * _1453) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3444 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3444] == mem[_3444]
                    mem[mem[64] + 4] = this.address
                    if mem[_3444]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3592 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3601 = mem[_3592]
                        require mem[_3592] == mem[_3592]
                        _3655 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 32] = stor6
                        if 1 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3655 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3655 + 100] = _3601
                        mem[_3655 + 132] = 1
                        mem[_3655 + 164] = 160
                        mem[_3655 + 260] = mem[_3655]
                        idx = 0
                        s = _3655 + 32
                        t = _3655 + 292
                        while idx < mem[_3655]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3655 + 196] = this.address
                        mem[_3655 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3655 + (32 * mem[_3655]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6045 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6077 = mem[_6045]
                        require mem[_6045] <= test266151307()
                        require _6045 + mem[_6045] + 31 < _6045 + return_data.size
                        _6166 = mem[_6045 + mem[_6045]]
                        if mem[_6045 + mem[_6045]] > test266151307():
                            revert with 'NH{q', 65
                        if _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1 > test266151307() or floor32(mem[_6045 + mem[_6045]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1
                        mem[_6045 + ceil32(return_data.size)] = _6166
                        require _6077 + (32 * _6166) + 32 <= return_data.size
                        idx = _6045 + _6077 + 32
                        s = _6045 + ceil32(return_data.size) + 32
                        while idx < _6045 + _6077 + (32 * _6166) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6166:
                            revert with 'NH{q', 50
                        if mem[_6045 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8731 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8731] == bool(mem[_8731])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9131 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9131] == bool(mem[_9131])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3620] == mem[_3620]
                        if mem[_3620]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3695 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3744 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3695 + 100] = 32
                        mem[_3695 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3810 = mem[_3744]
                        mem[_3695 + 164 len ceil32(mem[_3744])] = mem[_3744 + 32 len ceil32(mem[_3744])]
                        if ceil32(_3810) <= _3810:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8927 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9007 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8927 + (32 * _9007) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8927 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8927 + (32 * _9007) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9007:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10559 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10559] == bool(mem[_10559])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10879 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10879] == bool(mem[_10879])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8928 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9008 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8928 + (32 * _9008) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8928 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8928 + (32 * _9008) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9008:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10560] == bool(mem[_10560])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10880 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10880] == bool(mem[_10880])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8929 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9009 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9009
                                    require _8929 + (32 * _9009) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + (32 * _9009) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9009:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10561 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10561] == bool(mem[_10561])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10881 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10881] == bool(mem[_10881])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8930 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9010 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9010
                                    require _8930 + (32 * _9010) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + (32 * _9010) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9010:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10562 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10562] == bool(mem[_10562])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10882 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10882] == bool(mem[_10882])
                        else:
                            mem[_3695 + _3810 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8931 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9011 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8931 + (32 * _9011) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8931 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8931 + (32 * _9011) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9011:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10563 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10563] == bool(mem[_10563])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10883 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10883] == bool(mem[_10883])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8932 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9012 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8932 + (32 * _9012) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8932 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8932 + (32 * _9012) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9012:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10564 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10564] == bool(mem[_10564])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10884 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10884] == bool(mem[_10884])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8933 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9013 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9013
                                    require _8933 + (32 * _9013) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + (32 * _9013) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9013:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10565 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10565] == bool(mem[_10565])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10885 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10885] == bool(mem[_10885])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8934 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9014 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9014
                                    require _8934 + (32 * _9014) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + (32 * _9014) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9014:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10566 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10566] == bool(mem[_10566])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10886 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10886] == bool(mem[_10886])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1437 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1454 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1437 + (32 * _1454) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + (32 * _1454) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3445 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3445] == mem[_3445]
                    mem[mem[64] + 4] = this.address
                    if mem[_3445]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3593 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3602 = mem[_3593]
                        require mem[_3593] == mem[_3593]
                        _3656 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 32] = stor6
                        if 1 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3656 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3656 + 100] = _3602
                        mem[_3656 + 132] = 1
                        mem[_3656 + 164] = 160
                        mem[_3656 + 260] = mem[_3656]
                        idx = 0
                        s = _3656 + 32
                        t = _3656 + 292
                        while idx < mem[_3656]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3656 + 196] = this.address
                        mem[_3656 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3656 + (32 * mem[_3656]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6048 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6080 = mem[_6048]
                        require mem[_6048] <= test266151307()
                        require _6048 + mem[_6048] + 31 < _6048 + return_data.size
                        _6171 = mem[_6048 + mem[_6048]]
                        if mem[_6048 + mem[_6048]] > test266151307():
                            revert with 'NH{q', 65
                        if _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1 > test266151307() or floor32(mem[_6048 + mem[_6048]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1
                        mem[_6048 + ceil32(return_data.size)] = _6171
                        require _6080 + (32 * _6171) + 32 <= return_data.size
                        idx = _6048 + _6080 + 32
                        s = _6048 + ceil32(return_data.size) + 32
                        while idx < _6048 + _6080 + (32 * _6171) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6171:
                            revert with 'NH{q', 50
                        if mem[_6048 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8732 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8732] == bool(mem[_8732])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9132 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9132] == bool(mem[_9132])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3621 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3621] == mem[_3621]
                        if mem[_3621]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3697 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3746 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3697 + 100] = 32
                        mem[_3697 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3811 = mem[_3746]
                        mem[_3697 + 164 len ceil32(mem[_3746])] = mem[_3746 + 32 len ceil32(mem[_3746])]
                        if ceil32(_3811) <= _3811:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8935 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9015 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9015
                                    require _8935 + (32 * _9015) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8935 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8935 + (32 * _9015) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9015:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10567 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10567] == bool(mem[_10567])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10887 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10887] == bool(mem[_10887])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8936 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9016 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9016
                                    require _8936 + (32 * _9016) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8936 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8936 + (32 * _9016) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9016:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10568 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10568] == bool(mem[_10568])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10888 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10888] == bool(mem[_10888])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8937 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9017 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9017
                                    require _8937 + (32 * _9017) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + (32 * _9017) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9017:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10569 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10569] == bool(mem[_10569])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10889 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10889] == bool(mem[_10889])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8938 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9018 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9018
                                    require _8938 + (32 * _9018) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + (32 * _9018) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9018:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10570 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10570] == bool(mem[_10570])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10890 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10890] == bool(mem[_10890])
                        else:
                            mem[_3697 + _3811 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8939 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9019 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9019
                                    require _8939 + (32 * _9019) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8939 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8939 + (32 * _9019) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9019:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10571 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10571] == bool(mem[_10571])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10891 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10891] == bool(mem[_10891])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8940 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9020 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9020
                                    require _8940 + (32 * _9020) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8940 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8940 + (32 * _9020) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9020:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10572] == bool(mem[_10572])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10892 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10892] == bool(mem[_10892])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8941 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9021 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9021
                                    require _8941 + (32 * _9021) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + (32 * _9021) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9021:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10573 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10573] == bool(mem[_10573])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10893 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10893] == bool(mem[_10893])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8942 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9022 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9022
                                    require _8942 + (32 * _9022) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + (32 * _9022) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9022:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10574 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10574] == bool(mem[_10574])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10894 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10894] == bool(mem[_10894])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1438 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1455 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1438 + (32 * _1455) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + (32 * _1455) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3446 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3446] == mem[_3446]
                    mem[mem[64] + 4] = this.address
                    if mem[_3446]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3594 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3603 = mem[_3594]
                        require mem[_3594] == mem[_3594]
                        _3657 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 32] = stor6
                        if 1 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3657 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3657 + 100] = _3603
                        mem[_3657 + 132] = 1
                        mem[_3657 + 164] = 160
                        mem[_3657 + 260] = mem[_3657]
                        idx = 0
                        s = _3657 + 32
                        t = _3657 + 292
                        while idx < mem[_3657]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3657 + 196] = this.address
                        mem[_3657 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3657 + (32 * mem[_3657]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6051 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6083 = mem[_6051]
                        require mem[_6051] <= test266151307()
                        require _6051 + mem[_6051] + 31 < _6051 + return_data.size
                        _6176 = mem[_6051 + mem[_6051]]
                        if mem[_6051 + mem[_6051]] > test266151307():
                            revert with 'NH{q', 65
                        if _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1 > test266151307() or floor32(mem[_6051 + mem[_6051]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1
                        mem[_6051 + ceil32(return_data.size)] = _6176
                        require _6083 + (32 * _6176) + 32 <= return_data.size
                        idx = _6051 + _6083 + 32
                        s = _6051 + ceil32(return_data.size) + 32
                        while idx < _6051 + _6083 + (32 * _6176) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6176:
                            revert with 'NH{q', 50
                        if mem[_6051 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8733 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8733] == bool(mem[_8733])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9133 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9133] == bool(mem[_9133])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3622 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3622] == mem[_3622]
                        if mem[_3622]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3699 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3748 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3699 + 100] = 32
                        mem[_3699 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3812 = mem[_3748]
                        mem[_3699 + 164 len ceil32(mem[_3748])] = mem[_3748 + 32 len ceil32(mem[_3748])]
                        if ceil32(_3812) <= _3812:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8943 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9023 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9023
                                    require _8943 + (32 * _9023) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8943 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8943 + (32 * _9023) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9023:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10575 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10575] == bool(mem[_10575])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10895 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10895] == bool(mem[_10895])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8944 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9024 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9024
                                    require _8944 + (32 * _9024) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8944 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8944 + (32 * _9024) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9024:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10576 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10576] == bool(mem[_10576])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10896 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10896] == bool(mem[_10896])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8945 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9025 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9025
                                    require _8945 + (32 * _9025) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + (32 * _9025) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9025:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10577 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10577] == bool(mem[_10577])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10897 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10897] == bool(mem[_10897])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8946 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9026 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9026
                                    require _8946 + (32 * _9026) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + (32 * _9026) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9026:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10578 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10578] == bool(mem[_10578])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10898 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10898] == bool(mem[_10898])
                        else:
                            mem[_3699 + _3812 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8947 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9027 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9027
                                    require _8947 + (32 * _9027) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8947 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8947 + (32 * _9027) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9027:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10579 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10579] == bool(mem[_10579])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10899 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10899] == bool(mem[_10899])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8948 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9028 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9028
                                    require _8948 + (32 * _9028) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8948 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8948 + (32 * _9028) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9028:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10580 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10580] == bool(mem[_10580])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10900 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10900] == bool(mem[_10900])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8949 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9029 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9029
                                    require _8949 + (32 * _9029) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + (32 * _9029) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9029:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10581 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10581] == bool(mem[_10581])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10901 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10901] == bool(mem[_10901])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8950 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9030 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9030
                                    require _8950 + (32 * _9030) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + (32 * _9030) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9030:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10582 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10582] == bool(mem[_10582])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10902 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10902] == bool(mem[_10902])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1439 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1456 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1439 + (32 * _1456) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + (32 * _1456) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3447 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3447] == mem[_3447]
                    mem[mem[64] + 4] = this.address
                    if mem[_3447]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3595 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3604 = mem[_3595]
                        require mem[_3595] == mem[_3595]
                        _3658 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 32] = stor6
                        if 1 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3658 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3658 + 100] = _3604
                        mem[_3658 + 132] = 1
                        mem[_3658 + 164] = 160
                        mem[_3658 + 260] = mem[_3658]
                        idx = 0
                        s = _3658 + 32
                        t = _3658 + 292
                        while idx < mem[_3658]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3658 + 196] = this.address
                        mem[_3658 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3658 + (32 * mem[_3658]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6054 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6086 = mem[_6054]
                        require mem[_6054] <= test266151307()
                        require _6054 + mem[_6054] + 31 < _6054 + return_data.size
                        _6181 = mem[_6054 + mem[_6054]]
                        if mem[_6054 + mem[_6054]] > test266151307():
                            revert with 'NH{q', 65
                        if _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1 > test266151307() or floor32(mem[_6054 + mem[_6054]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1
                        mem[_6054 + ceil32(return_data.size)] = _6181
                        require _6086 + (32 * _6181) + 32 <= return_data.size
                        idx = _6054 + _6086 + 32
                        s = _6054 + ceil32(return_data.size) + 32
                        while idx < _6054 + _6086 + (32 * _6181) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6181:
                            revert with 'NH{q', 50
                        if mem[_6054 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8734 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8734] == bool(mem[_8734])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9134 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9134] == bool(mem[_9134])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3623 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3623] == mem[_3623]
                        if mem[_3623]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3701 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3750 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3701 + 100] = 32
                        mem[_3701 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3813 = mem[_3750]
                        mem[_3701 + 164 len ceil32(mem[_3750])] = mem[_3750 + 32 len ceil32(mem[_3750])]
                        if ceil32(_3813) <= _3813:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8951 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9031 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8951 + (32 * _9031) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8951 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8951 + (32 * _9031) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9031:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10583 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10583] == bool(mem[_10583])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10903 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10903] == bool(mem[_10903])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8952 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9032 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8952 + (32 * _9032) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8952 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8952 + (32 * _9032) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9032:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10584 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10584] == bool(mem[_10584])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10904 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10904] == bool(mem[_10904])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8953 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9033 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8953 + (32 * _9033) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + (32 * _9033) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9033:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10585 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10585] == bool(mem[_10585])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10905 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10905] == bool(mem[_10905])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8954 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9034 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8954 + (32 * _9034) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + (32 * _9034) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9034:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10586 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10586] == bool(mem[_10586])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10906 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10906] == bool(mem[_10906])
                        else:
                            mem[_3701 + _3813 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8955 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9035 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8955 + (32 * _9035) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8955 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8955 + (32 * _9035) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9035:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10587 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10587] == bool(mem[_10587])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10907 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10907] == bool(mem[_10907])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8956 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9036 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8956 + (32 * _9036) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8956 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8956 + (32 * _9036) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9036:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10588 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10588] == bool(mem[_10588])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10908 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10908] == bool(mem[_10908])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8957 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9037 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8957 + (32 * _9037) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + (32 * _9037) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9037:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10589 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10589] == bool(mem[_10589])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10909 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10909] == bool(mem[_10909])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8958 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9038 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8958 + (32 * _9038) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + (32 * _9038) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9038:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10590 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10590] == bool(mem[_10590])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10910 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10910] == bool(mem[_10910])
    call stor0 with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function jetswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    if arg4.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg4.length)) + 97 > test266151307() or ceil32(ceil32(arg4.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg4.length
    require arg4 + arg4.length + 36 <= calldata.size
    mem[128 len arg4.length] = arg4[all]
    if stor1 != msg.sender:
        revert with 0, 'wrong pair address'
    mem[ceil32(ceil32(arg4.length)) + 101] = this.address
    if not address(stor4):
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor3)
        require ext_code.size(stor6)
        staticcall stor6.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor3)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor6)
            staticcall stor6.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor3))
            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _400 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _418 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _400 + (32 * _418) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + (32 * _418) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            if 1 >= _418:
                revert with 'NH{q', 50
            if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 257] <= stor7:
                revert with 0, 'received < initial balance'
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
               value stor7 wei
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1389 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1389] == bool(mem[_1389])
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = stor7
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, stor7
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1477 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1477] == bool(mem[_1477])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor6) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor6 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1428 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1445 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1428 + (32 * _1445) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + (32 * _1445) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1445:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3364 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3364] == bool(mem[_3364])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3495 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3495] == bool(mem[_3495])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1429 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1446 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1429 + (32 * _1446) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + (32 * _1446) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1446:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3365 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3365] == bool(mem[_3365])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3496 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3496] == bool(mem[_3496])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1430 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1447 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1430 + (32 * _1447) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + (32 * _1447) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1447:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3366 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3366] == bool(mem[_3366])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3497 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3497] == bool(mem[_3497])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1431 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1448 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1431 + (32 * _1448) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + (32 * _1448) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1448:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3367 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3367] == bool(mem[_3367])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3498 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3498] == bool(mem[_3498])
    else:
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor4)
        require ext_code.size(stor5)
        staticcall stor5.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor4)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor5)
            staticcall stor5.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor5
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor4))
            call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _403 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _423 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _403 + (32 * _423) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + (32 * _423) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1458 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1458] == mem[_1458]
            mem[mem[64] + 4] = this.address
            if mem[_1458]:
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1556 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1565 = mem[_1556]
                require mem[_1556] == mem[_1556]
                _1593 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 32] = stor6
                if 1 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                mem[_1593 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                mem[_1593 + 100] = _1565
                mem[_1593 + 132] = 1
                mem[_1593 + 164] = 160
                mem[_1593 + 260] = mem[_1593]
                idx = 0
                s = _1593 + 32
                t = _1593 + 292
                while idx < mem[_1593]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1593 + 196] = this.address
                mem[_1593 + 228] = stor8
                require ext_code.size(address(stor3))
                call address(stor3).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _1593 + (32 * mem[_1593]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3407 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3410 = mem[_3407]
                require mem[_3407] <= test266151307()
                require _3407 + mem[_3407] + 31 < _3407 + return_data.size
                _3427 = mem[_3407 + mem[_3407]]
                if mem[_3407 + mem[_3407]] > test266151307():
                    revert with 'NH{q', 65
                if _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1 > test266151307() or floor32(mem[_3407 + mem[_3407]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1
                mem[_3407 + ceil32(return_data.size)] = _3427
                require _3410 + (32 * _3427) + 32 <= return_data.size
                idx = _3407 + _3410 + 32
                s = _3407 + ceil32(return_data.size) + 32
                while idx < _3407 + _3410 + (32 * _3427) + 32:
                    require mem[idx] == mem[idx]
                    mem[s] = mem[idx]
                    idx = idx + 32
                    s = s + 32
                    continue 
                if 1 >= _3427:
                    revert with 'NH{q', 50
                if mem[_3407 + ceil32(return_data.size) + 64] <= stor7:
                    revert with 0, 'received < initial balance'
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                   value stor7 wei
                     gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5830 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_5830] == bool(mem[_5830])
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor7
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, stor7
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6411 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_6411] == bool(mem[_6411])
            else:
                mem[mem[64] + 36] = address(stor3)
                require ext_code.size(stor6)
                staticcall stor6.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(stor3)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1575] == mem[_1575]
                if mem[_1575]:
                    revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                _1613 = mem[64]
                mem[mem[64] + 36] = address(stor3)
                mem[mem[64] + 68] = -1
                _1657 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                mem[64] = mem[64] + 164
                mem[_1613 + 100] = 32
                mem[_1613 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if ext_code.size(stor6) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _1712 = mem[_1657]
                mem[_1613 + 164 len ceil32(mem[_1657])] = mem[_1657 + 32 len ceil32(mem[_1657])]
                if ceil32(_1712) <= _1712:
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6057 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6138 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6057 + (32 * _6138) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6057 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6057 + (32 * _6138) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6138:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8719 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8719] == bool(mem[_8719])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9119] == bool(mem[_9119])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6058 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6139 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6058 + (32 * _6139) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6058 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6058 + (32 * _6139) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6139:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8720 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8720] == bool(mem[_8720])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9120 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9120] == bool(mem[_9120])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6059 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6140 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6140
                            require _6059 + (32 * _6140) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + (32 * _6140) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6140:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8721 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8721] == bool(mem[_8721])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9121 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9121] == bool(mem[_9121])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6060 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6141 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6141
                            require _6060 + (32 * _6141) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + (32 * _6141) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6141:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8722 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8722] == bool(mem[_8722])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9122 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9122] == bool(mem[_9122])
                else:
                    mem[_1613 + _1712 + 164] = 0
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6061 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6142 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6061 + (32 * _6142) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6061 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6061 + (32 * _6142) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6142:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8723 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8723] == bool(mem[_8723])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9123 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9123] == bool(mem[_9123])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6062 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6143 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6062 + (32 * _6143) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6062 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6062 + (32 * _6143) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6143:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8724 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8724] == bool(mem[_8724])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9124 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9124] == bool(mem[_9124])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6063 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6144 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6144
                            require _6063 + (32 * _6144) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + (32 * _6144) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6144:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8725 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8725] == bool(mem[_8725])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9125 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9125] == bool(mem[_9125])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6064 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6145 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6145
                            require _6064 + (32 * _6145) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + (32 * _6145) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6145:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8726 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8726] == bool(mem[_8726])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9126 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9126] == bool(mem[_9126])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor4)
            require ext_code.size(stor5)
            staticcall stor5.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor4)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor5) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor5 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1436 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1453 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1436 + (32 * _1453) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + (32 * _1453) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3444 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3444] == mem[_3444]
                    mem[mem[64] + 4] = this.address
                    if mem[_3444]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3592 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3601 = mem[_3592]
                        require mem[_3592] == mem[_3592]
                        _3655 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 32] = stor6
                        if 1 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3655 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3655 + 100] = _3601
                        mem[_3655 + 132] = 1
                        mem[_3655 + 164] = 160
                        mem[_3655 + 260] = mem[_3655]
                        idx = 0
                        s = _3655 + 32
                        t = _3655 + 292
                        while idx < mem[_3655]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3655 + 196] = this.address
                        mem[_3655 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3655 + (32 * mem[_3655]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6045 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6077 = mem[_6045]
                        require mem[_6045] <= test266151307()
                        require _6045 + mem[_6045] + 31 < _6045 + return_data.size
                        _6166 = mem[_6045 + mem[_6045]]
                        if mem[_6045 + mem[_6045]] > test266151307():
                            revert with 'NH{q', 65
                        if _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1 > test266151307() or floor32(mem[_6045 + mem[_6045]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1
                        mem[_6045 + ceil32(return_data.size)] = _6166
                        require _6077 + (32 * _6166) + 32 <= return_data.size
                        idx = _6045 + _6077 + 32
                        s = _6045 + ceil32(return_data.size) + 32
                        while idx < _6045 + _6077 + (32 * _6166) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6166:
                            revert with 'NH{q', 50
                        if mem[_6045 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8731 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8731] == bool(mem[_8731])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9131 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9131] == bool(mem[_9131])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3620] == mem[_3620]
                        if mem[_3620]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3695 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3744 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3695 + 100] = 32
                        mem[_3695 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3810 = mem[_3744]
                        mem[_3695 + 164 len ceil32(mem[_3744])] = mem[_3744 + 32 len ceil32(mem[_3744])]
                        if ceil32(_3810) <= _3810:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8927 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9007 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8927 + (32 * _9007) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8927 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8927 + (32 * _9007) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9007:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10559 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10559] == bool(mem[_10559])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10879 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10879] == bool(mem[_10879])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8928 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9008 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8928 + (32 * _9008) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8928 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8928 + (32 * _9008) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9008:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10560] == bool(mem[_10560])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10880 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10880] == bool(mem[_10880])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8929 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9009 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9009
                                    require _8929 + (32 * _9009) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + (32 * _9009) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9009:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10561 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10561] == bool(mem[_10561])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10881 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10881] == bool(mem[_10881])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8930 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9010 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9010
                                    require _8930 + (32 * _9010) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + (32 * _9010) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9010:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10562 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10562] == bool(mem[_10562])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10882 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10882] == bool(mem[_10882])
                        else:
                            mem[_3695 + _3810 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8931 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9011 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8931 + (32 * _9011) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8931 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8931 + (32 * _9011) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9011:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10563 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10563] == bool(mem[_10563])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10883 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10883] == bool(mem[_10883])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8932 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9012 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8932 + (32 * _9012) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8932 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8932 + (32 * _9012) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9012:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10564 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10564] == bool(mem[_10564])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10884 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10884] == bool(mem[_10884])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8933 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9013 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9013
                                    require _8933 + (32 * _9013) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + (32 * _9013) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9013:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10565 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10565] == bool(mem[_10565])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10885 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10885] == bool(mem[_10885])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8934 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9014 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9014
                                    require _8934 + (32 * _9014) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + (32 * _9014) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9014:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10566 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10566] == bool(mem[_10566])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10886 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10886] == bool(mem[_10886])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1437 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1454 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1437 + (32 * _1454) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + (32 * _1454) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3445 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3445] == mem[_3445]
                    mem[mem[64] + 4] = this.address
                    if mem[_3445]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3593 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3602 = mem[_3593]
                        require mem[_3593] == mem[_3593]
                        _3656 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 32] = stor6
                        if 1 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3656 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3656 + 100] = _3602
                        mem[_3656 + 132] = 1
                        mem[_3656 + 164] = 160
                        mem[_3656 + 260] = mem[_3656]
                        idx = 0
                        s = _3656 + 32
                        t = _3656 + 292
                        while idx < mem[_3656]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3656 + 196] = this.address
                        mem[_3656 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3656 + (32 * mem[_3656]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6048 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6080 = mem[_6048]
                        require mem[_6048] <= test266151307()
                        require _6048 + mem[_6048] + 31 < _6048 + return_data.size
                        _6171 = mem[_6048 + mem[_6048]]
                        if mem[_6048 + mem[_6048]] > test266151307():
                            revert with 'NH{q', 65
                        if _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1 > test266151307() or floor32(mem[_6048 + mem[_6048]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1
                        mem[_6048 + ceil32(return_data.size)] = _6171
                        require _6080 + (32 * _6171) + 32 <= return_data.size
                        idx = _6048 + _6080 + 32
                        s = _6048 + ceil32(return_data.size) + 32
                        while idx < _6048 + _6080 + (32 * _6171) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6171:
                            revert with 'NH{q', 50
                        if mem[_6048 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8732 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8732] == bool(mem[_8732])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9132 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9132] == bool(mem[_9132])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3621 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3621] == mem[_3621]
                        if mem[_3621]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3697 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3746 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3697 + 100] = 32
                        mem[_3697 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3811 = mem[_3746]
                        mem[_3697 + 164 len ceil32(mem[_3746])] = mem[_3746 + 32 len ceil32(mem[_3746])]
                        if ceil32(_3811) <= _3811:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8935 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9015 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9015
                                    require _8935 + (32 * _9015) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8935 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8935 + (32 * _9015) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9015:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10567 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10567] == bool(mem[_10567])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10887 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10887] == bool(mem[_10887])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8936 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9016 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9016
                                    require _8936 + (32 * _9016) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8936 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8936 + (32 * _9016) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9016:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10568 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10568] == bool(mem[_10568])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10888 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10888] == bool(mem[_10888])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8937 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9017 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9017
                                    require _8937 + (32 * _9017) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + (32 * _9017) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9017:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10569 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10569] == bool(mem[_10569])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10889 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10889] == bool(mem[_10889])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8938 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9018 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9018
                                    require _8938 + (32 * _9018) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + (32 * _9018) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9018:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10570 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10570] == bool(mem[_10570])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10890 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10890] == bool(mem[_10890])
                        else:
                            mem[_3697 + _3811 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8939 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9019 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9019
                                    require _8939 + (32 * _9019) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8939 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8939 + (32 * _9019) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9019:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10571 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10571] == bool(mem[_10571])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10891 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10891] == bool(mem[_10891])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8940 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9020 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9020
                                    require _8940 + (32 * _9020) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8940 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8940 + (32 * _9020) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9020:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10572] == bool(mem[_10572])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10892 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10892] == bool(mem[_10892])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8941 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9021 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9021
                                    require _8941 + (32 * _9021) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + (32 * _9021) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9021:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10573 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10573] == bool(mem[_10573])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10893 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10893] == bool(mem[_10893])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8942 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9022 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9022
                                    require _8942 + (32 * _9022) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + (32 * _9022) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9022:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10574 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10574] == bool(mem[_10574])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10894 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10894] == bool(mem[_10894])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1438 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1455 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1438 + (32 * _1455) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + (32 * _1455) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3446 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3446] == mem[_3446]
                    mem[mem[64] + 4] = this.address
                    if mem[_3446]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3594 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3603 = mem[_3594]
                        require mem[_3594] == mem[_3594]
                        _3657 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 32] = stor6
                        if 1 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3657 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3657 + 100] = _3603
                        mem[_3657 + 132] = 1
                        mem[_3657 + 164] = 160
                        mem[_3657 + 260] = mem[_3657]
                        idx = 0
                        s = _3657 + 32
                        t = _3657 + 292
                        while idx < mem[_3657]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3657 + 196] = this.address
                        mem[_3657 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3657 + (32 * mem[_3657]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6051 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6083 = mem[_6051]
                        require mem[_6051] <= test266151307()
                        require _6051 + mem[_6051] + 31 < _6051 + return_data.size
                        _6176 = mem[_6051 + mem[_6051]]
                        if mem[_6051 + mem[_6051]] > test266151307():
                            revert with 'NH{q', 65
                        if _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1 > test266151307() or floor32(mem[_6051 + mem[_6051]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1
                        mem[_6051 + ceil32(return_data.size)] = _6176
                        require _6083 + (32 * _6176) + 32 <= return_data.size
                        idx = _6051 + _6083 + 32
                        s = _6051 + ceil32(return_data.size) + 32
                        while idx < _6051 + _6083 + (32 * _6176) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6176:
                            revert with 'NH{q', 50
                        if mem[_6051 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8733 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8733] == bool(mem[_8733])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9133 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9133] == bool(mem[_9133])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3622 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3622] == mem[_3622]
                        if mem[_3622]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3699 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3748 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3699 + 100] = 32
                        mem[_3699 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3812 = mem[_3748]
                        mem[_3699 + 164 len ceil32(mem[_3748])] = mem[_3748 + 32 len ceil32(mem[_3748])]
                        if ceil32(_3812) <= _3812:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8943 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9023 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9023
                                    require _8943 + (32 * _9023) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8943 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8943 + (32 * _9023) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9023:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10575 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10575] == bool(mem[_10575])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10895 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10895] == bool(mem[_10895])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8944 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9024 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9024
                                    require _8944 + (32 * _9024) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8944 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8944 + (32 * _9024) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9024:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10576 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10576] == bool(mem[_10576])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10896 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10896] == bool(mem[_10896])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8945 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9025 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9025
                                    require _8945 + (32 * _9025) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + (32 * _9025) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9025:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10577 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10577] == bool(mem[_10577])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10897 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10897] == bool(mem[_10897])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8946 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9026 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9026
                                    require _8946 + (32 * _9026) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + (32 * _9026) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9026:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10578 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10578] == bool(mem[_10578])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10898 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10898] == bool(mem[_10898])
                        else:
                            mem[_3699 + _3812 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8947 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9027 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9027
                                    require _8947 + (32 * _9027) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8947 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8947 + (32 * _9027) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9027:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10579 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10579] == bool(mem[_10579])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10899 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10899] == bool(mem[_10899])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8948 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9028 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9028
                                    require _8948 + (32 * _9028) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8948 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8948 + (32 * _9028) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9028:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10580 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10580] == bool(mem[_10580])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10900 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10900] == bool(mem[_10900])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8949 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9029 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9029
                                    require _8949 + (32 * _9029) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + (32 * _9029) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9029:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10581 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10581] == bool(mem[_10581])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10901 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10901] == bool(mem[_10901])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8950 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9030 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9030
                                    require _8950 + (32 * _9030) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + (32 * _9030) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9030:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10582 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10582] == bool(mem[_10582])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10902 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10902] == bool(mem[_10902])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1439 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1456 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1439 + (32 * _1456) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + (32 * _1456) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3447 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3447] == mem[_3447]
                    mem[mem[64] + 4] = this.address
                    if mem[_3447]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3595 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3604 = mem[_3595]
                        require mem[_3595] == mem[_3595]
                        _3658 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 32] = stor6
                        if 1 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3658 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3658 + 100] = _3604
                        mem[_3658 + 132] = 1
                        mem[_3658 + 164] = 160
                        mem[_3658 + 260] = mem[_3658]
                        idx = 0
                        s = _3658 + 32
                        t = _3658 + 292
                        while idx < mem[_3658]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3658 + 196] = this.address
                        mem[_3658 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3658 + (32 * mem[_3658]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6054 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6086 = mem[_6054]
                        require mem[_6054] <= test266151307()
                        require _6054 + mem[_6054] + 31 < _6054 + return_data.size
                        _6181 = mem[_6054 + mem[_6054]]
                        if mem[_6054 + mem[_6054]] > test266151307():
                            revert with 'NH{q', 65
                        if _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1 > test266151307() or floor32(mem[_6054 + mem[_6054]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1
                        mem[_6054 + ceil32(return_data.size)] = _6181
                        require _6086 + (32 * _6181) + 32 <= return_data.size
                        idx = _6054 + _6086 + 32
                        s = _6054 + ceil32(return_data.size) + 32
                        while idx < _6054 + _6086 + (32 * _6181) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6181:
                            revert with 'NH{q', 50
                        if mem[_6054 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8734 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8734] == bool(mem[_8734])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9134 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9134] == bool(mem[_9134])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3623 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3623] == mem[_3623]
                        if mem[_3623]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3701 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3750 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3701 + 100] = 32
                        mem[_3701 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3813 = mem[_3750]
                        mem[_3701 + 164 len ceil32(mem[_3750])] = mem[_3750 + 32 len ceil32(mem[_3750])]
                        if ceil32(_3813) <= _3813:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8951 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9031 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8951 + (32 * _9031) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8951 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8951 + (32 * _9031) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9031:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10583 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10583] == bool(mem[_10583])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10903 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10903] == bool(mem[_10903])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8952 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9032 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8952 + (32 * _9032) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8952 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8952 + (32 * _9032) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9032:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10584 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10584] == bool(mem[_10584])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10904 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10904] == bool(mem[_10904])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8953 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9033 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8953 + (32 * _9033) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + (32 * _9033) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9033:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10585 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10585] == bool(mem[_10585])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10905 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10905] == bool(mem[_10905])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8954 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9034 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8954 + (32 * _9034) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + (32 * _9034) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9034:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10586 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10586] == bool(mem[_10586])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10906 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10906] == bool(mem[_10906])
                        else:
                            mem[_3701 + _3813 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8955 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9035 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8955 + (32 * _9035) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8955 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8955 + (32 * _9035) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9035:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10587 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10587] == bool(mem[_10587])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10907 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10907] == bool(mem[_10907])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8956 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9036 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8956 + (32 * _9036) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8956 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8956 + (32 * _9036) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9036:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10588 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10588] == bool(mem[_10588])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10908 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10908] == bool(mem[_10908])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8957 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9037 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8957 + (32 * _9037) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + (32 * _9037) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9037:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10589 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10589] == bool(mem[_10589])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10909 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10909] == bool(mem[_10909])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8958 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9038 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8958 + (32 * _9038) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + (32 * _9038) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9038:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10590 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10590] == bool(mem[_10590])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10910 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10910] == bool(mem[_10910])
    call stor0 with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function pancakeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    if arg4.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg4.length)) + 97 > test266151307() or ceil32(ceil32(arg4.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg4.length
    require arg4 + arg4.length + 36 <= calldata.size
    mem[128 len arg4.length] = arg4[all]
    if stor1 != msg.sender:
        revert with 0, 'wrong pair address'
    mem[ceil32(ceil32(arg4.length)) + 101] = this.address
    if not address(stor4):
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor3)
        require ext_code.size(stor6)
        staticcall stor6.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor3)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor6)
            staticcall stor6.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor3))
            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _400 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _418 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _400 + (32 * _418) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + (32 * _418) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            if 1 >= _418:
                revert with 'NH{q', 50
            if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 257] <= stor7:
                revert with 0, 'received < initial balance'
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
               value stor7 wei
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1389 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1389] == bool(mem[_1389])
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = stor7
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, stor7
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1477 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1477] == bool(mem[_1477])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor6) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor6 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1428 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1445 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1428 + (32 * _1445) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + (32 * _1445) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1445:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3364 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3364] == bool(mem[_3364])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3495 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3495] == bool(mem[_3495])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1429 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1446 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1429 + (32 * _1446) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + (32 * _1446) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1446:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3365 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3365] == bool(mem[_3365])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3496 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3496] == bool(mem[_3496])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1430 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1447 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1430 + (32 * _1447) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + (32 * _1447) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1447:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3366 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3366] == bool(mem[_3366])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3497 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3497] == bool(mem[_3497])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1431 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1448 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1431 + (32 * _1448) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + (32 * _1448) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1448:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3367 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3367] == bool(mem[_3367])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3498 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3498] == bool(mem[_3498])
    else:
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor4)
        require ext_code.size(stor5)
        staticcall stor5.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor4)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor5)
            staticcall stor5.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor5
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor4))
            call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _403 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _423 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _403 + (32 * _423) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + (32 * _423) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1458 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1458] == mem[_1458]
            mem[mem[64] + 4] = this.address
            if mem[_1458]:
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1556 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1565 = mem[_1556]
                require mem[_1556] == mem[_1556]
                _1593 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 32] = stor6
                if 1 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                mem[_1593 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                mem[_1593 + 100] = _1565
                mem[_1593 + 132] = 1
                mem[_1593 + 164] = 160
                mem[_1593 + 260] = mem[_1593]
                idx = 0
                s = _1593 + 32
                t = _1593 + 292
                while idx < mem[_1593]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1593 + 196] = this.address
                mem[_1593 + 228] = stor8
                require ext_code.size(address(stor3))
                call address(stor3).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _1593 + (32 * mem[_1593]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3407 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3410 = mem[_3407]
                require mem[_3407] <= test266151307()
                require _3407 + mem[_3407] + 31 < _3407 + return_data.size
                _3427 = mem[_3407 + mem[_3407]]
                if mem[_3407 + mem[_3407]] > test266151307():
                    revert with 'NH{q', 65
                if _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1 > test266151307() or floor32(mem[_3407 + mem[_3407]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1
                mem[_3407 + ceil32(return_data.size)] = _3427
                require _3410 + (32 * _3427) + 32 <= return_data.size
                idx = _3407 + _3410 + 32
                s = _3407 + ceil32(return_data.size) + 32
                while idx < _3407 + _3410 + (32 * _3427) + 32:
                    require mem[idx] == mem[idx]
                    mem[s] = mem[idx]
                    idx = idx + 32
                    s = s + 32
                    continue 
                if 1 >= _3427:
                    revert with 'NH{q', 50
                if mem[_3407 + ceil32(return_data.size) + 64] <= stor7:
                    revert with 0, 'received < initial balance'
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                   value stor7 wei
                     gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5830 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_5830] == bool(mem[_5830])
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor7
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, stor7
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6411 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_6411] == bool(mem[_6411])
            else:
                mem[mem[64] + 36] = address(stor3)
                require ext_code.size(stor6)
                staticcall stor6.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(stor3)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1575] == mem[_1575]
                if mem[_1575]:
                    revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                _1613 = mem[64]
                mem[mem[64] + 36] = address(stor3)
                mem[mem[64] + 68] = -1
                _1657 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                mem[64] = mem[64] + 164
                mem[_1613 + 100] = 32
                mem[_1613 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if ext_code.size(stor6) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _1712 = mem[_1657]
                mem[_1613 + 164 len ceil32(mem[_1657])] = mem[_1657 + 32 len ceil32(mem[_1657])]
                if ceil32(_1712) <= _1712:
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6057 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6138 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6057 + (32 * _6138) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6057 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6057 + (32 * _6138) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6138:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8719 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8719] == bool(mem[_8719])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9119] == bool(mem[_9119])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6058 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6139 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6058 + (32 * _6139) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6058 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6058 + (32 * _6139) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6139:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8720 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8720] == bool(mem[_8720])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9120 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9120] == bool(mem[_9120])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6059 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6140 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6140
                            require _6059 + (32 * _6140) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + (32 * _6140) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6140:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8721 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8721] == bool(mem[_8721])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9121 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9121] == bool(mem[_9121])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6060 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6141 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6141
                            require _6060 + (32 * _6141) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + (32 * _6141) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6141:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8722 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8722] == bool(mem[_8722])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9122 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9122] == bool(mem[_9122])
                else:
                    mem[_1613 + _1712 + 164] = 0
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6061 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6142 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6061 + (32 * _6142) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6061 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6061 + (32 * _6142) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6142:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8723 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8723] == bool(mem[_8723])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9123 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9123] == bool(mem[_9123])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6062 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6143 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6062 + (32 * _6143) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6062 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6062 + (32 * _6143) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6143:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8724 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8724] == bool(mem[_8724])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9124 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9124] == bool(mem[_9124])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6063 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6144 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6144
                            require _6063 + (32 * _6144) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + (32 * _6144) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6144:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8725 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8725] == bool(mem[_8725])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9125 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9125] == bool(mem[_9125])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6064 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6145 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6145
                            require _6064 + (32 * _6145) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + (32 * _6145) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6145:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8726 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8726] == bool(mem[_8726])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9126 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9126] == bool(mem[_9126])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor4)
            require ext_code.size(stor5)
            staticcall stor5.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor4)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor5) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor5 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1436 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1453 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1436 + (32 * _1453) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + (32 * _1453) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3444 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3444] == mem[_3444]
                    mem[mem[64] + 4] = this.address
                    if mem[_3444]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3592 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3601 = mem[_3592]
                        require mem[_3592] == mem[_3592]
                        _3655 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 32] = stor6
                        if 1 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3655 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3655 + 100] = _3601
                        mem[_3655 + 132] = 1
                        mem[_3655 + 164] = 160
                        mem[_3655 + 260] = mem[_3655]
                        idx = 0
                        s = _3655 + 32
                        t = _3655 + 292
                        while idx < mem[_3655]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3655 + 196] = this.address
                        mem[_3655 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3655 + (32 * mem[_3655]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6045 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6077 = mem[_6045]
                        require mem[_6045] <= test266151307()
                        require _6045 + mem[_6045] + 31 < _6045 + return_data.size
                        _6166 = mem[_6045 + mem[_6045]]
                        if mem[_6045 + mem[_6045]] > test266151307():
                            revert with 'NH{q', 65
                        if _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1 > test266151307() or floor32(mem[_6045 + mem[_6045]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1
                        mem[_6045 + ceil32(return_data.size)] = _6166
                        require _6077 + (32 * _6166) + 32 <= return_data.size
                        idx = _6045 + _6077 + 32
                        s = _6045 + ceil32(return_data.size) + 32
                        while idx < _6045 + _6077 + (32 * _6166) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6166:
                            revert with 'NH{q', 50
                        if mem[_6045 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8731 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8731] == bool(mem[_8731])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9131 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9131] == bool(mem[_9131])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3620] == mem[_3620]
                        if mem[_3620]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3695 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3744 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3695 + 100] = 32
                        mem[_3695 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3810 = mem[_3744]
                        mem[_3695 + 164 len ceil32(mem[_3744])] = mem[_3744 + 32 len ceil32(mem[_3744])]
                        if ceil32(_3810) <= _3810:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8927 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9007 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8927 + (32 * _9007) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8927 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8927 + (32 * _9007) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9007:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10559 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10559] == bool(mem[_10559])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10879 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10879] == bool(mem[_10879])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8928 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9008 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8928 + (32 * _9008) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8928 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8928 + (32 * _9008) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9008:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10560] == bool(mem[_10560])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10880 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10880] == bool(mem[_10880])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8929 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9009 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9009
                                    require _8929 + (32 * _9009) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + (32 * _9009) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9009:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10561 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10561] == bool(mem[_10561])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10881 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10881] == bool(mem[_10881])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8930 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9010 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9010
                                    require _8930 + (32 * _9010) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + (32 * _9010) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9010:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10562 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10562] == bool(mem[_10562])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10882 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10882] == bool(mem[_10882])
                        else:
                            mem[_3695 + _3810 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8931 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9011 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8931 + (32 * _9011) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8931 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8931 + (32 * _9011) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9011:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10563 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10563] == bool(mem[_10563])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10883 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10883] == bool(mem[_10883])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8932 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9012 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8932 + (32 * _9012) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8932 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8932 + (32 * _9012) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9012:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10564 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10564] == bool(mem[_10564])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10884 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10884] == bool(mem[_10884])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8933 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9013 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9013
                                    require _8933 + (32 * _9013) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + (32 * _9013) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9013:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10565 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10565] == bool(mem[_10565])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10885 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10885] == bool(mem[_10885])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8934 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9014 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9014
                                    require _8934 + (32 * _9014) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + (32 * _9014) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9014:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10566 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10566] == bool(mem[_10566])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10886 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10886] == bool(mem[_10886])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1437 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1454 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1437 + (32 * _1454) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + (32 * _1454) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3445 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3445] == mem[_3445]
                    mem[mem[64] + 4] = this.address
                    if mem[_3445]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3593 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3602 = mem[_3593]
                        require mem[_3593] == mem[_3593]
                        _3656 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 32] = stor6
                        if 1 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3656 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3656 + 100] = _3602
                        mem[_3656 + 132] = 1
                        mem[_3656 + 164] = 160
                        mem[_3656 + 260] = mem[_3656]
                        idx = 0
                        s = _3656 + 32
                        t = _3656 + 292
                        while idx < mem[_3656]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3656 + 196] = this.address
                        mem[_3656 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3656 + (32 * mem[_3656]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6048 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6080 = mem[_6048]
                        require mem[_6048] <= test266151307()
                        require _6048 + mem[_6048] + 31 < _6048 + return_data.size
                        _6171 = mem[_6048 + mem[_6048]]
                        if mem[_6048 + mem[_6048]] > test266151307():
                            revert with 'NH{q', 65
                        if _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1 > test266151307() or floor32(mem[_6048 + mem[_6048]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1
                        mem[_6048 + ceil32(return_data.size)] = _6171
                        require _6080 + (32 * _6171) + 32 <= return_data.size
                        idx = _6048 + _6080 + 32
                        s = _6048 + ceil32(return_data.size) + 32
                        while idx < _6048 + _6080 + (32 * _6171) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6171:
                            revert with 'NH{q', 50
                        if mem[_6048 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8732 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8732] == bool(mem[_8732])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9132 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9132] == bool(mem[_9132])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3621 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3621] == mem[_3621]
                        if mem[_3621]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3697 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3746 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3697 + 100] = 32
                        mem[_3697 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3811 = mem[_3746]
                        mem[_3697 + 164 len ceil32(mem[_3746])] = mem[_3746 + 32 len ceil32(mem[_3746])]
                        if ceil32(_3811) <= _3811:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8935 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9015 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9015
                                    require _8935 + (32 * _9015) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8935 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8935 + (32 * _9015) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9015:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10567 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10567] == bool(mem[_10567])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10887 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10887] == bool(mem[_10887])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8936 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9016 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9016
                                    require _8936 + (32 * _9016) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8936 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8936 + (32 * _9016) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9016:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10568 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10568] == bool(mem[_10568])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10888 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10888] == bool(mem[_10888])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8937 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9017 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9017
                                    require _8937 + (32 * _9017) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + (32 * _9017) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9017:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10569 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10569] == bool(mem[_10569])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10889 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10889] == bool(mem[_10889])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8938 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9018 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9018
                                    require _8938 + (32 * _9018) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + (32 * _9018) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9018:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10570 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10570] == bool(mem[_10570])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10890 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10890] == bool(mem[_10890])
                        else:
                            mem[_3697 + _3811 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8939 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9019 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9019
                                    require _8939 + (32 * _9019) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8939 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8939 + (32 * _9019) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9019:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10571 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10571] == bool(mem[_10571])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10891 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10891] == bool(mem[_10891])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8940 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9020 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9020
                                    require _8940 + (32 * _9020) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8940 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8940 + (32 * _9020) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9020:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10572] == bool(mem[_10572])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10892 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10892] == bool(mem[_10892])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8941 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9021 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9021
                                    require _8941 + (32 * _9021) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + (32 * _9021) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9021:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10573 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10573] == bool(mem[_10573])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10893 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10893] == bool(mem[_10893])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8942 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9022 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9022
                                    require _8942 + (32 * _9022) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + (32 * _9022) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9022:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10574 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10574] == bool(mem[_10574])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10894 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10894] == bool(mem[_10894])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1438 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1455 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1438 + (32 * _1455) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + (32 * _1455) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3446 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3446] == mem[_3446]
                    mem[mem[64] + 4] = this.address
                    if mem[_3446]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3594 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3603 = mem[_3594]
                        require mem[_3594] == mem[_3594]
                        _3657 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 32] = stor6
                        if 1 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3657 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3657 + 100] = _3603
                        mem[_3657 + 132] = 1
                        mem[_3657 + 164] = 160
                        mem[_3657 + 260] = mem[_3657]
                        idx = 0
                        s = _3657 + 32
                        t = _3657 + 292
                        while idx < mem[_3657]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3657 + 196] = this.address
                        mem[_3657 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3657 + (32 * mem[_3657]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6051 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6083 = mem[_6051]
                        require mem[_6051] <= test266151307()
                        require _6051 + mem[_6051] + 31 < _6051 + return_data.size
                        _6176 = mem[_6051 + mem[_6051]]
                        if mem[_6051 + mem[_6051]] > test266151307():
                            revert with 'NH{q', 65
                        if _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1 > test266151307() or floor32(mem[_6051 + mem[_6051]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1
                        mem[_6051 + ceil32(return_data.size)] = _6176
                        require _6083 + (32 * _6176) + 32 <= return_data.size
                        idx = _6051 + _6083 + 32
                        s = _6051 + ceil32(return_data.size) + 32
                        while idx < _6051 + _6083 + (32 * _6176) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6176:
                            revert with 'NH{q', 50
                        if mem[_6051 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8733 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8733] == bool(mem[_8733])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9133 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9133] == bool(mem[_9133])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3622 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3622] == mem[_3622]
                        if mem[_3622]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3699 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3748 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3699 + 100] = 32
                        mem[_3699 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3812 = mem[_3748]
                        mem[_3699 + 164 len ceil32(mem[_3748])] = mem[_3748 + 32 len ceil32(mem[_3748])]
                        if ceil32(_3812) <= _3812:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8943 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9023 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9023
                                    require _8943 + (32 * _9023) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8943 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8943 + (32 * _9023) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9023:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10575 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10575] == bool(mem[_10575])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10895 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10895] == bool(mem[_10895])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8944 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9024 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9024
                                    require _8944 + (32 * _9024) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8944 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8944 + (32 * _9024) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9024:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10576 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10576] == bool(mem[_10576])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10896 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10896] == bool(mem[_10896])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8945 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9025 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9025
                                    require _8945 + (32 * _9025) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + (32 * _9025) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9025:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10577 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10577] == bool(mem[_10577])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10897 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10897] == bool(mem[_10897])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8946 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9026 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9026
                                    require _8946 + (32 * _9026) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + (32 * _9026) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9026:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10578 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10578] == bool(mem[_10578])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10898 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10898] == bool(mem[_10898])
                        else:
                            mem[_3699 + _3812 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8947 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9027 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9027
                                    require _8947 + (32 * _9027) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8947 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8947 + (32 * _9027) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9027:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10579 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10579] == bool(mem[_10579])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10899 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10899] == bool(mem[_10899])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8948 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9028 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9028
                                    require _8948 + (32 * _9028) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8948 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8948 + (32 * _9028) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9028:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10580 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10580] == bool(mem[_10580])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10900 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10900] == bool(mem[_10900])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8949 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9029 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9029
                                    require _8949 + (32 * _9029) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + (32 * _9029) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9029:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10581 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10581] == bool(mem[_10581])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10901 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10901] == bool(mem[_10901])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8950 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9030 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9030
                                    require _8950 + (32 * _9030) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + (32 * _9030) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9030:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10582 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10582] == bool(mem[_10582])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10902 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10902] == bool(mem[_10902])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1439 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1456 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1439 + (32 * _1456) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + (32 * _1456) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3447 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3447] == mem[_3447]
                    mem[mem[64] + 4] = this.address
                    if mem[_3447]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3595 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3604 = mem[_3595]
                        require mem[_3595] == mem[_3595]
                        _3658 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 32] = stor6
                        if 1 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3658 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3658 + 100] = _3604
                        mem[_3658 + 132] = 1
                        mem[_3658 + 164] = 160
                        mem[_3658 + 260] = mem[_3658]
                        idx = 0
                        s = _3658 + 32
                        t = _3658 + 292
                        while idx < mem[_3658]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3658 + 196] = this.address
                        mem[_3658 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3658 + (32 * mem[_3658]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6054 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6086 = mem[_6054]
                        require mem[_6054] <= test266151307()
                        require _6054 + mem[_6054] + 31 < _6054 + return_data.size
                        _6181 = mem[_6054 + mem[_6054]]
                        if mem[_6054 + mem[_6054]] > test266151307():
                            revert with 'NH{q', 65
                        if _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1 > test266151307() or floor32(mem[_6054 + mem[_6054]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1
                        mem[_6054 + ceil32(return_data.size)] = _6181
                        require _6086 + (32 * _6181) + 32 <= return_data.size
                        idx = _6054 + _6086 + 32
                        s = _6054 + ceil32(return_data.size) + 32
                        while idx < _6054 + _6086 + (32 * _6181) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6181:
                            revert with 'NH{q', 50
                        if mem[_6054 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8734 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8734] == bool(mem[_8734])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9134 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9134] == bool(mem[_9134])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3623 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3623] == mem[_3623]
                        if mem[_3623]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3701 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3750 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3701 + 100] = 32
                        mem[_3701 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3813 = mem[_3750]
                        mem[_3701 + 164 len ceil32(mem[_3750])] = mem[_3750 + 32 len ceil32(mem[_3750])]
                        if ceil32(_3813) <= _3813:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8951 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9031 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8951 + (32 * _9031) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8951 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8951 + (32 * _9031) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9031:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10583 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10583] == bool(mem[_10583])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10903 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10903] == bool(mem[_10903])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8952 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9032 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8952 + (32 * _9032) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8952 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8952 + (32 * _9032) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9032:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10584 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10584] == bool(mem[_10584])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10904 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10904] == bool(mem[_10904])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8953 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9033 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8953 + (32 * _9033) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + (32 * _9033) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9033:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10585 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10585] == bool(mem[_10585])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10905 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10905] == bool(mem[_10905])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8954 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9034 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8954 + (32 * _9034) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + (32 * _9034) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9034:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10586 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10586] == bool(mem[_10586])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10906 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10906] == bool(mem[_10906])
                        else:
                            mem[_3701 + _3813 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8955 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9035 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8955 + (32 * _9035) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8955 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8955 + (32 * _9035) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9035:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10587 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10587] == bool(mem[_10587])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10907 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10907] == bool(mem[_10907])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8956 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9036 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8956 + (32 * _9036) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8956 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8956 + (32 * _9036) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9036:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10588 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10588] == bool(mem[_10588])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10908 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10908] == bool(mem[_10908])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8957 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9037 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8957 + (32 * _9037) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + (32 * _9037) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9037:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10589 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10589] == bool(mem[_10589])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10909 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10909] == bool(mem[_10909])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8958 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9038 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8958 + (32 * _9038) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + (32 * _9038) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9038:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10590 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10590] == bool(mem[_10590])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10910 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10910] == bool(mem[_10910])
    call stor0 with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function wakaSwapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    if arg4.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg4.length)) + 97 > test266151307() or ceil32(ceil32(arg4.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg4.length
    require arg4 + arg4.length + 36 <= calldata.size
    mem[128 len arg4.length] = arg4[all]
    if stor1 != msg.sender:
        revert with 0, 'wrong pair address'
    mem[ceil32(ceil32(arg4.length)) + 101] = this.address
    if not address(stor4):
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor3)
        require ext_code.size(stor6)
        staticcall stor6.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor3)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor6)
            staticcall stor6.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor3))
            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _400 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _418 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _400 + (32 * _418) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + (32 * _418) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            if 1 >= _418:
                revert with 'NH{q', 50
            if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 257] <= stor7:
                revert with 0, 'received < initial balance'
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
               value stor7 wei
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1389 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1389] == bool(mem[_1389])
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = stor7
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, stor7
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1477 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1477] == bool(mem[_1477])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor6) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor6 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1428 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1445 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1428 + (32 * _1445) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + (32 * _1445) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1445:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3364 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3364] == bool(mem[_3364])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3495 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3495] == bool(mem[_3495])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1429 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1446 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1429 + (32 * _1446) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + (32 * _1446) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1446:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3365 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3365] == bool(mem[_3365])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3496 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3496] == bool(mem[_3496])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1430 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1447 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1430 + (32 * _1447) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + (32 * _1447) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1447:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3366 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3366] == bool(mem[_3366])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3497 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3497] == bool(mem[_3497])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1431 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1448 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1431 + (32 * _1448) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + (32 * _1448) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1448:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3367 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3367] == bool(mem[_3367])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3498 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3498] == bool(mem[_3498])
    else:
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor4)
        require ext_code.size(stor5)
        staticcall stor5.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor4)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor5)
            staticcall stor5.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor5
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor4))
            call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _403 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _423 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _403 + (32 * _423) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + (32 * _423) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1458 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1458] == mem[_1458]
            mem[mem[64] + 4] = this.address
            if mem[_1458]:
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1556 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1565 = mem[_1556]
                require mem[_1556] == mem[_1556]
                _1593 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 32] = stor6
                if 1 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                mem[_1593 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                mem[_1593 + 100] = _1565
                mem[_1593 + 132] = 1
                mem[_1593 + 164] = 160
                mem[_1593 + 260] = mem[_1593]
                idx = 0
                s = _1593 + 32
                t = _1593 + 292
                while idx < mem[_1593]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1593 + 196] = this.address
                mem[_1593 + 228] = stor8
                require ext_code.size(address(stor3))
                call address(stor3).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _1593 + (32 * mem[_1593]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3407 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3410 = mem[_3407]
                require mem[_3407] <= test266151307()
                require _3407 + mem[_3407] + 31 < _3407 + return_data.size
                _3427 = mem[_3407 + mem[_3407]]
                if mem[_3407 + mem[_3407]] > test266151307():
                    revert with 'NH{q', 65
                if _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1 > test266151307() or floor32(mem[_3407 + mem[_3407]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1
                mem[_3407 + ceil32(return_data.size)] = _3427
                require _3410 + (32 * _3427) + 32 <= return_data.size
                idx = _3407 + _3410 + 32
                s = _3407 + ceil32(return_data.size) + 32
                while idx < _3407 + _3410 + (32 * _3427) + 32:
                    require mem[idx] == mem[idx]
                    mem[s] = mem[idx]
                    idx = idx + 32
                    s = s + 32
                    continue 
                if 1 >= _3427:
                    revert with 'NH{q', 50
                if mem[_3407 + ceil32(return_data.size) + 64] <= stor7:
                    revert with 0, 'received < initial balance'
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                   value stor7 wei
                     gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5830 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_5830] == bool(mem[_5830])
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor7
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, stor7
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6411 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_6411] == bool(mem[_6411])
            else:
                mem[mem[64] + 36] = address(stor3)
                require ext_code.size(stor6)
                staticcall stor6.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(stor3)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1575] == mem[_1575]
                if mem[_1575]:
                    revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                _1613 = mem[64]
                mem[mem[64] + 36] = address(stor3)
                mem[mem[64] + 68] = -1
                _1657 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                mem[64] = mem[64] + 164
                mem[_1613 + 100] = 32
                mem[_1613 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if ext_code.size(stor6) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _1712 = mem[_1657]
                mem[_1613 + 164 len ceil32(mem[_1657])] = mem[_1657 + 32 len ceil32(mem[_1657])]
                if ceil32(_1712) <= _1712:
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6057 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6138 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6057 + (32 * _6138) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6057 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6057 + (32 * _6138) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6138:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8719 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8719] == bool(mem[_8719])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9119] == bool(mem[_9119])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6058 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6139 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6058 + (32 * _6139) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6058 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6058 + (32 * _6139) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6139:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8720 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8720] == bool(mem[_8720])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9120 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9120] == bool(mem[_9120])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6059 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6140 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6140
                            require _6059 + (32 * _6140) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + (32 * _6140) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6140:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8721 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8721] == bool(mem[_8721])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9121 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9121] == bool(mem[_9121])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6060 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6141 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6141
                            require _6060 + (32 * _6141) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + (32 * _6141) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6141:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8722 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8722] == bool(mem[_8722])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9122 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9122] == bool(mem[_9122])
                else:
                    mem[_1613 + _1712 + 164] = 0
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6061 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6142 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6061 + (32 * _6142) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6061 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6061 + (32 * _6142) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6142:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8723 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8723] == bool(mem[_8723])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9123 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9123] == bool(mem[_9123])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6062 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6143 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6062 + (32 * _6143) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6062 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6062 + (32 * _6143) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6143:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8724 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8724] == bool(mem[_8724])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9124 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9124] == bool(mem[_9124])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6063 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6144 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6144
                            require _6063 + (32 * _6144) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + (32 * _6144) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6144:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8725 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8725] == bool(mem[_8725])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9125 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9125] == bool(mem[_9125])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6064 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6145 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6145
                            require _6064 + (32 * _6145) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + (32 * _6145) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6145:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8726 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8726] == bool(mem[_8726])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9126 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9126] == bool(mem[_9126])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor4)
            require ext_code.size(stor5)
            staticcall stor5.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor4)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor5) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor5 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1436 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1453 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1436 + (32 * _1453) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + (32 * _1453) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3444 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3444] == mem[_3444]
                    mem[mem[64] + 4] = this.address
                    if mem[_3444]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3592 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3601 = mem[_3592]
                        require mem[_3592] == mem[_3592]
                        _3655 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 32] = stor6
                        if 1 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3655 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3655 + 100] = _3601
                        mem[_3655 + 132] = 1
                        mem[_3655 + 164] = 160
                        mem[_3655 + 260] = mem[_3655]
                        idx = 0
                        s = _3655 + 32
                        t = _3655 + 292
                        while idx < mem[_3655]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3655 + 196] = this.address
                        mem[_3655 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3655 + (32 * mem[_3655]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6045 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6077 = mem[_6045]
                        require mem[_6045] <= test266151307()
                        require _6045 + mem[_6045] + 31 < _6045 + return_data.size
                        _6166 = mem[_6045 + mem[_6045]]
                        if mem[_6045 + mem[_6045]] > test266151307():
                            revert with 'NH{q', 65
                        if _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1 > test266151307() or floor32(mem[_6045 + mem[_6045]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1
                        mem[_6045 + ceil32(return_data.size)] = _6166
                        require _6077 + (32 * _6166) + 32 <= return_data.size
                        idx = _6045 + _6077 + 32
                        s = _6045 + ceil32(return_data.size) + 32
                        while idx < _6045 + _6077 + (32 * _6166) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6166:
                            revert with 'NH{q', 50
                        if mem[_6045 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8731 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8731] == bool(mem[_8731])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9131 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9131] == bool(mem[_9131])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3620] == mem[_3620]
                        if mem[_3620]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3695 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3744 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3695 + 100] = 32
                        mem[_3695 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3810 = mem[_3744]
                        mem[_3695 + 164 len ceil32(mem[_3744])] = mem[_3744 + 32 len ceil32(mem[_3744])]
                        if ceil32(_3810) <= _3810:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8927 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9007 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8927 + (32 * _9007) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8927 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8927 + (32 * _9007) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9007:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10559 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10559] == bool(mem[_10559])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10879 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10879] == bool(mem[_10879])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8928 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9008 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8928 + (32 * _9008) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8928 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8928 + (32 * _9008) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9008:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10560] == bool(mem[_10560])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10880 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10880] == bool(mem[_10880])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8929 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9009 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9009
                                    require _8929 + (32 * _9009) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + (32 * _9009) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9009:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10561 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10561] == bool(mem[_10561])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10881 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10881] == bool(mem[_10881])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8930 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9010 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9010
                                    require _8930 + (32 * _9010) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + (32 * _9010) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9010:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10562 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10562] == bool(mem[_10562])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10882 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10882] == bool(mem[_10882])
                        else:
                            mem[_3695 + _3810 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8931 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9011 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8931 + (32 * _9011) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8931 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8931 + (32 * _9011) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9011:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10563 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10563] == bool(mem[_10563])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10883 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10883] == bool(mem[_10883])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8932 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9012 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8932 + (32 * _9012) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8932 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8932 + (32 * _9012) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9012:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10564 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10564] == bool(mem[_10564])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10884 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10884] == bool(mem[_10884])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8933 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9013 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9013
                                    require _8933 + (32 * _9013) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + (32 * _9013) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9013:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10565 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10565] == bool(mem[_10565])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10885 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10885] == bool(mem[_10885])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8934 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9014 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9014
                                    require _8934 + (32 * _9014) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + (32 * _9014) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9014:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10566 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10566] == bool(mem[_10566])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10886 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10886] == bool(mem[_10886])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1437 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1454 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1437 + (32 * _1454) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + (32 * _1454) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3445 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3445] == mem[_3445]
                    mem[mem[64] + 4] = this.address
                    if mem[_3445]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3593 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3602 = mem[_3593]
                        require mem[_3593] == mem[_3593]
                        _3656 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 32] = stor6
                        if 1 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3656 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3656 + 100] = _3602
                        mem[_3656 + 132] = 1
                        mem[_3656 + 164] = 160
                        mem[_3656 + 260] = mem[_3656]
                        idx = 0
                        s = _3656 + 32
                        t = _3656 + 292
                        while idx < mem[_3656]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3656 + 196] = this.address
                        mem[_3656 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3656 + (32 * mem[_3656]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6048 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6080 = mem[_6048]
                        require mem[_6048] <= test266151307()
                        require _6048 + mem[_6048] + 31 < _6048 + return_data.size
                        _6171 = mem[_6048 + mem[_6048]]
                        if mem[_6048 + mem[_6048]] > test266151307():
                            revert with 'NH{q', 65
                        if _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1 > test266151307() or floor32(mem[_6048 + mem[_6048]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1
                        mem[_6048 + ceil32(return_data.size)] = _6171
                        require _6080 + (32 * _6171) + 32 <= return_data.size
                        idx = _6048 + _6080 + 32
                        s = _6048 + ceil32(return_data.size) + 32
                        while idx < _6048 + _6080 + (32 * _6171) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6171:
                            revert with 'NH{q', 50
                        if mem[_6048 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8732 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8732] == bool(mem[_8732])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9132 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9132] == bool(mem[_9132])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3621 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3621] == mem[_3621]
                        if mem[_3621]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3697 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3746 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3697 + 100] = 32
                        mem[_3697 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3811 = mem[_3746]
                        mem[_3697 + 164 len ceil32(mem[_3746])] = mem[_3746 + 32 len ceil32(mem[_3746])]
                        if ceil32(_3811) <= _3811:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8935 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9015 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9015
                                    require _8935 + (32 * _9015) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8935 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8935 + (32 * _9015) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9015:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10567 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10567] == bool(mem[_10567])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10887 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10887] == bool(mem[_10887])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8936 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9016 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9016
                                    require _8936 + (32 * _9016) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8936 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8936 + (32 * _9016) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9016:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10568 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10568] == bool(mem[_10568])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10888 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10888] == bool(mem[_10888])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8937 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9017 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9017
                                    require _8937 + (32 * _9017) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + (32 * _9017) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9017:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10569 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10569] == bool(mem[_10569])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10889 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10889] == bool(mem[_10889])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8938 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9018 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9018
                                    require _8938 + (32 * _9018) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + (32 * _9018) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9018:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10570 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10570] == bool(mem[_10570])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10890 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10890] == bool(mem[_10890])
                        else:
                            mem[_3697 + _3811 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8939 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9019 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9019
                                    require _8939 + (32 * _9019) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8939 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8939 + (32 * _9019) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9019:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10571 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10571] == bool(mem[_10571])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10891 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10891] == bool(mem[_10891])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8940 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9020 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9020
                                    require _8940 + (32 * _9020) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8940 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8940 + (32 * _9020) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9020:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10572] == bool(mem[_10572])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10892 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10892] == bool(mem[_10892])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8941 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9021 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9021
                                    require _8941 + (32 * _9021) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + (32 * _9021) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9021:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10573 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10573] == bool(mem[_10573])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10893 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10893] == bool(mem[_10893])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8942 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9022 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9022
                                    require _8942 + (32 * _9022) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + (32 * _9022) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9022:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10574 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10574] == bool(mem[_10574])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10894 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10894] == bool(mem[_10894])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1438 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1455 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1438 + (32 * _1455) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + (32 * _1455) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3446 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3446] == mem[_3446]
                    mem[mem[64] + 4] = this.address
                    if mem[_3446]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3594 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3603 = mem[_3594]
                        require mem[_3594] == mem[_3594]
                        _3657 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 32] = stor6
                        if 1 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3657 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3657 + 100] = _3603
                        mem[_3657 + 132] = 1
                        mem[_3657 + 164] = 160
                        mem[_3657 + 260] = mem[_3657]
                        idx = 0
                        s = _3657 + 32
                        t = _3657 + 292
                        while idx < mem[_3657]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3657 + 196] = this.address
                        mem[_3657 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3657 + (32 * mem[_3657]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6051 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6083 = mem[_6051]
                        require mem[_6051] <= test266151307()
                        require _6051 + mem[_6051] + 31 < _6051 + return_data.size
                        _6176 = mem[_6051 + mem[_6051]]
                        if mem[_6051 + mem[_6051]] > test266151307():
                            revert with 'NH{q', 65
                        if _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1 > test266151307() or floor32(mem[_6051 + mem[_6051]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1
                        mem[_6051 + ceil32(return_data.size)] = _6176
                        require _6083 + (32 * _6176) + 32 <= return_data.size
                        idx = _6051 + _6083 + 32
                        s = _6051 + ceil32(return_data.size) + 32
                        while idx < _6051 + _6083 + (32 * _6176) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6176:
                            revert with 'NH{q', 50
                        if mem[_6051 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8733 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8733] == bool(mem[_8733])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9133 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9133] == bool(mem[_9133])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3622 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3622] == mem[_3622]
                        if mem[_3622]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3699 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3748 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3699 + 100] = 32
                        mem[_3699 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3812 = mem[_3748]
                        mem[_3699 + 164 len ceil32(mem[_3748])] = mem[_3748 + 32 len ceil32(mem[_3748])]
                        if ceil32(_3812) <= _3812:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8943 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9023 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9023
                                    require _8943 + (32 * _9023) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8943 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8943 + (32 * _9023) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9023:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10575 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10575] == bool(mem[_10575])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10895 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10895] == bool(mem[_10895])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8944 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9024 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9024
                                    require _8944 + (32 * _9024) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8944 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8944 + (32 * _9024) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9024:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10576 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10576] == bool(mem[_10576])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10896 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10896] == bool(mem[_10896])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8945 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9025 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9025
                                    require _8945 + (32 * _9025) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + (32 * _9025) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9025:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10577 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10577] == bool(mem[_10577])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10897 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10897] == bool(mem[_10897])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8946 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9026 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9026
                                    require _8946 + (32 * _9026) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + (32 * _9026) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9026:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10578 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10578] == bool(mem[_10578])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10898 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10898] == bool(mem[_10898])
                        else:
                            mem[_3699 + _3812 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8947 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9027 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9027
                                    require _8947 + (32 * _9027) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8947 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8947 + (32 * _9027) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9027:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10579 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10579] == bool(mem[_10579])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10899 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10899] == bool(mem[_10899])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8948 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9028 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9028
                                    require _8948 + (32 * _9028) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8948 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8948 + (32 * _9028) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9028:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10580 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10580] == bool(mem[_10580])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10900 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10900] == bool(mem[_10900])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8949 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9029 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9029
                                    require _8949 + (32 * _9029) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + (32 * _9029) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9029:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10581 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10581] == bool(mem[_10581])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10901 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10901] == bool(mem[_10901])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8950 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9030 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9030
                                    require _8950 + (32 * _9030) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + (32 * _9030) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9030:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10582 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10582] == bool(mem[_10582])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10902 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10902] == bool(mem[_10902])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1439 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1456 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1439 + (32 * _1456) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + (32 * _1456) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3447 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3447] == mem[_3447]
                    mem[mem[64] + 4] = this.address
                    if mem[_3447]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3595 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3604 = mem[_3595]
                        require mem[_3595] == mem[_3595]
                        _3658 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 32] = stor6
                        if 1 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3658 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3658 + 100] = _3604
                        mem[_3658 + 132] = 1
                        mem[_3658 + 164] = 160
                        mem[_3658 + 260] = mem[_3658]
                        idx = 0
                        s = _3658 + 32
                        t = _3658 + 292
                        while idx < mem[_3658]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3658 + 196] = this.address
                        mem[_3658 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3658 + (32 * mem[_3658]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6054 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6086 = mem[_6054]
                        require mem[_6054] <= test266151307()
                        require _6054 + mem[_6054] + 31 < _6054 + return_data.size
                        _6181 = mem[_6054 + mem[_6054]]
                        if mem[_6054 + mem[_6054]] > test266151307():
                            revert with 'NH{q', 65
                        if _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1 > test266151307() or floor32(mem[_6054 + mem[_6054]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1
                        mem[_6054 + ceil32(return_data.size)] = _6181
                        require _6086 + (32 * _6181) + 32 <= return_data.size
                        idx = _6054 + _6086 + 32
                        s = _6054 + ceil32(return_data.size) + 32
                        while idx < _6054 + _6086 + (32 * _6181) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6181:
                            revert with 'NH{q', 50
                        if mem[_6054 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8734 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8734] == bool(mem[_8734])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9134 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9134] == bool(mem[_9134])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3623 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3623] == mem[_3623]
                        if mem[_3623]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3701 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3750 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3701 + 100] = 32
                        mem[_3701 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3813 = mem[_3750]
                        mem[_3701 + 164 len ceil32(mem[_3750])] = mem[_3750 + 32 len ceil32(mem[_3750])]
                        if ceil32(_3813) <= _3813:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8951 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9031 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8951 + (32 * _9031) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8951 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8951 + (32 * _9031) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9031:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10583 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10583] == bool(mem[_10583])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10903 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10903] == bool(mem[_10903])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8952 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9032 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8952 + (32 * _9032) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8952 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8952 + (32 * _9032) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9032:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10584 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10584] == bool(mem[_10584])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10904 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10904] == bool(mem[_10904])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8953 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9033 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8953 + (32 * _9033) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + (32 * _9033) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9033:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10585 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10585] == bool(mem[_10585])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10905 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10905] == bool(mem[_10905])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8954 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9034 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8954 + (32 * _9034) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + (32 * _9034) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9034:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10586 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10586] == bool(mem[_10586])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10906 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10906] == bool(mem[_10906])
                        else:
                            mem[_3701 + _3813 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8955 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9035 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8955 + (32 * _9035) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8955 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8955 + (32 * _9035) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9035:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10587 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10587] == bool(mem[_10587])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10907 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10907] == bool(mem[_10907])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8956 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9036 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8956 + (32 * _9036) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8956 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8956 + (32 * _9036) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9036:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10588 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10588] == bool(mem[_10588])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10908 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10908] == bool(mem[_10908])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8957 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9037 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8957 + (32 * _9037) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + (32 * _9037) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9037:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10589 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10589] == bool(mem[_10589])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10909 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10909] == bool(mem[_10909])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8958 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9038 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8958 + (32 * _9038) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + (32 * _9038) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9038:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10590 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10590] == bool(mem[_10590])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10910 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10910] == bool(mem[_10910])
    call stor0 with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    if arg4.length > test266151307():
        revert with 'NH{q', 65
    if ceil32(ceil32(arg4.length)) + 97 > test266151307() or ceil32(ceil32(arg4.length)) + 97 < 96:
        revert with 'NH{q', 65
    mem[96] = arg4.length
    require arg4 + arg4.length + 36 <= calldata.size
    mem[128 len arg4.length] = arg4[all]
    if stor1 != msg.sender:
        revert with 0, 'wrong pair address'
    mem[ceil32(ceil32(arg4.length)) + 101] = this.address
    if not address(stor4):
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor3)
        require ext_code.size(stor6)
        staticcall stor6.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor3)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor6)
            staticcall stor6.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor3))
            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _400 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _418 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _400 + (32 * _418) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _400 + (32 * _418) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            if 1 >= _418:
                revert with 'NH{q', 50
            if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 257] <= stor7:
                revert with 0, 'received < initial balance'
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
               value stor7 wei
                 gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1389 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1389] == bool(mem[_1389])
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = stor7
            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, stor7
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1477 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1477] == bool(mem[_1477])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor3)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor6) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor6 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor3), uint32(stor3), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1428 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1445 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1428 + (32 * _1445) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1428 + (32 * _1445) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1445:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3364 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3364] == bool(mem[_3364])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3495 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3495] == bool(mem[_3495])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1429 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1446 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1429 + (32 * _1446) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1429 + (32 * _1446) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1446:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 421] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3365 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3365] == bool(mem[_3365])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3496 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3496] == bool(mem[_3496])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1430 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1447 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1430 + (32 * _1447) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1430 + (32 * _1447) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1447:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3366 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3366] == bool(mem[_3366])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3497 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3497] == bool(mem[_3497])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor6)
                    staticcall stor6.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor3))
                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1431 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1448 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1431 + (32 * _1448) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1431 + (32 * _1448) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    if 1 >= _1448:
                        revert with 'NH{q', 50
                    if mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 422] <= stor7:
                        revert with 0, 'received < initial balance'
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                       value stor7 wei
                         gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3367 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3367] == bool(mem[_3367])
                    mem[mem[64] + 4] = msg.sender
                    mem[mem[64] + 36] = stor7
                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, stor7
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3498 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3498] == bool(mem[_3498])
    else:
        mem[ceil32(ceil32(arg4.length)) + 133] = address(stor4)
        require ext_code.size(stor5)
        staticcall stor5.0xdd62ed3e with:
                gas gas_remaining wei
               args address(this.address), address(stor4)
        mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 101] = this.address
        if ext_call.return_data[0]:
            require ext_code.size(stor5)
            staticcall stor5.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 2
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129] = stor5
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 161] = stor6
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = ext_call.return_data[0]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = 160
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 357] = 2
            idx = 0
            s = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129
            t = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] = this.address
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 325] = stor8
            require ext_code.size(address(stor4))
            call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 389 len 64]), address(this.address), stor8
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193
            require return_data.size >= 32
            _403 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28]
            require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] <= test266151307()
            require ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 224 < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + return_data.size + 193
            _423 = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            if mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193] > test266151307():
                revert with 'NH{q', 65
            if ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 1 < 0:
                revert with 'NH{q', 65
            mem[64] = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]) + 194
            mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 193] = mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 193 len 4], ext_call.return_data[0 len 28] + 193]
            require _403 + (32 * _423) + 32 <= return_data.size
            idx = ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + 225
            s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 225
            while idx < ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + _403 + (32 * _423) + 225:
                require mem[idx] == mem[idx]
                mem[s] = mem[idx]
                idx = idx + 32
                s = s + 32
                continue 
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = address(stor3)
            require ext_code.size(stor6)
            staticcall stor6.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor3)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1458 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_1458] == mem[_1458]
            mem[mem[64] + 4] = this.address
            if mem[_1458]:
                require ext_code.size(stor6)
                staticcall stor6.0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1556 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1565 = mem[_1556]
                require mem[_1556] == mem[_1556]
                _1593 = mem[64]
                mem[mem[64]] = 2
                mem[64] = mem[64] + 96
                if 0 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 32] = stor6
                if 1 >= mem[_1593]:
                    revert with 'NH{q', 50
                mem[_1593 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                mem[_1593 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                mem[_1593 + 100] = _1565
                mem[_1593 + 132] = 1
                mem[_1593 + 164] = 160
                mem[_1593 + 260] = mem[_1593]
                idx = 0
                s = _1593 + 32
                t = _1593 + 292
                while idx < mem[_1593]:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1593 + 196] = this.address
                mem[_1593 + 228] = stor8
                require ext_code.size(address(stor3))
                call address(stor3).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len _1593 + (32 * mem[_1593]) + -mem[64] + 288]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3407 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3410 = mem[_3407]
                require mem[_3407] <= test266151307()
                require _3407 + mem[_3407] + 31 < _3407 + return_data.size
                _3427 = mem[_3407 + mem[_3407]]
                if mem[_3407 + mem[_3407]] > test266151307():
                    revert with 'NH{q', 65
                if _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1 > test266151307() or floor32(mem[_3407 + mem[_3407]]) + 1 < 0:
                    revert with 'NH{q', 65
                mem[64] = _3407 + ceil32(return_data.size) + floor32(mem[_3407 + mem[_3407]]) + 1
                mem[_3407 + ceil32(return_data.size)] = _3427
                require _3410 + (32 * _3427) + 32 <= return_data.size
                idx = _3407 + _3410 + 32
                s = _3407 + ceil32(return_data.size) + 32
                while idx < _3407 + _3410 + (32 * _3427) + 32:
                    require mem[idx] == mem[idx]
                    mem[s] = mem[idx]
                    idx = idx + 32
                    s = s + 32
                    continue 
                if 1 >= _3427:
                    revert with 'NH{q', 50
                if mem[_3407 + ceil32(return_data.size) + 64] <= stor7:
                    revert with 0, 'received < initial balance'
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                   value stor7 wei
                     gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _5830 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_5830] == bool(mem[_5830])
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = stor7
                require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, stor7
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6411 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_6411] == bool(mem[_6411])
            else:
                mem[mem[64] + 36] = address(stor3)
                require ext_code.size(stor6)
                staticcall stor6.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(stor3)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1575] == mem[_1575]
                if mem[_1575]:
                    revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                _1613 = mem[64]
                mem[mem[64] + 36] = address(stor3)
                mem[mem[64] + 68] = -1
                _1657 = mem[64]
                mem[mem[64]] = 68
                mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                mem[64] = mem[64] + 164
                mem[_1613 + 100] = 32
                mem[_1613 + 132] = 'SafeERC20: low-level call failed'
                if eth.balance(this.address) < 0:
                    revert with 0, 'Address: insufficient balance for call'
                if ext_code.size(stor6) <= 0:
                    revert with 0, 'Address: call to non-contract'
                _1712 = mem[_1657]
                mem[_1613 + 164 len ceil32(mem[_1657])] = mem[_1657 + 32 len ceil32(mem[_1657])]
                if ceil32(_1712) <= _1712:
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6057 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6138 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6057 + (32 * _6138) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6057 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6057 + (32 * _6138) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6138:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8719 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8719] == bool(mem[_8719])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9119] == bool(mem[_9119])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6058 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6139 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6058 + (32 * _6139) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6058 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6058 + (32 * _6139) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6139:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8720 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8720] == bool(mem[_8720])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9120 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9120] == bool(mem[_9120])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6059 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6140 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6140
                            require _6059 + (32 * _6140) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6059 + (32 * _6140) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6140:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8721 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8721] == bool(mem[_8721])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9121 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9121] == bool(mem[_9121])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6060 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6141 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6141
                            require _6060 + (32 * _6141) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6060 + (32 * _6141) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6141:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8722 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8722] == bool(mem[_8722])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9122 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9122] == bool(mem[_9122])
                else:
                    mem[_1613 + _1712 + 164] = 0
                    call stor6 with:
                         gas gas_remaining wei
                        args mem[_1613 + 168 len _1712 - 4]
                    if not return_data.size:
                        if not ext_call.success:
                            if arg4.length > 0:
                                revert with arg4[all]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if arg4.length <= 0:
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6061 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6142 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6061 + (32 * _6142) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6061 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6061 + (32 * _6142) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6142:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8723 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8723] == bool(mem[_8723])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9123 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9123] == bool(mem[_9123])
                        else:
                            require arg4.length >= 32
                            require mem[128] == bool(mem[128])
                            if not mem[128]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + 168] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + 164] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 164] = 2
                            mem[_1613 + ceil32(return_data.size) + 196] = stor6
                            mem[_1613 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + 296] = 1
                            mem[_1613 + ceil32(return_data.size) + 328] = 160
                            mem[_1613 + ceil32(return_data.size) + 424] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + 196
                            t = _1613 + ceil32(return_data.size) + 456
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + 360] = this.address
                            mem[_1613 + ceil32(return_data.size) + 392] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + 260
                            require return_data.size >= 32
                            _6062 = mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _1613 + ceil32(return_data.size) + return_data.size + 260
                            _6143 = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            if mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                            mem[_1613 + (2 * ceil32(return_data.size)) + 260] = mem[_1613 + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                            require _6062 + (32 * _6143) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + _6062 + 292
                            s = _1613 + (2 * ceil32(return_data.size)) + 292
                            while idx < _1613 + ceil32(return_data.size) + _6062 + (32 * _6143) + 292:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6143:
                                revert with 'NH{q', 50
                            if mem[_1613 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8724 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8724] == bool(mem[_8724])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9124 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9124] == bool(mem[_9124])
                    else:
                        mem[_1613 + 164] = return_data.size
                        mem[_1613 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size <= 0:
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6063 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6144 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6144
                            require _6063 + (32 * _6144) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6063 + (32 * _6144) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6144:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8725 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8725] == bool(mem[_8725])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9125 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9125] == bool(mem[_9125])
                        else:
                            require return_data.size >= 32
                            require mem[_1613 + 196] == bool(mem[_1613 + 196])
                            if not mem[_1613 + 196]:
                                revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                            mem[_1613 + ceil32(return_data.size) + 169] = this.address
                            require ext_code.size(stor6)
                            staticcall stor6.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1613 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                            idx = 0
                            s = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                            t = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                            require ext_code.size(address(stor3))
                            call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 1, Array(len=2, data=mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                            require return_data.size >= 32
                            _6064 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                            require mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                            require _1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                            _6145 = mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                            if mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                revert with 'NH{q', 65
                            if _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                revert with 'NH{q', 65
                            mem[64] = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_1613 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                            mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _6145
                            require _6064 + (32 * _6145) + 32 <= return_data.size
                            idx = _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + 293
                            s = _1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                            while idx < _1613 + ceil32(return_data.size) + ceil32(return_data.size) + _6064 + (32 * _6145) + 293:
                                require mem[idx] == mem[idx]
                                mem[s] = mem[idx]
                                idx = idx + 32
                                s = s + 32
                                continue 
                            if 1 >= _6145:
                                revert with 'NH{q', 50
                            if mem[_1613 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                revert with 0, 'received < initial balance'
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                               value stor7 wei
                                 gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8726 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8726] == bool(mem[_8726])
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = stor7
                            require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                            call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, stor7
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9126 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_9126] == bool(mem[_9126])
        else:
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 133] = address(stor4)
            require ext_code.size(stor5)
            staticcall stor5.0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor4)
            mem[ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0]:
                revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133] = address(stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 165] = -1
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 97] = 68
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 133 len 28] = Mask(224, 0, stor4)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 129 len 4] = approve(address arg1, uint256 arg2)
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 197] = 32
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 229] = 'SafeERC20: low-level call failed'
            if eth.balance(this.address) < 0:
                revert with 0, 'Address: insufficient balance for call'
            if ext_code.size(stor5) <= 0:
                revert with 0, 'Address: call to non-contract'
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261 len 96] = approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0
            mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 329] = 0
            call stor5 with:
               funct Mask(32, 224, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) >> 224
                 gas gas_remaining wei
                args (Mask(512, -288, approve(address arg1, uint256 arg2), Mask(224, 0, stor4), uint32(stor4), -1, 0) << 288)
            if not return_data.size:
                if not ext_call.success:
                    if arg4.length > 0:
                        revert with arg4[all]
                    revert with 0, 'SafeERC20: low-level call failed'
                if arg4.length <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1436 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1453 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1436 + (32 * _1453) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1436 + (32 * _1453) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3444 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3444] == mem[_3444]
                    mem[mem[64] + 4] = this.address
                    if mem[_3444]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3592 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3601 = mem[_3592]
                        require mem[_3592] == mem[_3592]
                        _3655 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 32] = stor6
                        if 1 >= mem[_3655]:
                            revert with 'NH{q', 50
                        mem[_3655 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3655 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3655 + 100] = _3601
                        mem[_3655 + 132] = 1
                        mem[_3655 + 164] = 160
                        mem[_3655 + 260] = mem[_3655]
                        idx = 0
                        s = _3655 + 32
                        t = _3655 + 292
                        while idx < mem[_3655]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3655 + 196] = this.address
                        mem[_3655 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3655 + (32 * mem[_3655]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6045 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6077 = mem[_6045]
                        require mem[_6045] <= test266151307()
                        require _6045 + mem[_6045] + 31 < _6045 + return_data.size
                        _6166 = mem[_6045 + mem[_6045]]
                        if mem[_6045 + mem[_6045]] > test266151307():
                            revert with 'NH{q', 65
                        if _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1 > test266151307() or floor32(mem[_6045 + mem[_6045]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6045 + ceil32(return_data.size) + floor32(mem[_6045 + mem[_6045]]) + 1
                        mem[_6045 + ceil32(return_data.size)] = _6166
                        require _6077 + (32 * _6166) + 32 <= return_data.size
                        idx = _6045 + _6077 + 32
                        s = _6045 + ceil32(return_data.size) + 32
                        while idx < _6045 + _6077 + (32 * _6166) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6166:
                            revert with 'NH{q', 50
                        if mem[_6045 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8731 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8731] == bool(mem[_8731])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9131 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9131] == bool(mem[_9131])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3620] == mem[_3620]
                        if mem[_3620]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3695 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3744 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3695 + 100] = 32
                        mem[_3695 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3810 = mem[_3744]
                        mem[_3695 + 164 len ceil32(mem[_3744])] = mem[_3744 + 32 len ceil32(mem[_3744])]
                        if ceil32(_3810) <= _3810:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8927 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9007 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8927 + (32 * _9007) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8927 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8927 + (32 * _9007) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9007:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10559 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10559] == bool(mem[_10559])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10879 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10879] == bool(mem[_10879])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8928 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9008 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8928 + (32 * _9008) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8928 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8928 + (32 * _9008) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9008:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10560] == bool(mem[_10560])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10880 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10880] == bool(mem[_10880])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8929 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9009 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9009
                                    require _8929 + (32 * _9009) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8929 + (32 * _9009) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9009:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10561 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10561] == bool(mem[_10561])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10881 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10881] == bool(mem[_10881])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8930 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9010 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9010
                                    require _8930 + (32 * _9010) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8930 + (32 * _9010) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9010:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10562 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10562] == bool(mem[_10562])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10882 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10882] == bool(mem[_10882])
                        else:
                            mem[_3695 + _3810 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3695 + 168 len _3810 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8931 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9011 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8931 + (32 * _9011) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8931 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8931 + (32 * _9011) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9011:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10563 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10563] == bool(mem[_10563])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10883 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10883] == bool(mem[_10883])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 164] = 2
                                    mem[_3695 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3695 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + 296] = 1
                                    mem[_3695 + ceil32(return_data.size) + 328] = 160
                                    mem[_3695 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + 196
                                    t = _3695 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3695 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8932 = mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3695 + ceil32(return_data.size) + return_data.size + 260
                                    _9012 = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3695 + (2 * ceil32(return_data.size)) + 260] = mem[_3695 + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8932 + (32 * _9012) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + _8932 + 292
                                    s = _3695 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3695 + ceil32(return_data.size) + _8932 + (32 * _9012) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9012:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10564 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10564] == bool(mem[_10564])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10884 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10884] == bool(mem[_10884])
                            else:
                                mem[_3695 + 164] = return_data.size
                                mem[_3695 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8933 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9013 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9013
                                    require _8933 + (32 * _9013) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8933 + (32 * _9013) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9013:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10565 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10565] == bool(mem[_10565])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10885 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10885] == bool(mem[_10885])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3695 + 196] == bool(mem[_3695 + 196])
                                    if not mem[_3695 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3695 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3695 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8934 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9014 = mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3695 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9014
                                    require _8934 + (32 * _9014) + 32 <= return_data.size
                                    idx = _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + 293
                                    s = _3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3695 + ceil32(return_data.size) + ceil32(return_data.size) + _8934 + (32 * _9014) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9014:
                                        revert with 'NH{q', 50
                                    if mem[_3695 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10566 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10566] == bool(mem[_10566])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10886 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10886] == bool(mem[_10886])
                else:
                    require arg4.length >= 32
                    require mem[128] == bool(mem[128])
                    if not mem[128]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 265] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 261] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 325] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 361] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 393] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 425] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 521] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 293
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 457] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 489] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 553 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357
                    require return_data.size >= 32
                    _1437 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 388 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + return_data.size + 357
                    _1454 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]) + 358
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 357] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + 357 len 4], ext_call.return_data[0 len 28] + 357]
                    require _1437 + (32 * _1454) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + 389
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + 389
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + _1437 + (32 * _1454) + 389:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3445 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3445] == mem[_3445]
                    mem[mem[64] + 4] = this.address
                    if mem[_3445]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3593 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3602 = mem[_3593]
                        require mem[_3593] == mem[_3593]
                        _3656 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 32] = stor6
                        if 1 >= mem[_3656]:
                            revert with 'NH{q', 50
                        mem[_3656 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3656 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3656 + 100] = _3602
                        mem[_3656 + 132] = 1
                        mem[_3656 + 164] = 160
                        mem[_3656 + 260] = mem[_3656]
                        idx = 0
                        s = _3656 + 32
                        t = _3656 + 292
                        while idx < mem[_3656]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3656 + 196] = this.address
                        mem[_3656 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3656 + (32 * mem[_3656]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6048 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6080 = mem[_6048]
                        require mem[_6048] <= test266151307()
                        require _6048 + mem[_6048] + 31 < _6048 + return_data.size
                        _6171 = mem[_6048 + mem[_6048]]
                        if mem[_6048 + mem[_6048]] > test266151307():
                            revert with 'NH{q', 65
                        if _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1 > test266151307() or floor32(mem[_6048 + mem[_6048]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6048 + ceil32(return_data.size) + floor32(mem[_6048 + mem[_6048]]) + 1
                        mem[_6048 + ceil32(return_data.size)] = _6171
                        require _6080 + (32 * _6171) + 32 <= return_data.size
                        idx = _6048 + _6080 + 32
                        s = _6048 + ceil32(return_data.size) + 32
                        while idx < _6048 + _6080 + (32 * _6171) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6171:
                            revert with 'NH{q', 50
                        if mem[_6048 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8732 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8732] == bool(mem[_8732])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9132 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9132] == bool(mem[_9132])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3621 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3621] == mem[_3621]
                        if mem[_3621]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3697 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3746 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3697 + 100] = 32
                        mem[_3697 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3811 = mem[_3746]
                        mem[_3697 + 164 len ceil32(mem[_3746])] = mem[_3746 + 32 len ceil32(mem[_3746])]
                        if ceil32(_3811) <= _3811:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8935 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9015 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9015
                                    require _8935 + (32 * _9015) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8935 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8935 + (32 * _9015) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9015:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10567 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10567] == bool(mem[_10567])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10887 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10887] == bool(mem[_10887])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8936 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9016 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9016
                                    require _8936 + (32 * _9016) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8936 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8936 + (32 * _9016) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9016:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10568 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10568] == bool(mem[_10568])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10888 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10888] == bool(mem[_10888])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8937 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9017 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9017
                                    require _8937 + (32 * _9017) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8937 + (32 * _9017) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9017:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10569 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10569] == bool(mem[_10569])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10889 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10889] == bool(mem[_10889])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8938 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9018 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9018
                                    require _8938 + (32 * _9018) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8938 + (32 * _9018) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9018:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10570 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10570] == bool(mem[_10570])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10890 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10890] == bool(mem[_10890])
                        else:
                            mem[_3697 + _3811 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3697 + 168 len _3811 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8939 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9019 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9019
                                    require _8939 + (32 * _9019) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8939 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8939 + (32 * _9019) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9019:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10571 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10571] == bool(mem[_10571])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10891 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10891] == bool(mem[_10891])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 164] = 2
                                    mem[_3697 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3697 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + 296] = 1
                                    mem[_3697 + ceil32(return_data.size) + 328] = 160
                                    mem[_3697 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + 196
                                    t = _3697 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3697 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8940 = mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3697 + ceil32(return_data.size) + return_data.size + 260
                                    _9020 = mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3697 + (2 * ceil32(return_data.size)) + 260] = _9020
                                    require _8940 + (32 * _9020) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + _8940 + 292
                                    s = _3697 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3697 + ceil32(return_data.size) + _8940 + (32 * _9020) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9020:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10572 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10572] == bool(mem[_10572])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10892 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10892] == bool(mem[_10892])
                            else:
                                mem[_3697 + 164] = return_data.size
                                mem[_3697 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8941 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9021 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9021
                                    require _8941 + (32 * _9021) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8941 + (32 * _9021) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9021:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10573 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10573] == bool(mem[_10573])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10893 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10893] == bool(mem[_10893])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3697 + 196] == bool(mem[_3697 + 196])
                                    if not mem[_3697 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3697 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3697 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8942 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9022 = mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3697 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9022
                                    require _8942 + (32 * _9022) + 32 <= return_data.size
                                    idx = _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + 293
                                    s = _3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3697 + ceil32(return_data.size) + ceil32(return_data.size) + _8942 + (32 * _9022) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9022:
                                        revert with 'NH{q', 50
                                    if mem[_3697 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10574 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10574] == bool(mem[_10574])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10894 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10894] == bool(mem[_10894])
            else:
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 261] = return_data.size
                mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size > 0:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size <= 0:
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1438 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1455 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1438 + (32 * _1455) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1438 + (32 * _1455) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3446 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3446] == mem[_3446]
                    mem[mem[64] + 4] = this.address
                    if mem[_3446]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3594 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3603 = mem[_3594]
                        require mem[_3594] == mem[_3594]
                        _3657 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 32] = stor6
                        if 1 >= mem[_3657]:
                            revert with 'NH{q', 50
                        mem[_3657 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3657 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3657 + 100] = _3603
                        mem[_3657 + 132] = 1
                        mem[_3657 + 164] = 160
                        mem[_3657 + 260] = mem[_3657]
                        idx = 0
                        s = _3657 + 32
                        t = _3657 + 292
                        while idx < mem[_3657]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3657 + 196] = this.address
                        mem[_3657 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3657 + (32 * mem[_3657]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6051 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6083 = mem[_6051]
                        require mem[_6051] <= test266151307()
                        require _6051 + mem[_6051] + 31 < _6051 + return_data.size
                        _6176 = mem[_6051 + mem[_6051]]
                        if mem[_6051 + mem[_6051]] > test266151307():
                            revert with 'NH{q', 65
                        if _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1 > test266151307() or floor32(mem[_6051 + mem[_6051]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6051 + ceil32(return_data.size) + floor32(mem[_6051 + mem[_6051]]) + 1
                        mem[_6051 + ceil32(return_data.size)] = _6176
                        require _6083 + (32 * _6176) + 32 <= return_data.size
                        idx = _6051 + _6083 + 32
                        s = _6051 + ceil32(return_data.size) + 32
                        while idx < _6051 + _6083 + (32 * _6176) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6176:
                            revert with 'NH{q', 50
                        if mem[_6051 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8733 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8733] == bool(mem[_8733])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9133 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9133] == bool(mem[_9133])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3622 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3622] == mem[_3622]
                        if mem[_3622]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3699 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3748 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3699 + 100] = 32
                        mem[_3699 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3812 = mem[_3748]
                        mem[_3699 + 164 len ceil32(mem[_3748])] = mem[_3748 + 32 len ceil32(mem[_3748])]
                        if ceil32(_3812) <= _3812:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8943 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9023 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9023
                                    require _8943 + (32 * _9023) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8943 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8943 + (32 * _9023) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9023:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10575 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10575] == bool(mem[_10575])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10895 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10895] == bool(mem[_10895])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8944 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9024 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9024
                                    require _8944 + (32 * _9024) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8944 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8944 + (32 * _9024) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9024:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10576 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10576] == bool(mem[_10576])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10896 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10896] == bool(mem[_10896])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8945 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9025 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9025
                                    require _8945 + (32 * _9025) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8945 + (32 * _9025) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9025:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10577 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10577] == bool(mem[_10577])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10897 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10897] == bool(mem[_10897])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8946 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9026 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9026
                                    require _8946 + (32 * _9026) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8946 + (32 * _9026) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9026:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10578 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10578] == bool(mem[_10578])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10898 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10898] == bool(mem[_10898])
                        else:
                            mem[_3699 + _3812 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3699 + 168 len _3812 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8947 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9027 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9027
                                    require _8947 + (32 * _9027) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8947 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8947 + (32 * _9027) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9027:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10579 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10579] == bool(mem[_10579])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10899 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10899] == bool(mem[_10899])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 164] = 2
                                    mem[_3699 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3699 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + 296] = 1
                                    mem[_3699 + ceil32(return_data.size) + 328] = 160
                                    mem[_3699 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + 196
                                    t = _3699 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3699 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8948 = mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3699 + ceil32(return_data.size) + return_data.size + 260
                                    _9028 = mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3699 + (2 * ceil32(return_data.size)) + 260] = _9028
                                    require _8948 + (32 * _9028) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + _8948 + 292
                                    s = _3699 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3699 + ceil32(return_data.size) + _8948 + (32 * _9028) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9028:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10580 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10580] == bool(mem[_10580])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10900 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10900] == bool(mem[_10900])
                            else:
                                mem[_3699 + 164] = return_data.size
                                mem[_3699 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8949 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9029 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9029
                                    require _8949 + (32 * _9029) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8949 + (32 * _9029) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9029:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10581 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10581] == bool(mem[_10581])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10901 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10901] == bool(mem[_10901])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3699 + 196] == bool(mem[_3699 + 196])
                                    if not mem[_3699 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3699 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3699 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8950 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9030 = mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3699 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = _9030
                                    require _8950 + (32 * _9030) + 32 <= return_data.size
                                    idx = _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + 293
                                    s = _3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3699 + ceil32(return_data.size) + ceil32(return_data.size) + _8950 + (32 * _9030) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9030:
                                        revert with 'NH{q', 50
                                    if mem[_3699 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10582 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10582] == bool(mem[_10582])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10902 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10902] == bool(mem[_10902])
                else:
                    require return_data.size >= 32
                    require mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293] == bool(mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293])
                    if not mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + 293]:
                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 266] = this.address
                    require ext_code.size(stor5)
                    staticcall stor5.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(ceil32(arg4.length)) + (2 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 262] = 2
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294] = stor5
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 326] = stor6
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 362] = ext_call.return_data[0]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 394] = 1
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 426] = 160
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 522] = 2
                    idx = 0
                    s = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 294
                    t = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 458] = this.address
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 490] = stor8
                    require ext_code.size(address(stor4))
                    call address(stor4).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args ext_call.return_data[0], 1, Array(len=2, data=mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 554 len 64]), address(this.address), stor8
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358
                    require return_data.size >= 32
                    _1439 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28]
                    require mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] <= test266151307()
                    require ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 389 < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + return_data.size + 358
                    _1456 = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    if mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358] > test266151307():
                        revert with 'NH{q', 65
                    if ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359 > test266151307() or floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 1 < 0:
                        revert with 'NH{q', 65
                    mem[64] = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + floor32(mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]) + 359
                    mem[ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 358] = mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + mem[ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + 358 len 4], ext_call.return_data[0 len 28] + 358]
                    require _1439 + (32 * _1456) + 32 <= return_data.size
                    idx = ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + 390
                    s = ceil32(ceil32(arg4.length)) + (6 * ceil32(return_data.size)) + ceil32(return_data.size) + 390
                    while idx < ceil32(ceil32(arg4.length)) + (4 * ceil32(return_data.size)) + ceil32(return_data.size) + _1439 + (32 * _1456) + 390:
                        require mem[idx] == mem[idx]
                        mem[s] = mem[idx]
                        idx = idx + 32
                        s = s + 32
                        continue 
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(stor3)
                    require ext_code.size(stor6)
                    staticcall stor6.0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(stor3)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3447 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_3447] == mem[_3447]
                    mem[mem[64] + 4] = this.address
                    if mem[_3447]:
                        require ext_code.size(stor6)
                        staticcall stor6.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3595 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3604 = mem[_3595]
                        require mem[_3595] == mem[_3595]
                        _3658 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 32] = stor6
                        if 1 >= mem[_3658]:
                            revert with 'NH{q', 50
                        mem[_3658 + 64] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                        mem[_3658 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[_3658 + 100] = _3604
                        mem[_3658 + 132] = 1
                        mem[_3658 + 164] = 160
                        mem[_3658 + 260] = mem[_3658]
                        idx = 0
                        s = _3658 + 32
                        t = _3658 + 292
                        while idx < mem[_3658]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[_3658 + 196] = this.address
                        mem[_3658 + 228] = stor8
                        require ext_code.size(address(stor3))
                        call address(stor3).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _3658 + (32 * mem[_3658]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6054 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _6086 = mem[_6054]
                        require mem[_6054] <= test266151307()
                        require _6054 + mem[_6054] + 31 < _6054 + return_data.size
                        _6181 = mem[_6054 + mem[_6054]]
                        if mem[_6054 + mem[_6054]] > test266151307():
                            revert with 'NH{q', 65
                        if _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1 > test266151307() or floor32(mem[_6054 + mem[_6054]]) + 1 < 0:
                            revert with 'NH{q', 65
                        mem[64] = _6054 + ceil32(return_data.size) + floor32(mem[_6054 + mem[_6054]]) + 1
                        mem[_6054 + ceil32(return_data.size)] = _6181
                        require _6086 + (32 * _6181) + 32 <= return_data.size
                        idx = _6054 + _6086 + 32
                        s = _6054 + ceil32(return_data.size) + 32
                        while idx < _6054 + _6086 + (32 * _6181) + 32:
                            require mem[idx] == mem[idx]
                            mem[s] = mem[idx]
                            idx = idx + 32
                            s = s + 32
                            continue 
                        if 1 >= _6181:
                            revert with 'NH{q', 50
                        if mem[_6054 + ceil32(return_data.size) + 64] <= stor7:
                            revert with 0, 'received < initial balance'
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                           value stor7 wei
                             gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8734 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_8734] == bool(mem[_8734])
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = stor7
                        require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                        call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, stor7
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9134 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_9134] == bool(mem[_9134])
                    else:
                        mem[mem[64] + 36] = address(stor3)
                        require ext_code.size(stor6)
                        staticcall stor6.0xdd62ed3e with:
                                gas gas_remaining wei
                               args address(this.address), address(stor3)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3623 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_3623] == mem[_3623]
                        if mem[_3623]:
                            revert with 0, 'SafeERC20: approve from non-zero to non-zero allowance'
                        _3701 = mem[64]
                        mem[mem[64] + 36] = address(stor3)
                        mem[mem[64] + 68] = -1
                        _3750 = mem[64]
                        mem[mem[64]] = 68
                        mem[mem[64] + 32 len 4] = approve(address arg1, uint256 arg2)
                        mem[64] = mem[64] + 164
                        mem[_3701 + 100] = 32
                        mem[_3701 + 132] = 'SafeERC20: low-level call failed'
                        if eth.balance(this.address) < 0:
                            revert with 0, 'Address: insufficient balance for call'
                        if ext_code.size(stor6) <= 0:
                            revert with 0, 'Address: call to non-contract'
                        _3813 = mem[_3750]
                        mem[_3701 + 164 len ceil32(mem[_3750])] = mem[_3750 + 32 len ceil32(mem[_3750])]
                        if ceil32(_3813) <= _3813:
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8951 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9031 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8951 + (32 * _9031) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8951 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8951 + (32 * _9031) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9031:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10583 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10583] == bool(mem[_10583])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10903 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10903] == bool(mem[_10903])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8952 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9032 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8952 + (32 * _9032) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8952 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8952 + (32 * _9032) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9032:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10584 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10584] == bool(mem[_10584])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10904 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10904] == bool(mem[_10904])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8953 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9033 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8953 + (32 * _9033) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8953 + (32 * _9033) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9033:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10585 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10585] == bool(mem[_10585])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10905 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10905] == bool(mem[_10905])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8954 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9034 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8954 + (32 * _9034) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8954 + (32 * _9034) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9034:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10586 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10586] == bool(mem[_10586])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10906 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10906] == bool(mem[_10906])
                        else:
                            mem[_3701 + _3813 + 164] = 0
                            call stor6 with:
                                 gas gas_remaining wei
                                args mem[_3701 + 168 len _3813 - 4]
                            if not return_data.size:
                                if not ext_call.success:
                                    if arg4.length > 0:
                                        revert with arg4[all]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if arg4.length <= 0:
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8955 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9035 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8955 + (32 * _9035) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8955 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8955 + (32 * _9035) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9035:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10587 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10587] == bool(mem[_10587])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10907 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10907] == bool(mem[_10907])
                                else:
                                    require arg4.length >= 32
                                    require mem[128] == bool(mem[128])
                                    if not mem[128]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + 168] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + 164] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 164] = 2
                                    mem[_3701 + ceil32(return_data.size) + 196] = stor6
                                    mem[_3701 + ceil32(return_data.size) + 228] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + 260] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + 264] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + 296] = 1
                                    mem[_3701 + ceil32(return_data.size) + 328] = 160
                                    mem[_3701 + ceil32(return_data.size) + 424] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + 196
                                    t = _3701 + ceil32(return_data.size) + 456
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + 360] = this.address
                                    mem[_3701 + ceil32(return_data.size) + 392] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + 456 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + 260 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + 260
                                    require return_data.size >= 32
                                    _8956 = mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 291 < _3701 + ceil32(return_data.size) + return_data.size + 260
                                    _9036 = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    if mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]) + 261
                                    mem[_3701 + (2 * ceil32(return_data.size)) + 260] = mem[_3701 + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + 260 len 4], ext_call.return_data[0 len 28] + 260]
                                    require _8956 + (32 * _9036) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + _8956 + 292
                                    s = _3701 + (2 * ceil32(return_data.size)) + 292
                                    while idx < _3701 + ceil32(return_data.size) + _8956 + (32 * _9036) + 292:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9036:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + (2 * ceil32(return_data.size)) + 324] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10588 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10588] == bool(mem[_10588])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10908 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10908] == bool(mem[_10908])
                            else:
                                mem[_3701 + 164] = return_data.size
                                mem[_3701 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size > 0:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size <= 0:
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8957 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9037 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8957 + (32 * _9037) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8957 + (32 * _9037) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9037:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10589 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10589] == bool(mem[_10589])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10909 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10909] == bool(mem[_10909])
                                else:
                                    require return_data.size >= 32
                                    require mem[_3701 + 196] == bool(mem[_3701 + 196])
                                    if not mem[_3701 + 196]:
                                        revert with 0, 'SafeERC20: ERC20 operation did not succeed'
                                    mem[_3701 + ceil32(return_data.size) + 169] = this.address
                                    require ext_code.size(stor6)
                                    staticcall stor6.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[_3701 + ceil32(return_data.size) + 165] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 165] = 2
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197] = stor6
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 229] = 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 265] = ext_call.return_data[0]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 297] = 1
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 329] = 160
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 425] = 2
                                    idx = 0
                                    s = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 197
                                    t = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457
                                    while idx < 2:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 361] = this.address
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 393] = stor8
                                    require ext_code.size(address(stor3))
                                    call address(stor3).swapExactTokensForETH(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], 1, Array(len=2, data=mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 457 len 64]), address(this.address), stor8
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261
                                    require return_data.size >= 32
                                    _8958 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28]
                                    require mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] <= test266151307()
                                    require _3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 292 < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + return_data.size + 261
                                    _9038 = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    if mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261] > test266151307():
                                        revert with 'NH{q', 65
                                    if _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262 > test266151307() or floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 1 < 0:
                                        revert with 'NH{q', 65
                                    mem[64] = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + floor32(mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]) + 262
                                    mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 261] = mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + mem[_3701 + ceil32(return_data.size) + ceil32(return_data.size) + 261 len 4], ext_call.return_data[0 len 28] + 261]
                                    require _8958 + (32 * _9038) + 32 <= return_data.size
                                    idx = _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + 293
                                    s = _3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 293
                                    while idx < _3701 + ceil32(return_data.size) + ceil32(return_data.size) + _8958 + (32 * _9038) + 293:
                                        require mem[idx] == mem[idx]
                                        mem[s] = mem[idx]
                                        idx = idx + 32
                                        s = s + 32
                                        continue 
                                    if 1 >= _9038:
                                        revert with 'NH{q', 50
                                    if mem[_3701 + ceil32(return_data.size) + (2 * ceil32(return_data.size)) + 325] <= stor7:
                                        revert with 0, 'received < initial balance'
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.deposit() with:
                                       value stor7 wei
                                         gas gas_remaining wei
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10590 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10590] == bool(mem[_10590])
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = stor7
                                    require ext_code.size(0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83)
                                    call 0x21be370d5312f44cb42ce377bc9b8a0cef1a4c83.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, stor7
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _10910 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_10910] == bool(mem[_10910])
    call stor0 with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}



}
