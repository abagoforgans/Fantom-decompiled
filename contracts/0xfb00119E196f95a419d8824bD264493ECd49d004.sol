contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#
address _owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
mapping of uint8 stor5;
array of address stor6;
array of struct stor7;
array of struct stor8;
uint256 decimals;
address feeAddress;
uint256 stor13;
uint256 totalSupply;
uint256 stor15;
uint256 totalFees;
uint256 totalBurn;
uint256 totalCharity;
uint256 _TAX_FEE;
uint256 _BURN_FEE;
uint256 _CHARITY_FEE;
address stor22;
uint256 stor23;
uint256 stor24;
uint256 stor25;

function totalFees() payable {
    return totalFees
}

function totalSupply() payable {
    return totalSupply
}

function decimals() payable {
    return decimals
}

function totalBurn() payable {
    return totalBurn
}

function _BURN_FEE() payable {
    return _BURN_FEE
}

function FeeAddress() payable {
    return feeAddress
}

function owner() payable {
    return _owner
}

function _CHARITY_FEE() payable {
    return _CHARITY_FEE
}

function _owner() payable {
    return _owner
}

function _TAX_FEE() payable {
    return _TAX_FEE
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function totalCharity() payable {
    return totalCharity
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function isCharity(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor5[address(arg1)])
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(_owner, 0);
    _owner = 0
}

function setAsCharityAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor5[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Account is already charity account'
    stor5[address(arg1)] = 1
    feeAddress = arg1
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(_owner, arg1);
    _owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function burn(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= stor1[address(msg.sender)]
    if arg1 > stor1[address(msg.sender)]:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if stor1[address(msg.sender)] < arg1:
        revert with 0, 17
    stor1[address(msg.sender)] -= arg1
    if arg1 > totalSupply:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if totalSupply < arg1:
        revert with 0, 17
    totalSupply -= arg1
    emit 0x65ddf252: arg1, msg.sender, 0
}

function mint(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if totalSupply > !arg2:
        revert with 0, 17
    if totalSupply + arg2 < totalSupply:
        revert with 0, 'SafeMath: addition overflow'
    totalSupply += arg2
    if stor1[address(arg1)] > !arg2:
        revert with 0, 17
    if stor1[address(arg1)] + arg2 < stor1[address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    stor1[address(arg1)] += arg2
    emit 0x65ddf252: arg2, 0, arg1
}

function updateFee(uint256 arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _TAX_FEE = 100 * arg1
    if arg2 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _BURN_FEE = 100 * arg2
    if arg3 > 0x28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f5c28f:
        revert with 0, 17
    _CHARITY_FEE = 100 * arg3
    stor23 = _TAX_FEE
    stor24 = _BURN_FEE
    stor25 = 100 * arg3
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 39, 0xfe544f4b454e32303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[167 len 25] >> 56, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TOKEN20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor6.length:
        mem[0] = 6
        if stor6[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor6.length < 1:
            revert with 0, 17
        if stor6.length - 1 >= stor6.length:
            revert with 0, 50
        if idx >= stor6.length:
            revert with 0, 50
        stor6[idx] = stor6[stor6.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor6.length:
            revert with 0, 49
        stor6[stor6.length] = 0
        stor6.length--
}

function sub_13576e0f(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg3.length)) + 97 < 96 or ceil32(ceil32(arg3.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg3.length
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    mem[arg3.length + 128] = 0
    if stor22 != msg.sender:
        revert with 0, 'm'
    mem[ceil32(ceil32(arg3.length)) + 97 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
    if ceil32(arg3.length) > arg3.length:
        mem[arg3.length + ceil32(ceil32(arg3.length)) + 97] = 0
    call address(arg1).mem[ceil32(ceil32(arg3.length)) + 97 len 4] with:
       value arg2 wei
         gas gas_remaining wei
        args mem[ceil32(ceil32(arg3.length)) + 101 len arg3.length - 4]
}

function name() payable {
    if bool(stor7.length):
        if bool(stor7.length) == stor7.length.field_1 < 32:
            revert with 0, 34
        if bool(stor7.length):
            if bool(stor7.length) == stor7.length.field_1 < 32:
                revert with 0, 34
            if stor7.length.field_1:
                if 31 < stor7.length.field_1:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while stor7.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor7[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length.field_1), data=mem[128 len ceil32(stor7.length.field_1)])
                mem[128] = 256 * stor7.length.field_8
        else:
            if bool(stor7.length) == stor7.length.field_1 < 32:
                revert with 0, 34
            if stor7.length.field_1:
                if 31 < stor7.length.field_1:
                    mem[128] = uint256(stor7.field_0)
                    idx = 128
                    s = 0
                    while stor7.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor7[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor7.length.field_1), data=mem[128 len ceil32(stor7.length.field_1)])
                mem[128] = 256 * stor7.length.field_8
        mem[ceil32(stor7.length.field_1) + 192 len ceil32(stor7.length.field_1)] = mem[128 len ceil32(stor7.length.field_1)]
        if ceil32(stor7.length.field_1) > stor7.length.field_1:
            mem[stor7.length.field_1 + ceil32(stor7.length.field_1) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor7.length.field_1), data=mem[128 len ceil32(stor7.length.field_1)], mem[(2 * ceil32(stor7.length.field_1)) + 192 len 2 * ceil32(stor7.length.field_1)]), 
    if bool(stor7.length) == stor7.length.field_1 < 32:
        revert with 0, 34
    if bool(stor7.length):
        if bool(stor7.length) == stor7.length.field_1 < 32:
            revert with 0, 34
        if stor7.length.field_1:
            if 31 < stor7.length.field_1:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while stor7.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor7[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)])
            mem[128] = 256 * stor7.length.field_8
    else:
        if bool(stor7.length) == stor7.length.field_1 < 32:
            revert with 0, 34
        if stor7.length.field_1:
            if 31 < stor7.length.field_1:
                mem[128] = uint256(stor7.field_0)
                idx = 128
                s = 0
                while stor7.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor7[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)])
            mem[128] = 256 * stor7.length.field_8
    mem[ceil32(stor7.length.field_1) + 192 len ceil32(stor7.length.field_1)] = mem[128 len ceil32(stor7.length.field_1)]
    if ceil32(stor7.length.field_1) > stor7.length.field_1:
        mem[stor7.length.field_1 + ceil32(stor7.length.field_1) + 192] = 0
    return Array(len=stor7.length % 128, data=mem[128 len ceil32(stor7.length.field_1)], mem[(2 * ceil32(stor7.length.field_1)) + 192 len 2 * ceil32(stor7.length.field_1)]), 
}

function symbol() payable {
    if bool(stor8.length):
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if bool(stor8.length):
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 0, 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length.field_1), data=mem[128 len ceil32(stor8.length.field_1)])
                mem[128] = 256 * stor8.length.field_8
        else:
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 0, 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length.field_1), data=mem[128 len ceil32(stor8.length.field_1)])
                mem[128] = 256 * stor8.length.field_8
        mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
        if ceil32(stor8.length.field_1) > stor8.length.field_1:
            mem[stor8.length.field_1 + ceil32(stor8.length.field_1) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor8.length.field_1), data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
    if bool(stor8.length) == stor8.length.field_1 < 32:
        revert with 0, 34
    if bool(stor8.length):
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    else:
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
    if ceil32(stor8.length.field_1) > stor8.length.field_1:
        mem[stor8.length.field_1 + ceil32(stor8.length.field_1) + 192] = 0
    return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor15:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor15
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _97 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _97 + 68] = mem[idx + _92 + 32]
                    idx = idx + 32
                    continue 
                mem[_97 + 94] = 0
                revert with memory
                  from mem[64]
                   len _97 + -mem[64] + 100
            _115 = mem[64]
            mem[64] = mem[64] + 64
            mem[_115] = 26
            mem[_115 + 32] = 'SafeMath: division by zero'
            if stor15 / totalSupply:
                return (arg1 / stor15 / totalSupply)
            _123 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _123 + 68] = mem[idx + _115 + 32]
                idx = idx + 32
                continue 
            mem[_123 + 94] = 0
            revert with memory
              from mem[64]
               len _123 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _104 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _104 + 68] = mem[idx + _98 + 32]
                    idx = idx + 32
                    continue 
                mem[_104 + 94] = 0
                revert with memory
                  from mem[64]
                   len _104 + -mem[64] + 100
            _124 = mem[64]
            mem[64] = mem[64] + 64
            mem[_124] = 26
            mem[_124 + 32] = 'SafeMath: division by zero'
            if stor15 / totalSupply:
                return (arg1 / stor15 / totalSupply)
            _132 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _132 + 68] = mem[idx + _124 + 32]
                idx = idx + 32
                continue 
            mem[_132 + 94] = 0
            revert with memory
              from mem[64]
               len _132 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _96 = mem[64]
        mem[64] = mem[64] + 64
        mem[_96] = 30
        mem[_96 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _100 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _100 + 68] = mem[idx + _96 + 32]
                idx = idx + 32
                continue 
            mem[_100 + 98] = 0
            revert with memory
              from mem[64]
               len _100 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 0, 17
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _120 = mem[64]
        mem[64] = mem[64] + 64
        mem[_120] = 30
        mem[_120 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _130 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _130 + 68] = mem[idx + _120 + 32]
            idx = idx + 32
            continue 
        mem[_130 + 98] = 0
        revert with memory
          from mem[64]
           len _130 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor15 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor15 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor15 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor15:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor15
    while idx < stor6.length:
        mem[0] = stor6[idx]
        mem[32] = 1
        if stor1[stor6[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _102 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _102 + 68] = mem[idx + _97 + 32]
                    idx = idx + 32
                    continue 
                mem[_102 + 94] = 0
                revert with memory
                  from mem[64]
                   len _102 + -mem[64] + 100
            _120 = mem[64]
            mem[64] = mem[64] + 64
            mem[_120] = 26
            mem[_120 + 32] = 'SafeMath: division by zero'
            if stor15 / totalSupply:
                return (stor1[address(arg1)] / stor15 / totalSupply)
            _128 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _128 + 68] = mem[idx + _120 + 32]
                idx = idx + 32
                continue 
            mem[_128 + 94] = 0
            revert with memory
              from mem[64]
               len _128 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        if stor2[stor6[idx]] > s:
            _103 = mem[64]
            mem[64] = mem[64] + 64
            mem[_103] = 26
            mem[_103 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _109 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _109 + 68] = mem[idx + _103 + 32]
                    idx = idx + 32
                    continue 
                mem[_109 + 94] = 0
                revert with memory
                  from mem[64]
                   len _109 + -mem[64] + 100
            _129 = mem[64]
            mem[64] = mem[64] + 64
            mem[_129] = 26
            mem[_129 + 32] = 'SafeMath: division by zero'
            if stor15 / totalSupply:
                return (stor1[address(arg1)] / stor15 / totalSupply)
            _137 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _137 + 68] = mem[idx + _129 + 32]
                idx = idx + 32
                continue 
            mem[_137 + 94] = 0
            revert with memory
              from mem[64]
               len _137 + -mem[64] + 100
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 1
        _101 = mem[64]
        mem[64] = mem[64] + 64
        mem[_101] = 30
        mem[_101 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor6[idx]] > t:
            _105 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _105 + 68] = mem[idx + _101 + 32]
                idx = idx + 32
                continue 
            mem[_105 + 98] = 0
            revert with memory
              from mem[64]
               len _105 + -mem[64] + 100
        if t < stor1[stor6[idx]]:
            revert with 0, 17
        if idx >= stor6.length:
            revert with 0, 50
        mem[0] = stor6[idx]
        mem[32] = 2
        _125 = mem[64]
        mem[64] = mem[64] + 64
        mem[_125] = 30
        mem[_125 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor6[idx]] <= s:
            if s < stor2[stor6[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor6[idx]]
            t = t - stor1[stor6[idx]]
            continue 
        _135 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _135 + 68] = mem[idx + _125 + 32]
            idx = idx + 32
            continue 
        mem[_135 + 98] = 0
        revert with memory
          from mem[64]
           len _135 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor15 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor15 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / stor15 / totalSupply)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if _owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor15:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor15
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_100] = 26
                mem[_100 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _105 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _105 + 68] = mem[idx + _100 + 32]
                        idx = idx + 32
                        continue 
                    mem[_105 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _105 + -mem[64] + 100
                _123 = mem[64]
                mem[64] = mem[64] + 64
                mem[_123] = 26
                mem[_123 + 32] = 'SafeMath: division by zero'
                if stor15 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor15 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _131 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _131 + 68] = mem[idx + _123 + 32]
                    idx = idx + 32
                    continue 
                mem[_131 + 94] = 0
                revert with memory
                  from mem[64]
                   len _131 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] > s:
                _106 = mem[64]
                mem[64] = mem[64] + 64
                mem[_106] = 26
                mem[_106 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _112 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _112 + 68] = mem[idx + _106 + 32]
                        idx = idx + 32
                        continue 
                    mem[_112 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _112 + -mem[64] + 100
                _132 = mem[64]
                mem[64] = mem[64] + 64
                mem[_132] = 26
                mem[_132 + 32] = 'SafeMath: division by zero'
                if stor15 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor15 / totalSupply
                    stor4[address(arg1)] = 1
                    stor6.length++
                    stor6[stor6.length] = arg1
                _140 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _140 + 68] = mem[idx + _132 + 32]
                    idx = idx + 32
                    continue 
                mem[_140 + 94] = 0
                revert with memory
                  from mem[64]
                   len _140 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 1
            _104 = mem[64]
            mem[64] = mem[64] + 64
            mem[_104] = 30
            mem[_104 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor6[idx]] > t:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _108 + 68] = mem[idx + _104 + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 98] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            if t < stor1[stor6[idx]]:
                revert with 0, 17
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 30
            mem[_128 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor6[idx]] <= s:
                if s < stor2[stor6[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor6[idx]]
                t = t - stor1[stor6[idx]]
                continue 
            _138 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _138 + 68] = mem[idx + _128 + 32]
                idx = idx + 32
                continue 
            mem[_138 + 98] = 0
            revert with memory
              from mem[64]
               len _138 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor15 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor15 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor15 / totalSupply
    stor4[address(arg1)] = 1
    stor6.length++
    stor6[stor6.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if not arg1:
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if not stor13:
                        revert with 0, 'SafeMath: division by zero', 0
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0 / stor13 / 100:
                        revert with 0, 17
                    mem[544] = 30
                    mem[576] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (0 / stor13 / 100) < 0 / stor13 / 100:
                        revert with 0, 17
                    mem[64] = 672
                    mem[608] = 30
                    mem[640] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 > arg1 - (2 * 0 / stor13 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (2 * 0 / stor13 / 100) < 0 / stor13 / 100:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor15
                    while idx < stor6.length:
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        if stor1[stor6[idx]] > t:
                            _19168 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19168] = 26
                            mem[_19168 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _19241 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _19241 + 68] = mem[idx + _19168 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19241 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _19241 + -mem[64] + 100
                            if not arg1:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20350 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20350] = 30
                                    mem[_20350 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20600 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20600 + 68] = mem[idx + _20350 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20600 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20600 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21539 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21539] = 30
                                    mem[_21539 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22073 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22073 + 68] = mem[idx + _21539 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22073 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22073 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24378] = 30
                                    mem[_24378 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25453 + 68] = mem[idx + _24378 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25453 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25453 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _21095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21095] = 30
                                    mem[_21095 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _21538 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21538 + 68] = mem[idx + _21095 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21538 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21538 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _23381 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23381] = 30
                                    mem[_23381 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _24377 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24377 + 68] = mem[idx + _23381 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24377 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24377 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _27511 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27511] = 30
                                    mem[_27511 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                            revert with 0, 17
                                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                    _28851 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _28851 + 68] = mem[idx + _27511 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28851 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28851 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _22749 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22749] = 30
                                mem[_22749 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _23380 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23380 + 68] = mem[idx + _22749 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23380 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23380 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _26276 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26276] = 30
                                mem[_26276 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _27510 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27510 + 68] = mem[idx + _26276 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27510 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27510 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _31041 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31041] = 30
                                mem[_31041 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _32263 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _32263 + 68] = mem[idx + _31041 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32263 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _32263 + -mem[64] + 100
                            if arg1 and stor15 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20348 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20348] = 30
                                mem[_20348 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20599 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20599 + 68] = mem[idx + _20348 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20599 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20599 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21537 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21537] = 30
                                mem[_21537 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22071 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22071 + 68] = mem[idx + _21537 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22071 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22071 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24376 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24376] = 30
                                mem[_24376 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25451 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25451 + 68] = mem[idx + _24376 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25451 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25451 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21093] = 30
                                mem[_21093 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21536 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21536 + 68] = mem[idx + _21093 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21536 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21536 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23378] = 30
                                mem[_23378 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24375 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24375 + 68] = mem[idx + _23378 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24375 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24375 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27508 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27508] = 30
                                mem[_27508 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28850 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28850 + 68] = mem[idx + _27508 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28850 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28850 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _22747 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22747] = 30
                                mem[_22747 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _23377 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23377 + 68] = mem[idx + _22747 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23377 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23377 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _26274 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26274] = 30
                                mem[_26274 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _27507 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27507 + 68] = mem[idx + _26274 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27507 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27507 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _31038 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_31038] = 30
                                mem[_31038 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _32262 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _32262 + 68] = mem[idx + _31038 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32262 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _32262 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _25449 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25449] = 30
                            mem[_25449 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _26273 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26273 + 68] = mem[idx + _25449 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26273 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26273 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29889 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29889] = 30
                            mem[_29889 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _31037 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _31037 + 68] = mem[idx + _29889 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31037 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _31037 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _34201 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_34201] = 30
                            mem[_34201 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _35001 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _35001 + 68] = mem[idx + _34201 + 32]
                                idx = idx + 32
                                continue 
                            mem[_35001 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _35001 + -mem[64] + 100
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        if stor2[stor6[idx]] <= s:
                            if idx >= stor6.length:
                                revert with 0, 50
                            mem[0] = stor6[idx]
                            mem[32] = 1
                            _19210 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19210] = 30
                            mem[_19210 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor6[idx]] > t:
                                _19274 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19274 + 68] = mem[idx + _19210 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19274 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19274 + -mem[64] + 100
                            if t < stor1[stor6[idx]]:
                                revert with 0, 17
                            if idx >= stor6.length:
                                revert with 0, 50
                            mem[0] = stor6[idx]
                            mem[32] = 2
                            _19600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19600] = 30
                            mem[_19600 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor6[idx]] <= s:
                                if s < stor2[stor6[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor6[idx]]
                                t = t - stor1[stor6[idx]]
                                continue 
                            _19682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19682 + 68] = mem[idx + _19600 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19682 + -mem[64] + 100
                        _19242 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19242] = 26
                        mem[_19242 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19322 + 68] = mem[idx + _19242 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19322 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19322 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20604 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20604] = 30
                                mem[_20604 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20783 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20783 + 68] = mem[idx + _20604 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20783 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20783 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22078 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22078] = 30
                                mem[_22078 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22753 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22753 + 68] = mem[idx + _22078 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22753 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22753 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25458 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25458] = 30
                                mem[_25458 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26282 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26282 + 68] = mem[idx + _25458 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26282 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26282 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21543 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21543] = 30
                                mem[_21543 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22077 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22077 + 68] = mem[idx + _21543 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22077 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22077 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24383 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24383] = 30
                                mem[_24383 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _25457 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25457 + 68] = mem[idx + _24383 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25457 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25457 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _28856 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28856] = 30
                                mem[_28856 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _29894 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29894 + 68] = mem[idx + _28856 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29894 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29894 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _23385 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23385] = 30
                            mem[_23385 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _24382 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24382 + 68] = mem[idx + _23385 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24382 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24382 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27517 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27517] = 30
                            mem[_27517 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _28855 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28855 + 68] = mem[idx + _27517 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28855 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28855 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _32268 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32268] = 30
                            mem[_32268 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _33334 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33334 + 68] = mem[idx + _32268 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33334 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33334 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20602] = 30
                            mem[_20602 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20782 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20782 + 68] = mem[idx + _20602 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20782 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20782 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22076 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22076] = 30
                            mem[_22076 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22751 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22751 + 68] = mem[idx + _22076 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22751 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22751 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25456 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25456] = 30
                            mem[_25456 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26280 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26280 + 68] = mem[idx + _25456 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26280 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26280 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21541 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21541] = 30
                            mem[_21541 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22075 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22075 + 68] = mem[idx + _21541 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22075 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22075 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24380 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24380] = 30
                            mem[_24380 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25455 + 68] = mem[idx + _24380 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25455 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25455 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _28853 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28853] = 30
                            mem[_28853 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29893 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29893 + 68] = mem[idx + _28853 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29893 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29893 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _23383 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23383] = 30
                            mem[_23383 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _24379 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24379 + 68] = mem[idx + _23383 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24379 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24379 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27515 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27515] = 30
                            mem[_27515 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _28852 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28852 + 68] = mem[idx + _27515 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28852 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28852 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _32265 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_32265] = 30
                            mem[_32265 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _33333 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _33333 + 68] = mem[idx + _32265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33333 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _33333 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _26278 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26278] = 30
                        mem[_26278 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27514 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27514 + 68] = mem[idx + _26278 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27514 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27514 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _31044 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_31044] = 30
                        mem[_31044 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _32264 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32264 + 68] = mem[idx + _31044 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32264 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32264 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _35002 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_35002] = 30
                        mem[_35002 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _35762 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35762 + 68] = mem[idx + _35002 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35762 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35762 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor15 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg1:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 and t / s > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            return 0
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (2 * 0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19165 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19165] = 26
                        mem[_19165 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19239 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19239 + 68] = mem[idx + _19165 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19239 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19239 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20342] = 30
                                mem[_20342 + 32] = 'SafeMath: subtraction overflow'
                                _21522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21522] = 30
                                mem[_21522 + 32] = 'SafeMath: subtraction overflow'
                                _24356 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24356] = 30
                                mem[_24356 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25432 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25432 + 68] = mem[idx + _24356 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25432 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25432 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20341 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20341] = 30
                                    mem[_20341 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20593 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20593 + 68] = mem[idx + _20341 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20593 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20593 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21521 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21521] = 30
                                    mem[_21521 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22062 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22062 + 68] = mem[idx + _21521 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22062 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22062 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24355 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24355] = 30
                                    mem[_24355 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25431 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25431 + 68] = mem[idx + _24355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25431 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25431 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21082] = 30
                                mem[_21082 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21520 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21520 + 68] = mem[idx + _21082 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21520 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21520 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23360 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23360] = 30
                                mem[_23360 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24354 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24354 + 68] = mem[idx + _23360 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24354 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24354 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27485 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27485] = 30
                                mem[_27485 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                                _28827 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28827 + 68] = mem[idx + _27485 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28827 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28827 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21081 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21081] = 30
                                mem[_21081 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21519 + 68] = mem[idx + _21081 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21519 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21519 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23359 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23359] = 30
                                mem[_23359 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24353 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24353 + 68] = mem[idx + _23359 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24353 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24353 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27484] = 30
                                mem[_27484 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28826 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28826 + 68] = mem[idx + _27484 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28826 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28826 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22729 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22729] = 30
                            mem[_22729 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23358 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23358 + 68] = mem[idx + _22729 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23358 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23358 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26251 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26251] = 30
                            mem[_26251 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _27483 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27483 + 68] = mem[idx + _26251 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27483 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27483 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31014 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31014] = 30
                            mem[_31014 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _32244 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32244 + 68] = mem[idx + _31014 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32244 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32244 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20339] = 30
                                mem[_20339 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20592 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20592 + 68] = mem[idx + _20339 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20592 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20592 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21518 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21518] = 30
                                mem[_21518 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22060 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22060 + 68] = mem[idx + _21518 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22060 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22060 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24352 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24352] = 30
                                mem[_24352 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25429 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25429 + 68] = mem[idx + _24352 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25429 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25429 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21079] = 30
                            mem[_21079 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21517 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21517 + 68] = mem[idx + _21079 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21517 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21517 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23356 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23356] = 30
                            mem[_23356 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24351 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24351 + 68] = mem[idx + _23356 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24351 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24351 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27481 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27481] = 30
                            mem[_27481 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28825 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28825 + 68] = mem[idx + _27481 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28825 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28825 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21078 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21078] = 30
                                mem[_21078 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21516 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21516 + 68] = mem[idx + _21078 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21516 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21516 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23355] = 30
                                mem[_23355 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24350 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24350 + 68] = mem[idx + _23355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24350 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24350 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27480 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27480] = 30
                                mem[_27480 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28824 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28824 + 68] = mem[idx + _27480 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28824 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28824 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22726] = 30
                            mem[_22726 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23354 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23354 + 68] = mem[idx + _22726 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23354 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23354 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26248 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26248] = 30
                            mem[_26248 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27479 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27479 + 68] = mem[idx + _26248 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27479 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27479 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31010 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31010] = 30
                            mem[_31010 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _32243 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32243 + 68] = mem[idx + _31010 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32243 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32243 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _22725 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22725] = 30
                            mem[_22725 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23353 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23353 + 68] = mem[idx + _22725 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23353 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23353 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26247 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26247] = 30
                            mem[_26247 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27478 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27478 + 68] = mem[idx + _26247 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27478 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27478 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31009] = 30
                            mem[_31009 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32242 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32242 + 68] = mem[idx + _31009 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32242 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32242 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25426 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25426] = 30
                        mem[_25426 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26246 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26246 + 68] = mem[idx + _25426 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26246 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26246 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29870 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29870] = 30
                        mem[_29870 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31008 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31008 + 68] = mem[idx + _29870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31008 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31008 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34178 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34178] = 30
                        mem[_34178 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _34988 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _34988 + 68] = mem[idx + _34178 + 32]
                            idx = idx + 32
                            continue 
                        mem[_34988 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _34988 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19208 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19208] = 30
                        mem[_19208 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19272 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19272 + 68] = mem[idx + _19208 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19272 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19272 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19597 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19597] = 30
                        mem[_19597 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19679 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19679 + 68] = mem[idx + _19597 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19679 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19679 + -mem[64] + 100
                    _19240 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19240] = 26
                    mem[_19240 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19318 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19318 + 68] = mem[idx + _19240 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19318 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19318 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20598] = 30
                            mem[_20598 + 32] = 'SafeMath: subtraction overflow'
                            _22070 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22070] = 30
                            mem[_22070 + 32] = 'SafeMath: subtraction overflow'
                            _25440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25440] = 30
                            mem[_25440 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26260 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26260 + 68] = mem[idx + _25440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26260 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26260 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20597 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20597] = 30
                                mem[_20597 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20780 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20780 + 68] = mem[idx + _20597 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20780 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20780 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22069 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22069] = 30
                                mem[_22069 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22735 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22735 + 68] = mem[idx + _22069 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22735 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22735 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25439 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25439] = 30
                                mem[_25439 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26259 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26259 + 68] = mem[idx + _25439 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26259 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26259 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21528 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21528] = 30
                            mem[_21528 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22068 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22068 + 68] = mem[idx + _21528 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22068 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22068 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24364 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24364] = 30
                            mem[_24364 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25438 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25438 + 68] = mem[idx + _24364 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25438 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25438 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28835 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28835] = 30
                            mem[_28835 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29878 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29878 + 68] = mem[idx + _28835 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29878 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29878 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21527 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21527] = 30
                            mem[_21527 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22067 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22067 + 68] = mem[idx + _21527 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22067 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22067 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24363 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24363] = 30
                            mem[_24363 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25437 + 68] = mem[idx + _24363 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25437 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25437 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28834 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28834] = 30
                            mem[_28834 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29877 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29877 + 68] = mem[idx + _28834 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29877 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29877 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23366 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23366] = 30
                        mem[_23366 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24362 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24362 + 68] = mem[idx + _23366 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24362 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24362 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27494 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27494] = 30
                        mem[_27494 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _28833 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28833 + 68] = mem[idx + _27494 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28833 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28833 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32251 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32251] = 30
                        mem[_32251 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _33325 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33325 + 68] = mem[idx + _32251 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33325 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33325 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20595] = 30
                            mem[_20595 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20779 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20779 + 68] = mem[idx + _20595 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20779 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20779 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22066 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22066] = 30
                            mem[_22066 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22733 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22733 + 68] = mem[idx + _22066 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22733 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22733 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25436 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25436] = 30
                            mem[_25436 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26257 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26257 + 68] = mem[idx + _25436 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26257 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26257 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21525 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21525] = 30
                        mem[_21525 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22065 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22065 + 68] = mem[idx + _21525 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22065 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22065 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24360 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24360] = 30
                        mem[_24360 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25435 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25435 + 68] = mem[idx + _24360 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25435 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25435 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28831 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28831] = 30
                        mem[_28831 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29876 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29876 + 68] = mem[idx + _28831 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29876 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29876 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21524 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21524] = 30
                            mem[_21524 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22064 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22064 + 68] = mem[idx + _21524 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22064 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22064 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24359 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24359] = 30
                            mem[_24359 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25434 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25434 + 68] = mem[idx + _24359 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25434 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25434 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _28830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28830] = 30
                            mem[_28830 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29875 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29875 + 68] = mem[idx + _28830 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29875 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29875 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23363] = 30
                        mem[_23363 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24358 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24358 + 68] = mem[idx + _23363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24358 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24358 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27491 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27491] = 30
                        mem[_27491 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _28829 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28829 + 68] = mem[idx + _27491 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28829 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28829 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32247 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32247] = 30
                        mem[_32247 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _33324 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33324 + 68] = mem[idx + _32247 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33324 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33324 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23362] = 30
                        mem[_23362 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24357 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24357 + 68] = mem[idx + _23362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24357 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24357 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27490 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27490] = 30
                        mem[_27490 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _28828 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28828 + 68] = mem[idx + _27490 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28828 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28828 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32246 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32246] = 30
                        mem[_32246 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33323 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33323 + 68] = mem[idx + _32246 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33323 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33323 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26254 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26254] = 30
                    mem[_26254 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27489 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27489 + 68] = mem[idx + _26254 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27489 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27489 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31019 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31019] = 30
                    mem[_31019 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32245 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32245 + 68] = mem[idx + _31019 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32245 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32245 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _34989 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34989] = 30
                    mem[_34989 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _35759 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35759 + 68] = mem[idx + _34989 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35759 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35759 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19162 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19162] = 26
                        mem[_19162 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19237 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19237 + 68] = mem[idx + _19162 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19237 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19237 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not 0 / stor13 / 100:
                                        return 0
                                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20333 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20333] = 30
                                    mem[_20333 + 32] = 'SafeMath: subtraction overflow'
                                    _21500 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21500] = 30
                                    mem[_21500 + 32] = 'SafeMath: subtraction overflow'
                                    _24325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24325] = 30
                                    mem[_24325 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25400 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25400 + 68] = mem[idx + _24325 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25400 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25400 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20332 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20332] = 30
                                    mem[_20332 + 32] = 'SafeMath: subtraction overflow'
                                    _21499 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21499] = 30
                                    mem[_21499 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22044 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22044 + 68] = mem[idx + _21499 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22044 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22044 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24324 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24324] = 30
                                    mem[_24324 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                                    _25399 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25399 + 68] = mem[idx + _24324 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25399 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25399 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21065 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21065] = 30
                                mem[_21065 + 32] = 'SafeMath: subtraction overflow'
                                _23328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23328] = 30
                                mem[_23328 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24323 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24323 + 68] = mem[idx + _23328 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24323 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24323 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27447 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27447] = 30
                                mem[_27447 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28793 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28793 + 68] = mem[idx + _27447 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28793 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28793 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20331 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20331] = 30
                                    mem[_20331 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20584 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20584 + 68] = mem[idx + _20331 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20584 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20584 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21498 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21498] = 30
                                    mem[_21498 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22043 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22043 + 68] = mem[idx + _21498 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22043 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22043 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24322 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24322] = 30
                                    mem[_24322 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25398 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25398 + 68] = mem[idx + _24322 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25398 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25398 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21063 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21063] = 30
                                mem[_21063 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21497 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21497 + 68] = mem[idx + _21063 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21497 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21497 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23326] = 30
                                mem[_23326 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24321 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24321 + 68] = mem[idx + _23326 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24321 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24321 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27445 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27445] = 30
                                mem[_27445 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28792 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28792 + 68] = mem[idx + _27445 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28792 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28792 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21062] = 30
                                mem[_21062 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21496 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21496 + 68] = mem[idx + _21062 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21496 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21496 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23325 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23325] = 30
                                mem[_23325 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24320 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24320 + 68] = mem[idx + _23325 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24320 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24320 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27444 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27444] = 30
                                mem[_27444 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                                _28791 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28791 + 68] = mem[idx + _27444 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28791 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28791 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22701 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22701] = 30
                            mem[_22701 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23324 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23324 + 68] = mem[idx + _22701 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23324 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23324 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26215 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26215] = 30
                            mem[_26215 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _27443 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27443 + 68] = mem[idx + _26215 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27443 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27443 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _30974 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30974] = 30
                            mem[_30974 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32216 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32216 + 68] = mem[idx + _30974 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32216 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32216 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20329 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20329] = 30
                                    mem[_20329 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20583 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20583 + 68] = mem[idx + _20329 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20583 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20583 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21495 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21495] = 30
                                    mem[_21495 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22041 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22041 + 68] = mem[idx + _21495 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22041 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22041 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24319] = 30
                                    mem[_24319 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25396 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25396 + 68] = mem[idx + _24319 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25396 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25396 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21060 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21060] = 30
                                mem[_21060 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21494 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21494 + 68] = mem[idx + _21060 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21494 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21494 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23322] = 30
                                mem[_23322 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24318 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24318 + 68] = mem[idx + _23322 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24318 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24318 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27441 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27441] = 30
                                mem[_27441 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28790 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28790 + 68] = mem[idx + _27441 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28790 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28790 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21059 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21059] = 30
                                mem[_21059 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21493 + 68] = mem[idx + _21059 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21493 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21493 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23321] = 30
                                mem[_23321 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24317 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24317 + 68] = mem[idx + _23321 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24317 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24317 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27440 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27440] = 30
                                mem[_27440 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                                _28789 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28789 + 68] = mem[idx + _27440 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28789 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28789 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22698 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22698] = 30
                            mem[_22698 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23320 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23320 + 68] = mem[idx + _22698 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23320 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23320 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26212 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26212] = 30
                            mem[_26212 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27439 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27439 + 68] = mem[idx + _26212 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27439 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27439 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _30970 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30970] = 30
                            mem[_30970 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32215 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32215 + 68] = mem[idx + _30970 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32215 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32215 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _21058 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21058] = 30
                                mem[_21058 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21492 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21492 + 68] = mem[idx + _21058 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21492 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21492 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23319] = 30
                                mem[_23319 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24316 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24316 + 68] = mem[idx + _23319 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24316 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24316 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27438 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27438] = 30
                                mem[_27438 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28788 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28788 + 68] = mem[idx + _27438 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28788 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28788 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22696 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22696] = 30
                            mem[_22696 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23318 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23318 + 68] = mem[idx + _22696 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23318 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23318 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26210 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26210] = 30
                            mem[_26210 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27437 + 68] = mem[idx + _26210 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27437 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27437 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _30968 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30968] = 30
                            mem[_30968 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32214 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32214 + 68] = mem[idx + _30968 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32214 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32214 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22695 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22695] = 30
                            mem[_22695 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23317 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23317 + 68] = mem[idx + _22695 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23317 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23317 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26209 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26209] = 30
                            mem[_26209 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27436 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27436 + 68] = mem[idx + _26209 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27436 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27436 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _30967 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30967] = 30
                            mem[_30967 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _32213 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32213 + 68] = mem[idx + _30967 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32213 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32213 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25392 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25392] = 30
                        mem[_25392 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26208 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26208 + 68] = mem[idx + _25392 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26208 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26208 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29842 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29842] = 30
                        mem[_29842 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _30966 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30966 + 68] = mem[idx + _29842 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30966 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30966 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34144] = 30
                        mem[_34144 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _34970 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _34970 + 68] = mem[idx + _34144 + 32]
                            idx = idx + 32
                            continue 
                        mem[_34970 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _34970 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19206 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19206] = 30
                        mem[_19206 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19270 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19270 + 68] = mem[idx + _19206 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19270 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19270 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19594] = 30
                        mem[_19594 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19676 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19676 + 68] = mem[idx + _19594 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19676 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19676 + -mem[64] + 100
                    _19238 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19238] = 26
                    mem[_19238 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19314 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19314 + 68] = mem[idx + _19238 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19314 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19314 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20591 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20591] = 30
                                mem[_20591 + 32] = 'SafeMath: subtraction overflow'
                                _22054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22054] = 30
                                mem[_22054 + 32] = 'SafeMath: subtraction overflow'
                                _25411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25411] = 30
                                mem[_25411 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26227 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26227 + 68] = mem[idx + _25411 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26227 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26227 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20590 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20590] = 30
                                mem[_20590 + 32] = 'SafeMath: subtraction overflow'
                                _22053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22053] = 30
                                mem[_22053 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22709 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22709 + 68] = mem[idx + _22053 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22709 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22709 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25410 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25410] = 30
                                mem[_25410 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                                _26226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26226 + 68] = mem[idx + _25410 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26226 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26226 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21509] = 30
                            mem[_21509 + 32] = 'SafeMath: subtraction overflow'
                            _24337 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24337] = 30
                            mem[_24337 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25409 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25409 + 68] = mem[idx + _24337 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25409 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25409 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28805 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28805] = 30
                            mem[_28805 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29853 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29853 + 68] = mem[idx + _28805 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29853 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29853 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20589 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20589] = 30
                                mem[_20589 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20773 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20773 + 68] = mem[idx + _20589 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20773 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20773 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22052] = 30
                                mem[_22052 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22708 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22708 + 68] = mem[idx + _22052 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22708 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22708 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25408 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25408] = 30
                                mem[_25408 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26225 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26225 + 68] = mem[idx + _25408 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26225 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26225 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21507 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21507] = 30
                            mem[_21507 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22051 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22051 + 68] = mem[idx + _21507 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22051 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22051 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24335 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24335] = 30
                            mem[_24335 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25407 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25407 + 68] = mem[idx + _24335 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25407 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25407 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28803 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28803] = 30
                            mem[_28803 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29852 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29852 + 68] = mem[idx + _28803 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29852 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29852 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21506 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21506] = 30
                            mem[_21506 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22050 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22050 + 68] = mem[idx + _21506 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22050 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22050 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24334 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24334] = 30
                            mem[_24334 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25406 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25406 + 68] = mem[idx + _24334 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25406 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25406 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28802 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28802] = 30
                            mem[_28802 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29851 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29851 + 68] = mem[idx + _28802 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29851 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29851 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23336 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23336] = 30
                        mem[_23336 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24333 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24333 + 68] = mem[idx + _23336 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24333 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24333 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27458 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27458] = 30
                        mem[_27458 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _28801 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28801 + 68] = mem[idx + _27458 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28801 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28801 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32225 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32225] = 30
                        mem[_32225 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33313 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33313 + 68] = mem[idx + _32225 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33313 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33313 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20587 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20587] = 30
                                mem[_20587 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20772 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20772 + 68] = mem[idx + _20587 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20772 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20772 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22049 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22049] = 30
                                mem[_22049 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22706 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22706 + 68] = mem[idx + _22049 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22706 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22706 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25405 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25405] = 30
                                mem[_25405 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26223 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26223 + 68] = mem[idx + _25405 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26223 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26223 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21504] = 30
                            mem[_21504 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22048 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22048 + 68] = mem[idx + _21504 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22048 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22048 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24331] = 30
                            mem[_24331 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25404 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25404 + 68] = mem[idx + _24331 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25404 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25404 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28799 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28799] = 30
                            mem[_28799 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29850 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29850 + 68] = mem[idx + _28799 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29850 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29850 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21503] = 30
                            mem[_21503 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22047 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22047 + 68] = mem[idx + _21503 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22047 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22047 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24330 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24330] = 30
                            mem[_24330 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25403 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25403 + 68] = mem[idx + _24330 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25403 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25403 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28798] = 30
                            mem[_28798 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _29849 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29849 + 68] = mem[idx + _28798 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29849 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29849 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23333 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23333] = 30
                        mem[_23333 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24329 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24329 + 68] = mem[idx + _23333 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24329 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24329 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27455 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27455] = 30
                        mem[_27455 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _28797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28797 + 68] = mem[idx + _27455 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28797 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28797 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32221 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32221] = 30
                        mem[_32221 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33312 + 68] = mem[idx + _32221 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33312 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33312 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _21502 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21502] = 30
                            mem[_21502 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22046 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22046 + 68] = mem[idx + _21502 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22046 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22046 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24328 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24328] = 30
                            mem[_24328 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25402 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25402 + 68] = mem[idx + _24328 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25402 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25402 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _28796 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28796] = 30
                            mem[_28796 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29848 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29848 + 68] = mem[idx + _28796 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29848 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29848 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23331 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23331] = 30
                        mem[_23331 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24327 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24327 + 68] = mem[idx + _23331 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24327 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24327 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27453 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27453] = 30
                        mem[_27453 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _28795 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28795 + 68] = mem[idx + _27453 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28795 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28795 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32219 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32219] = 30
                        mem[_32219 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33311 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33311 + 68] = mem[idx + _32219 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33311 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33311 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23330 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23330] = 30
                        mem[_23330 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24326 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24326 + 68] = mem[idx + _23330 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24326 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24326 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27452 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27452] = 30
                        mem[_27452 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _28794 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28794 + 68] = mem[idx + _27452 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28794 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28794 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32218 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32218] = 30
                        mem[_32218 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _33310 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33310 + 68] = mem[idx + _32218 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33310 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33310 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26219 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26219] = 30
                    mem[_26219 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27451 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27451 + 68] = mem[idx + _26219 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27451 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27451 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _30981 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30981] = 30
                    mem[_30981 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32217 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32217 + 68] = mem[idx + _30981 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32217 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32217 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _34971 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34971] = 30
                    mem[_34971 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _35756 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35756 + 68] = mem[idx + _34971 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35756 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35756 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                return (arg1 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 and _CHARITY_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if 0 / stor13 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0 / stor13 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (0 / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor15
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _19159 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19159] = 26
                    mem[_19159 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19235 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19235 + 68] = mem[idx + _19159 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19235 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19235 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20320 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20320] = 30
                                mem[_20320 + 32] = 'SafeMath: subtraction overflow'
                                _21476 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21476] = 30
                                mem[_21476 + 32] = 'SafeMath: subtraction overflow'
                                _24287 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24287] = 30
                                mem[_24287 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25362 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25362 + 68] = mem[idx + _24287 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25362 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25362 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20319] = 30
                                mem[_20319 + 32] = 'SafeMath: subtraction overflow'
                                _21475 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21475] = 30
                                mem[_21475 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22022 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22022 + 68] = mem[idx + _21475 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22022 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22022 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24286 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24286] = 30
                                mem[_24286 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25361 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25361 + 68] = mem[idx + _24286 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25361 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25361 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21041] = 30
                            mem[_21041 + 32] = 'SafeMath: subtraction overflow'
                            _23288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23288] = 30
                            mem[_23288 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _24285 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24285 + 68] = mem[idx + _23288 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24285 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24285 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27399 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27399] = 30
                            mem[_27399 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28753 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28753 + 68] = mem[idx + _27399 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28753 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28753 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20318 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20318] = 30
                                mem[_20318 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20575 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20575 + 68] = mem[idx + _20318 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20575 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20575 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21474 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21474] = 30
                                mem[_21474 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22021 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22021 + 68] = mem[idx + _21474 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22021 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22021 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24284] = 30
                                mem[_24284 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _25360 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25360 + 68] = mem[idx + _24284 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25360 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25360 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21039] = 30
                            mem[_21039 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _21473 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21473 + 68] = mem[idx + _21039 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21473 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21473 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23286 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23286] = 30
                            mem[_23286 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _24283 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24283 + 68] = mem[idx + _23286 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24283 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24283 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27397 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27397] = 30
                            mem[_27397 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28752 + 68] = mem[idx + _27397 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28752 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28752 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21038 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21038] = 30
                            mem[_21038 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _21472 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21472 + 68] = mem[idx + _21038 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21472 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21472 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23285 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23285] = 30
                            mem[_23285 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _24282 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24282 + 68] = mem[idx + _23285 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24282 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24282 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27396 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27396] = 30
                            mem[_27396 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28751 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28751 + 68] = mem[idx + _27396 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28751 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28751 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22667 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22667] = 30
                        mem[_22667 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _23284 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23284 + 68] = mem[idx + _22667 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23284 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23284 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26169 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26169] = 30
                        mem[_26169 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _27395 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27395 + 68] = mem[idx + _26169 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27395 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27395 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30924 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30924] = 30
                        mem[_30924 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32183 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32183 + 68] = mem[idx + _30924 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32183 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32183 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20316 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20316] = 30
                                mem[_20316 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20574 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20574 + 68] = mem[idx + _20316 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20574 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20574 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21471] = 30
                                mem[_21471 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22019 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22019 + 68] = mem[idx + _21471 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22019 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22019 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24281 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24281] = 30
                                mem[_24281 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25358 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25358 + 68] = mem[idx + _24281 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25358 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25358 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21036 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21036] = 30
                            mem[_21036 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21470 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21470 + 68] = mem[idx + _21036 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21470 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21470 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23282 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23282] = 30
                            mem[_23282 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24280 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24280 + 68] = mem[idx + _23282 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24280 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24280 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27393 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27393] = 30
                            mem[_27393 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28750 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28750 + 68] = mem[idx + _27393 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28750 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28750 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21035 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21035] = 30
                            mem[_21035 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21469 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21469 + 68] = mem[idx + _21035 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21469 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21469 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23281 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23281] = 30
                            mem[_23281 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _24279 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24279 + 68] = mem[idx + _23281 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24279 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24279 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27392] = 30
                            mem[_27392 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28749 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28749 + 68] = mem[idx + _27392 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28749 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28749 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22664 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22664] = 30
                        mem[_22664 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _23280 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23280 + 68] = mem[idx + _22664 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23280 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23280 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _26166 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26166] = 30
                        mem[_26166 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27391 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27391 + 68] = mem[idx + _26166 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27391 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27391 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30920 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30920] = 30
                        mem[_30920 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32182 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32182 + 68] = mem[idx + _30920 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32182 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32182 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21034 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21034] = 30
                            mem[_21034 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21468 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21468 + 68] = mem[idx + _21034 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21468 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21468 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23279 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23279] = 30
                            mem[_23279 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _24278 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24278 + 68] = mem[idx + _23279 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24278 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24278 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27390 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27390] = 30
                            mem[_27390 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _28748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28748 + 68] = mem[idx + _27390 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28748 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28748 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22662 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22662] = 30
                        mem[_22662 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23278 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23278 + 68] = mem[idx + _22662 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23278 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23278 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26164 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26164] = 30
                        mem[_26164 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _27389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27389 + 68] = mem[idx + _26164 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27389 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27389 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _30918 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30918] = 30
                        mem[_30918 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32181 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32181 + 68] = mem[idx + _30918 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32181 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32181 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _22661 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22661] = 30
                        mem[_22661 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23277 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23277 + 68] = mem[idx + _22661 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23277 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23277 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26163 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26163] = 30
                        mem[_26163 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _27388 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27388 + 68] = mem[idx + _26163 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27388 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27388 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30917 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30917] = 30
                        mem[_30917 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32180 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32180 + 68] = mem[idx + _30917 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32180 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32180 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25354 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25354] = 30
                    mem[_25354 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _26162 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26162 + 68] = mem[idx + _25354 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26162 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26162 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _29808 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29808] = 30
                    mem[_29808 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _30916 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30916 + 68] = mem[idx + _29808 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30916 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30916 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _34102 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34102] = 30
                    mem[_34102 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _34950 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _34950 + 68] = mem[idx + _34102 + 32]
                        idx = idx + 32
                        continue 
                    mem[_34950 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _34950 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _19204 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19204] = 30
                    mem[_19204 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _19268 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19268 + 68] = mem[idx + _19204 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19268 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19268 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _19591 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19591] = 30
                    mem[_19591 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _19673 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19673 + 68] = mem[idx + _19591 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19673 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19673 + -mem[64] + 100
                _19236 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19236] = 26
                mem[_19236 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19310 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19310 + 68] = mem[idx + _19236 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19310 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19310 + -mem[64] + 100
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20582 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20582] = 30
                            mem[_20582 + 32] = 'SafeMath: subtraction overflow'
                            _22032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22032] = 30
                            mem[_22032 + 32] = 'SafeMath: subtraction overflow'
                            _25373 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25373] = 30
                            mem[_25373 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26181 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26181 + 68] = mem[idx + _25373 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26181 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26181 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20581 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20581] = 30
                            mem[_20581 + 32] = 'SafeMath: subtraction overflow'
                            _22031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22031] = 30
                            mem[_22031 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22675 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22675 + 68] = mem[idx + _22031 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22675 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22675 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _25372 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25372] = 30
                            mem[_25372 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26180 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26180 + 68] = mem[idx + _25372 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26180 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26180 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21485 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21485] = 30
                        mem[_21485 + 32] = 'SafeMath: subtraction overflow'
                        _24299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24299] = 30
                        mem[_24299 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _25371 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25371 + 68] = mem[idx + _24299 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25371 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25371 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28765 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28765] = 30
                        mem[_28765 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29819 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29819 + 68] = mem[idx + _28765 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29819 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29819 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20580 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20580] = 30
                            mem[_20580 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _20765 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20765 + 68] = mem[idx + _20580 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20765 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20765 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22030 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22030] = 30
                            mem[_22030 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _22674 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22674 + 68] = mem[idx + _22030 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22674 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22674 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25370 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25370] = 30
                            mem[_25370 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                            _26179 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26179 + 68] = mem[idx + _25370 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26179 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26179 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21483 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21483] = 30
                        mem[_21483 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _22029 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22029 + 68] = mem[idx + _21483 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22029 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22029 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24297 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24297] = 30
                        mem[_24297 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _25369 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25369 + 68] = mem[idx + _24297 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25369 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25369 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28763 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28763] = 30
                        mem[_28763 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29818 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29818 + 68] = mem[idx + _28763 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29818 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29818 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21482 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21482] = 30
                        mem[_21482 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _22028 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22028 + 68] = mem[idx + _21482 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22028 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22028 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24296 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24296] = 30
                        mem[_24296 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _25368 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25368 + 68] = mem[idx + _24296 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25368 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25368 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28762 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28762] = 30
                        mem[_28762 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29817 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29817 + 68] = mem[idx + _28762 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29817 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29817 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23296 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23296] = 30
                    mem[_23296 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        _24295 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24295 + 68] = mem[idx + _23296 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24295 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24295 + -mem[64] + 100
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27410 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27410] = 30
                    mem[_27410 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        _28761 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28761 + 68] = mem[idx + _27410 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28761 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28761 + -mem[64] + 100
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32192 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32192] = 30
                    mem[_32192 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33298 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33298 + 68] = mem[idx + _32192 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33298 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33298 + -mem[64] + 100
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20578 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20578] = 30
                            mem[_20578 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20764 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20764 + 68] = mem[idx + _20578 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20764 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20764 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22027 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22027] = 30
                            mem[_22027 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22672 + 68] = mem[idx + _22027 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22672 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22672 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25367 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25367] = 30
                            mem[_25367 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26177 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26177 + 68] = mem[idx + _25367 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26177 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26177 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21480 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21480] = 30
                        mem[_21480 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22026 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22026 + 68] = mem[idx + _21480 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22026 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22026 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24293 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24293] = 30
                        mem[_24293 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25366 + 68] = mem[idx + _24293 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25366 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25366 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28759 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28759] = 30
                        mem[_28759 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29816 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29816 + 68] = mem[idx + _28759 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29816 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29816 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21479 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21479] = 30
                        mem[_21479 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22025 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22025 + 68] = mem[idx + _21479 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22025 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22025 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24292 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24292] = 30
                        mem[_24292 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _25365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25365 + 68] = mem[idx + _24292 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25365 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25365 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28758 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28758] = 30
                        mem[_28758 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29815 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29815 + 68] = mem[idx + _28758 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29815 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29815 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23293 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23293] = 30
                    mem[_23293 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _24291 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24291 + 68] = mem[idx + _23293 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24291 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24291 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _27407 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27407] = 30
                    mem[_27407 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28757 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28757 + 68] = mem[idx + _27407 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28757 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28757 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32188 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32188] = 30
                    mem[_32188 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33297 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33297 + 68] = mem[idx + _32188 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33297 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33297 + -mem[64] + 100
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21478 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21478] = 30
                        mem[_21478 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22024 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22024 + 68] = mem[idx + _21478 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22024 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22024 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24290 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24290] = 30
                        mem[_24290 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _25364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25364 + 68] = mem[idx + _24290 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25364 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25364 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _28756 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28756] = 30
                        mem[_28756 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _29814 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29814 + 68] = mem[idx + _28756 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29814 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29814 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23291 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23291] = 30
                    mem[_23291 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24289 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24289 + 68] = mem[idx + _23291 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24289 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24289 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27405 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27405] = 30
                    mem[_27405 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _28755 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28755 + 68] = mem[idx + _27405 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28755 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28755 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _32186 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32186] = 30
                    mem[_32186 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33296 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33296 + 68] = mem[idx + _32186 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33296 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33296 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _23290 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23290] = 30
                    mem[_23290 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24288 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24288 + 68] = mem[idx + _23290 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24288 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24288 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27404 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27404] = 30
                    mem[_27404 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _28754 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28754 + 68] = mem[idx + _27404 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28754 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28754 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32185 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32185] = 30
                    mem[_32185 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33295 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33295 + 68] = mem[idx + _32185 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33295 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33295 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26173 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26173] = 30
                mem[_26173 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _27403 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27403 + 68] = mem[idx + _26173 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27403 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27403 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _30931 = mem[64]
                mem[64] = mem[64] + 64
                mem[_30931] = 30
                mem[_30931 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    _32184 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32184 + 68] = mem[idx + _30931 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32184 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32184 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _34951 = mem[64]
                mem[64] = mem[64] + 64
                mem[_34951] = 30
                mem[_34951 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _35753 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35753 + 68] = mem[idx + _34951 + 32]
                    idx = idx + 32
                    continue 
                mem[_35753 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35753 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor15 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * t / s)
                        if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 and stor15 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                revert with 0, 17
            if not 0 / stor13 / 100:
                revert with 0, 18
            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 and _TAX_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _TAX_FEE / arg1 != _TAX_FEE:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19156 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19156] = 26
                        mem[_19156 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19233 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19233 + 68] = mem[idx + _19156 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19233 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19233 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20308] = 30
                                    mem[_20308 + 32] = 'SafeMath: subtraction overflow'
                                    _21454 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21454] = 30
                                    mem[_21454 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22003 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22003 + 68] = mem[idx + _21454 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22003 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22003 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24252 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24252] = 30
                                    mem[_24252 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                    _25327 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25327 + 68] = mem[idx + _24252 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25327 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25327 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21019 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21019] = 30
                                mem[_21019 + 32] = 'SafeMath: subtraction overflow'
                                _23251 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23251] = 30
                                mem[_23251 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24251 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24251 + 68] = mem[idx + _23251 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24251 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24251 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27355] = 30
                                mem[_27355 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28717 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28717 + 68] = mem[idx + _27355 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28717 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28717 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20307] = 30
                                mem[_20307 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20567 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20567 + 68] = mem[idx + _20307 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20567 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20567 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21453] = 30
                                mem[_21453 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22002 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22002 + 68] = mem[idx + _21453 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22002 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22002 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24250] = 30
                                mem[_24250 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25326 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25326 + 68] = mem[idx + _24250 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25326 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25326 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21017 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21017] = 30
                                mem[_21017 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21452 + 68] = mem[idx + _21017 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21452 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21452 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23249 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23249] = 30
                                mem[_23249 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24249 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24249 + 68] = mem[idx + _23249 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24249 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24249 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27353 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27353] = 30
                                mem[_27353 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28716 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28716 + 68] = mem[idx + _27353 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28716 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28716 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22635] = 30
                            mem[_22635 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23248 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23248 + 68] = mem[idx + _22635 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23248 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23248 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26126 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26126] = 30
                            mem[_26126 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _27352 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27352 + 68] = mem[idx + _26126 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27352 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27352 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _30877 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30877] = 30
                            mem[_30877 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32154 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32154 + 68] = mem[idx + _30877 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32154 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32154 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20305] = 30
                                mem[_20305 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20566 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20566 + 68] = mem[idx + _20305 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20566 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20566 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21451 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21451] = 30
                                mem[_21451 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22000 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22000 + 68] = mem[idx + _21451 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22000 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22000 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24248 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24248] = 30
                                mem[_24248 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25324 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25324 + 68] = mem[idx + _24248 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25324 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25324 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21015 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21015] = 30
                                mem[_21015 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21450 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21450 + 68] = mem[idx + _21015 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21450 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21450 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23246 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23246] = 30
                                mem[_23246 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24247 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24247 + 68] = mem[idx + _23246 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24247 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24247 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27350 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27350] = 30
                                mem[_27350 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                                _28715 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28715 + 68] = mem[idx + _27350 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28715 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28715 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22633 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22633] = 30
                            mem[_22633 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23245 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23245 + 68] = mem[idx + _22633 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23245 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23245 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26124 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26124] = 30
                            mem[_26124 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27349 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27349 + 68] = mem[idx + _26124 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27349 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27349 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _30874 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30874] = 30
                            mem[_30874 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32153 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32153 + 68] = mem[idx + _30874 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32153 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32153 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21014 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21014] = 30
                            mem[_21014 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21449 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21449 + 68] = mem[idx + _21014 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21449 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21449 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23244 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23244] = 30
                            mem[_23244 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _24246 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24246 + 68] = mem[idx + _23244 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24246 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24246 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27348 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27348] = 30
                            mem[_27348 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28714 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28714 + 68] = mem[idx + _27348 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28714 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28714 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22631 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22631] = 30
                            mem[_22631 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23243 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23243 + 68] = mem[idx + _22631 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23243 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23243 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26122 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26122] = 30
                            mem[_26122 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27347 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27347 + 68] = mem[idx + _26122 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27347 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27347 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _30872 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_30872] = 30
                            mem[_30872 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _32152 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32152 + 68] = mem[idx + _30872 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32152 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32152 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25321 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25321] = 30
                        mem[_25321 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26121 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26121 + 68] = mem[idx + _25321 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26121 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26121 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29777 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29777] = 30
                        mem[_29777 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _30871 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30871 + 68] = mem[idx + _29777 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30871 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30871 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34063 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34063] = 30
                        mem[_34063 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _34933 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _34933 + 68] = mem[idx + _34063 + 32]
                            idx = idx + 32
                            continue 
                        mem[_34933 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _34933 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19202 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19202] = 30
                        mem[_19202 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19266 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19266 + 68] = mem[idx + _19202 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19266 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19266 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19588 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19588] = 30
                        mem[_19588 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19670 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19670 + 68] = mem[idx + _19588 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19670 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19670 + -mem[64] + 100
                    _19234 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19234] = 26
                    mem[_19234 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19306 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19306 + 68] = mem[idx + _19234 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19306 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19306 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20573 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20573] = 30
                                mem[_20573 + 32] = 'SafeMath: subtraction overflow'
                                _22010 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22010] = 30
                                mem[_22010 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22641 + 68] = mem[idx + _22010 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22641 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22641 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25335] = 30
                                mem[_25335 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _26135 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26135 + 68] = mem[idx + _25335 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26135 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26135 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21461 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21461] = 30
                            mem[_21461 + 32] = 'SafeMath: subtraction overflow'
                            _24261 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24261] = 30
                            mem[_24261 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _25334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25334 + 68] = mem[idx + _24261 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25334 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28726] = 30
                            mem[_28726 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29785 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29785 + 68] = mem[idx + _28726 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29785 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29785 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20572 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20572] = 30
                            mem[_20572 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20757 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20757 + 68] = mem[idx + _20572 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20757 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20757 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22009] = 30
                            mem[_22009 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22640 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22640 + 68] = mem[idx + _22009 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22640 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22640 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25333 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25333] = 30
                            mem[_25333 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26134 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26134 + 68] = mem[idx + _25333 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26134 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26134 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21459 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21459] = 30
                            mem[_21459 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22008 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22008 + 68] = mem[idx + _21459 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22008 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22008 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24259 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24259] = 30
                            mem[_24259 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25332 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25332 + 68] = mem[idx + _24259 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25332 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25332 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28724 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28724] = 30
                            mem[_28724 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29784 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29784 + 68] = mem[idx + _28724 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29784 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29784 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23257 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23257] = 30
                        mem[_23257 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24258 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24258 + 68] = mem[idx + _23257 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24258 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24258 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27363] = 30
                        mem[_27363 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _28723 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28723 + 68] = mem[idx + _27363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28723 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28723 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32161 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32161] = 30
                        mem[_32161 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33283 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33283 + 68] = mem[idx + _32161 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33283 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33283 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20570 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20570] = 30
                            mem[_20570 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20756 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20756 + 68] = mem[idx + _20570 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20756 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20756 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22007 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22007] = 30
                            mem[_22007 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22638 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22638 + 68] = mem[idx + _22007 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22638 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22638 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25331] = 30
                            mem[_25331 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26132 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26132 + 68] = mem[idx + _25331 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26132 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26132 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21457 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21457] = 30
                            mem[_21457 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22006 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22006 + 68] = mem[idx + _21457 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22006 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22006 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24256 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24256] = 30
                            mem[_24256 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25330 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25330 + 68] = mem[idx + _24256 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25330 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25330 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28721 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28721] = 30
                            mem[_28721 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _29783 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29783 + 68] = mem[idx + _28721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29783 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29783 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23255 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23255] = 30
                        mem[_23255 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24255 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24255 + 68] = mem[idx + _23255 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24255 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24255 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27361] = 30
                        mem[_27361 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _28720 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28720 + 68] = mem[idx + _27361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28720 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28720 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32158 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32158] = 30
                        mem[_32158 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33282 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33282 + 68] = mem[idx + _32158 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33282 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33282 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21456 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21456] = 30
                        mem[_21456 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22005 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22005 + 68] = mem[idx + _21456 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22005 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22005 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24254 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24254] = 30
                        mem[_24254 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _25329 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25329 + 68] = mem[idx + _24254 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25329 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25329 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _28719 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28719] = 30
                        mem[_28719 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29782 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29782 + 68] = mem[idx + _28719 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29782 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29782 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23253 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23253] = 30
                        mem[_23253 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24253 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24253 + 68] = mem[idx + _23253 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24253 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24253 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27359] = 30
                        mem[_27359 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _28718 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28718 + 68] = mem[idx + _27359 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28718 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28718 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32156 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32156] = 30
                        mem[_32156 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _33281 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33281 + 68] = mem[idx + _32156 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33281 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33281 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26129 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26129] = 30
                    mem[_26129 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27358 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27358 + 68] = mem[idx + _26129 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27358 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27358 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _30882 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30882] = 30
                    mem[_30882 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32155 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32155 + 68] = mem[idx + _30882 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32155 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32155 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _34934 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34934] = 30
                    mem[_34934 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _35750 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35750 + 68] = mem[idx + _34934 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35750 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35750 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * t / s)
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            return 0
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 and _CHARITY_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < 0 / stor13 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor15
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _19153 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19153] = 26
                    mem[_19153 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19231 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19231 + 68] = mem[idx + _19153 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19231 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19231 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20296 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20296] = 30
                                mem[_20296 + 32] = 'SafeMath: subtraction overflow'
                                _21433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21433] = 30
                                mem[_21433 + 32] = 'SafeMath: subtraction overflow'
                                _24219 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24219] = 30
                                mem[_24219 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25297 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25297 + 68] = mem[idx + _24219 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25297 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25297 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20295] = 30
                                mem[_20295 + 32] = 'SafeMath: subtraction overflow'
                                _21432 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21432] = 30
                                mem[_21432 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21986 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21986 + 68] = mem[idx + _21432 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21986 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21986 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24218 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24218] = 30
                                mem[_24218 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _25296 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25296 + 68] = mem[idx + _24218 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25296 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25296 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20999 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20999] = 30
                            mem[_20999 + 32] = 'SafeMath: subtraction overflow'
                            _23220 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23220] = 30
                            mem[_23220 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _24217 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24217 + 68] = mem[idx + _23220 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24217 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24217 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27316 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27316] = 30
                            mem[_27316 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28683 + 68] = mem[idx + _27316 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28683 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28683 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20294 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20294] = 30
                                mem[_20294 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20558 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20558 + 68] = mem[idx + _20294 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20558 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20558 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21431] = 30
                                mem[_21431 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _21985 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21985 + 68] = mem[idx + _21431 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21985 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21985 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24216 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24216] = 30
                                mem[_24216 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25295 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25295 + 68] = mem[idx + _24216 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25295 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25295 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20997 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20997] = 30
                            mem[_20997 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21430 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21430 + 68] = mem[idx + _20997 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21430 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21430 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23218] = 30
                            mem[_23218 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _24215 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24215 + 68] = mem[idx + _23218 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24215 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24215 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27314 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27314] = 30
                            mem[_27314 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28682 + 68] = mem[idx + _27314 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28682 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20996 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20996] = 30
                            mem[_20996 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21429 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21429 + 68] = mem[idx + _20996 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21429 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21429 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23217 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23217] = 30
                            mem[_23217 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _24214 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24214 + 68] = mem[idx + _23217 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24214 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24214 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27313] = 30
                            mem[_27313 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _28681 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28681 + 68] = mem[idx + _27313 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28681 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28681 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22607] = 30
                        mem[_22607 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _23216 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23216 + 68] = mem[idx + _22607 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23216 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23216 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26088] = 30
                        mem[_26088 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _27312 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27312 + 68] = mem[idx + _26088 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27312 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27312 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30837 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30837] = 30
                        mem[_30837 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32126 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32126 + 68] = mem[idx + _30837 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32126 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32126 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20292 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20292] = 30
                                mem[_20292 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20557 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20557 + 68] = mem[idx + _20292 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20557 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20557 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21428 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21428] = 30
                                mem[_21428 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21983 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21983 + 68] = mem[idx + _21428 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21983 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21983 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24213 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24213] = 30
                                mem[_24213 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25293 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25293 + 68] = mem[idx + _24213 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25293 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25293 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20994 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20994] = 30
                            mem[_20994 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21427 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21427 + 68] = mem[idx + _20994 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21427 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21427 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23214 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23214] = 30
                            mem[_23214 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24212 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24212 + 68] = mem[idx + _23214 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24212 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24212 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27310 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27310] = 30
                            mem[_27310 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28680 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28680 + 68] = mem[idx + _27310 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28680 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28680 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20993 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20993] = 30
                            mem[_20993 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21426 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21426 + 68] = mem[idx + _20993 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21426 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21426 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23213 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23213] = 30
                            mem[_23213 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _24211 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24211 + 68] = mem[idx + _23213 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24211 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24211 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27309 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27309] = 30
                            mem[_27309 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _28679 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28679 + 68] = mem[idx + _27309 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28679 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28679 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22604 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22604] = 30
                        mem[_22604 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _23212 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23212 + 68] = mem[idx + _22604 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23212 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23212 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _26085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26085] = 30
                        mem[_26085 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27308 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27308 + 68] = mem[idx + _26085 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27308 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27308 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30833 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30833] = 30
                        mem[_30833 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32125 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32125 + 68] = mem[idx + _30833 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32125 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32125 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20992 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20992] = 30
                            mem[_20992 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21425 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21425 + 68] = mem[idx + _20992 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21425 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21425 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23211] = 30
                            mem[_23211 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _24210 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24210 + 68] = mem[idx + _23211 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24210 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24210 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27307 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27307] = 30
                            mem[_27307 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28678 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28678 + 68] = mem[idx + _27307 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28678 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28678 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22602 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22602] = 30
                        mem[_22602 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23210 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23210 + 68] = mem[idx + _22602 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23210 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23210 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26083] = 30
                        mem[_26083 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _27306 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27306 + 68] = mem[idx + _26083 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27306 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27306 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _30831 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30831] = 30
                        mem[_30831 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32124 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32124 + 68] = mem[idx + _30831 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32124 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32124 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _22601 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22601] = 30
                        mem[_22601 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23209 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23209 + 68] = mem[idx + _22601 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23209 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23209 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26082 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26082] = 30
                        mem[_26082 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _27305 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27305 + 68] = mem[idx + _26082 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27305 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27305 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30830 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30830] = 30
                        mem[_30830 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _32123 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32123 + 68] = mem[idx + _30830 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32123 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32123 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25289] = 30
                    mem[_25289 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _26081 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26081 + 68] = mem[idx + _25289 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26081 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26081 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _29749 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29749] = 30
                    mem[_29749 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _30829 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30829 + 68] = mem[idx + _29749 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30829 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30829 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _34029 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_34029] = 30
                    mem[_34029 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _34915 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _34915 + 68] = mem[idx + _34029 + 32]
                        idx = idx + 32
                        continue 
                    mem[_34915 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _34915 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _19200 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19200] = 30
                    mem[_19200 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _19264 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19264 + 68] = mem[idx + _19200 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19264 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19264 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _19585 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19585] = 30
                    mem[_19585 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _19667 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19667 + 68] = mem[idx + _19585 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19667 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19667 + -mem[64] + 100
                _19232 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19232] = 26
                mem[_19232 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19302 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19302 + 68] = mem[idx + _19232 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19302 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19302 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20565] = 30
                            mem[_20565 + 32] = 'SafeMath: subtraction overflow'
                            _21996 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21996] = 30
                            mem[_21996 + 32] = 'SafeMath: subtraction overflow'
                            _25308 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25308] = 30
                            mem[_25308 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26100 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26100 + 68] = mem[idx + _25308 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26100 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26100 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20564 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20564] = 30
                            mem[_20564 + 32] = 'SafeMath: subtraction overflow'
                            _21995 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21995] = 30
                            mem[_21995 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22615 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22615 + 68] = mem[idx + _21995 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22615 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22615 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _25307 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25307] = 30
                            mem[_25307 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                            _26099 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26099 + 68] = mem[idx + _25307 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26099 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26099 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21442 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21442] = 30
                        mem[_21442 + 32] = 'SafeMath: subtraction overflow'
                        _24231 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24231] = 30
                        mem[_24231 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _25306 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25306 + 68] = mem[idx + _24231 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25306 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25306 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28695 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28695] = 30
                        mem[_28695 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29760 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29760 + 68] = mem[idx + _28695 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29760 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29760 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20563] = 30
                            mem[_20563 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20753 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20753 + 68] = mem[idx + _20563 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20753 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20753 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _21994 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21994] = 30
                            mem[_21994 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22614 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22614 + 68] = mem[idx + _21994 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22614 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22614 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25305 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25305] = 30
                            mem[_25305 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26098 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26098 + 68] = mem[idx + _25305 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26098 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26098 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21440 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21440] = 30
                        mem[_21440 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _21993 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21993 + 68] = mem[idx + _21440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21993 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21993 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24229 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24229] = 30
                        mem[_24229 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _25304 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25304 + 68] = mem[idx + _24229 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25304 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25304 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28693 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28693] = 30
                        mem[_28693 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29759 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29759 + 68] = mem[idx + _28693 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29759 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29759 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21439 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21439] = 30
                        mem[_21439 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _21992 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21992 + 68] = mem[idx + _21439 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21992 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21992 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24228 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24228] = 30
                        mem[_24228 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _25303 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25303 + 68] = mem[idx + _24228 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25303 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25303 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28692 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28692] = 30
                        mem[_28692 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _29758 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29758 + 68] = mem[idx + _28692 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29758 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29758 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23228 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23228] = 30
                    mem[_23228 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _24227 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24227 + 68] = mem[idx + _23228 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24227 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24227 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27327 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27327] = 30
                    mem[_27327 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _28691 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28691 + 68] = mem[idx + _27327 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28691 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28691 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32135 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32135] = 30
                    mem[_32135 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33271 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33271 + 68] = mem[idx + _32135 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33271 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33271 + -mem[64] + 100
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20561 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20561] = 30
                            mem[_20561 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20752 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20752 + 68] = mem[idx + _20561 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20752 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20752 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _21991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21991] = 30
                            mem[_21991 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22612 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22612 + 68] = mem[idx + _21991 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22612 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22612 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25302 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25302] = 30
                            mem[_25302 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26096 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26096 + 68] = mem[idx + _25302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26096 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26096 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21437 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21437] = 30
                        mem[_21437 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _21990 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21990 + 68] = mem[idx + _21437 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21990 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21990 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24225 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24225] = 30
                        mem[_24225 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25301 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25301 + 68] = mem[idx + _24225 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25301 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25301 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28689 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28689] = 30
                        mem[_28689 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29757 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29757 + 68] = mem[idx + _28689 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29757 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29757 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21436] = 30
                        mem[_21436 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _21989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21989 + 68] = mem[idx + _21436 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21989 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21989 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24224] = 30
                        mem[_24224 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _25300 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25300 + 68] = mem[idx + _24224 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25300 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25300 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28688 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28688] = 30
                        mem[_28688 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _29756 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29756 + 68] = mem[idx + _28688 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29756 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29756 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23225 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23225] = 30
                    mem[_23225 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _24223 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24223 + 68] = mem[idx + _23225 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24223 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24223 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _27324 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27324] = 30
                    mem[_27324 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28687 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28687 + 68] = mem[idx + _27324 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28687 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28687 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32131 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32131] = 30
                    mem[_32131 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33270 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33270 + 68] = mem[idx + _32131 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33270 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33270 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _21435 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21435] = 30
                        mem[_21435 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _21988 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21988 + 68] = mem[idx + _21435 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21988 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21988 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24222] = 30
                        mem[_24222 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _25299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25299 + 68] = mem[idx + _24222 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25299 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25299 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _28686 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28686] = 30
                        mem[_28686 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29755 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29755 + 68] = mem[idx + _28686 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29755 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29755 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23223 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23223] = 30
                    mem[_23223 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24221 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24221 + 68] = mem[idx + _23223 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24221 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24221 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27322 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27322] = 30
                    mem[_27322 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _28685 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28685 + 68] = mem[idx + _27322 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28685 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28685 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _32129 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32129] = 30
                    mem[_32129 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33269 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33269 + 68] = mem[idx + _32129 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33269 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33269 + -mem[64] + 100
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _23222 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23222] = 30
                    mem[_23222 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24220 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24220 + 68] = mem[idx + _23222 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24220 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24220 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27321 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27321] = 30
                    mem[_27321 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _28684 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28684 + 68] = mem[idx + _27321 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28684 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28684 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32128 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32128] = 30
                    mem[_32128 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _33268 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33268 + 68] = mem[idx + _32128 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33268 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33268 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26092 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26092] = 30
                mem[_26092 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _27320 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27320 + 68] = mem[idx + _26092 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27320 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27320 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _30844 = mem[64]
                mem[64] = mem[64] + 64
                mem[_30844] = 30
                mem[_30844 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _32127 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32127 + 68] = mem[idx + _30844 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32127 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32127 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _34916 = mem[64]
                mem[64] = mem[64] + 64
                mem[_34916] = 30
                mem[_34916 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _35747 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35747 + 68] = mem[idx + _34916 + 32]
                    idx = idx + 32
                    continue 
                mem[_35747 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35747 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor15 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * 0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s))
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 and stor15 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                revert with 0, 17
            if not 0 / stor13 / 100:
                revert with 0, 18
            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 and _BURN_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[288] = 26
        mem[320] = 'SafeMath: division by zero'
        if not arg1:
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[416] = 26
            mem[448] = 'SafeMath: division by zero'
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            mem[544] = 30
            mem[576] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            mem[64] = 672
            mem[608] = 30
            mem[640] = 'SafeMath: subtraction overflow'
            if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < 0 / stor13 / 100:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor15
            while idx < stor6.length:
                mem[0] = stor6[idx]
                mem[32] = 1
                if stor1[stor6[idx]] > t:
                    _19150 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19150] = 26
                    mem[_19150 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19229 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19229 + 68] = mem[idx + _19150 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19229 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19229 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20283] = 30
                                mem[_20283 + 32] = 'SafeMath: subtraction overflow'
                                _21409 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21409] = 30
                                mem[_21409 + 32] = 'SafeMath: subtraction overflow'
                                _24181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24181] = 30
                                mem[_24181 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                                _25259 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25259 + 68] = mem[idx + _24181 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25259 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25259 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20282] = 30
                                mem[_20282 + 32] = 'SafeMath: subtraction overflow'
                                _21408 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21408] = 30
                                mem[_21408 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21964 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21964 + 68] = mem[idx + _21408 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21964 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21964 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _24180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24180] = 30
                                mem[_24180 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25258 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25258 + 68] = mem[idx + _24180 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25258 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25258 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20975 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20975] = 30
                            mem[_20975 + 32] = 'SafeMath: subtraction overflow'
                            _23180 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23180] = 30
                            mem[_23180 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _24179 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24179 + 68] = mem[idx + _23180 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24179 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24179 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27268 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27268] = 30
                            mem[_27268 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _28643 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28643 + 68] = mem[idx + _27268 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28643 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28643 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20281 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20281] = 30
                                mem[_20281 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20549 + 68] = mem[idx + _20281 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20549 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20549 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21407] = 30
                                mem[_21407 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _21963 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21963 + 68] = mem[idx + _21407 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21963 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21963 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24178] = 30
                                mem[_24178 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                                _25257 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25257 + 68] = mem[idx + _24178 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25257 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25257 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20973 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20973] = 30
                            mem[_20973 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21406 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21406 + 68] = mem[idx + _20973 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21406 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21406 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23178 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23178] = 30
                            mem[_23178 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _24177 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24177 + 68] = mem[idx + _23178 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24177 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24177 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27266 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27266] = 30
                            mem[_27266 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _28642 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28642 + 68] = mem[idx + _27266 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28642 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28642 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20972 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20972] = 30
                            mem[_20972 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21405 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21405 + 68] = mem[idx + _20972 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21405 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21405 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23177 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23177] = 30
                            mem[_23177 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _24176 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24176 + 68] = mem[idx + _23177 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24176 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24176 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27265 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27265] = 30
                            mem[_27265 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28641 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28641 + 68] = mem[idx + _27265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28641 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28641 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22573 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22573] = 30
                        mem[_22573 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _23176 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23176 + 68] = mem[idx + _22573 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23176 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23176 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26042 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26042] = 30
                        mem[_26042 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _27264 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27264 + 68] = mem[idx + _26042 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27264 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27264 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30787 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30787] = 30
                        mem[_30787 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _32093 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32093 + 68] = mem[idx + _30787 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32093 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32093 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20279 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20279] = 30
                                mem[_20279 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20548 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20548 + 68] = mem[idx + _20279 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20548 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20548 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21404] = 30
                                mem[_21404 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21961 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21961 + 68] = mem[idx + _21404 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21961 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21961 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24175 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24175] = 30
                                mem[_24175 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25255 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25255 + 68] = mem[idx + _24175 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25255 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25255 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20970 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20970] = 30
                            mem[_20970 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21403 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21403 + 68] = mem[idx + _20970 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21403 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21403 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23174 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23174] = 30
                            mem[_23174 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24174 + 68] = mem[idx + _23174 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24174 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24174 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27262 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27262] = 30
                            mem[_27262 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                            _28640 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28640 + 68] = mem[idx + _27262 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28640 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28640 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20969] = 30
                            mem[_20969 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21402 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21402 + 68] = mem[idx + _20969 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21402 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21402 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23173 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23173] = 30
                            mem[_23173 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _24173 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24173 + 68] = mem[idx + _23173 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24173 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24173 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _27261 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27261] = 30
                            mem[_27261 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28639 + 68] = mem[idx + _27261 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28639 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28639 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22570 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22570] = 30
                        mem[_22570 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _23172 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23172 + 68] = mem[idx + _22570 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23172 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23172 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _26039 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26039] = 30
                        mem[_26039 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _27260 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27260 + 68] = mem[idx + _26039 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27260 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27260 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30783 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30783] = 30
                        mem[_30783 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _32092 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32092 + 68] = mem[idx + _30783 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32092 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32092 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20968 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20968] = 30
                            mem[_20968 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21401 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21401 + 68] = mem[idx + _20968 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21401 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21401 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23171 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23171] = 30
                            mem[_23171 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _24172 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24172 + 68] = mem[idx + _23171 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24172 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24172 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27259 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27259] = 30
                            mem[_27259 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                            _28638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28638 + 68] = mem[idx + _27259 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28638 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28638 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _22568 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22568] = 30
                        mem[_22568 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23170 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23170 + 68] = mem[idx + _22568 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23170 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23170 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26037] = 30
                        mem[_26037 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _27258 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27258 + 68] = mem[idx + _26037 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27258 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27258 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _30781 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30781] = 30
                        mem[_30781 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _32091 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32091 + 68] = mem[idx + _30781 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32091 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32091 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _22567 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22567] = 30
                        mem[_22567 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _23169 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23169 + 68] = mem[idx + _22567 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23169 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23169 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _26036 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26036] = 30
                        mem[_26036 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _27257 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27257 + 68] = mem[idx + _26036 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27257 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27257 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30780 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30780] = 30
                        mem[_30780 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _32090 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32090 + 68] = mem[idx + _30780 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32090 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32090 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _25251 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25251] = 30
                    mem[_25251 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _26035 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26035 + 68] = mem[idx + _25251 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26035 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26035 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _29715 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_29715] = 30
                    mem[_29715 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _30779 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30779 + 68] = mem[idx + _29715 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30779 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30779 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _33987 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_33987] = 30
                    mem[_33987 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _34895 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _34895 + 68] = mem[idx + _33987 + 32]
                        idx = idx + 32
                        continue 
                    mem[_34895 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _34895 + -mem[64] + 100
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                if stor2[stor6[idx]] <= s:
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    _19198 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19198] = 30
                    mem[_19198 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor6[idx]] > t:
                        _19262 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19262 + 68] = mem[idx + _19198 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19262 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19262 + -mem[64] + 100
                    if t < stor1[stor6[idx]]:
                        revert with 0, 17
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    _19582 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19582] = 30
                    mem[_19582 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor6[idx]] <= s:
                        if s < stor2[stor6[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor6[idx]]
                        t = t - stor1[stor6[idx]]
                        continue 
                    _19664 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19664 + 68] = mem[idx + _19582 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19664 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19664 + -mem[64] + 100
                _19230 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19230] = 26
                mem[_19230 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19298 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19298 + 68] = mem[idx + _19230 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19298 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19298 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20556] = 30
                            mem[_20556 + 32] = 'SafeMath: subtraction overflow'
                            _21974 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21974] = 30
                            mem[_21974 + 32] = 'SafeMath: subtraction overflow'
                            _25270 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25270] = 30
                            mem[_25270 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                            _26054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26054 + 68] = mem[idx + _25270 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26054 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26054 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20555 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20555] = 30
                            mem[_20555 + 32] = 'SafeMath: subtraction overflow'
                            _21973 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21973] = 30
                            mem[_21973 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22581 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22581 + 68] = mem[idx + _21973 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22581 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22581 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _25269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25269] = 30
                            mem[_25269 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26053 + 68] = mem[idx + _25269 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26053 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26053 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21418 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21418] = 30
                        mem[_21418 + 32] = 'SafeMath: subtraction overflow'
                        _24193 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24193] = 30
                        mem[_24193 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _25268 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25268 + 68] = mem[idx + _24193 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25268 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25268 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28655 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28655] = 30
                        mem[_28655 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _29726 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29726 + 68] = mem[idx + _28655 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29726 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29726 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20554 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20554] = 30
                            mem[_20554 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20745 + 68] = mem[idx + _20554 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20745 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20745 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _21972 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21972] = 30
                            mem[_21972 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22580 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22580 + 68] = mem[idx + _21972 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22580 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22580 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25267] = 30
                            mem[_25267 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                            _26052 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26052 + 68] = mem[idx + _25267 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26052 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26052 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21416 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21416] = 30
                        mem[_21416 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _21971 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21971 + 68] = mem[idx + _21416 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21971 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21971 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24191 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24191] = 30
                        mem[_24191 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _25266 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25266 + 68] = mem[idx + _24191 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25266 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25266 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28653 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28653] = 30
                        mem[_28653 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _29725 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29725 + 68] = mem[idx + _28653 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29725 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29725 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21415 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21415] = 30
                        mem[_21415 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _21970 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21970 + 68] = mem[idx + _21415 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21970 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21970 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24190 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24190] = 30
                        mem[_24190 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _25265 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25265 + 68] = mem[idx + _24190 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25265 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25265 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28652] = 30
                        mem[_28652 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29724 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29724 + 68] = mem[idx + _28652 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29724 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29724 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23188 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23188] = 30
                    mem[_23188 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _24189 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24189 + 68] = mem[idx + _23188 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24189 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24189 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27279 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27279] = 30
                    mem[_27279 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _28651 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28651 + 68] = mem[idx + _27279 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28651 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28651 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32102 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32102] = 30
                    mem[_32102 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _33256 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33256 + 68] = mem[idx + _32102 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33256 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33256 + -mem[64] + 100
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20552 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20552] = 30
                            mem[_20552 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20744 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20744 + 68] = mem[idx + _20552 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20744 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20744 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _21969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21969] = 30
                            mem[_21969 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22578 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22578 + 68] = mem[idx + _21969 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22578 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22578 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25264 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25264] = 30
                            mem[_25264 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26050 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26050 + 68] = mem[idx + _25264 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26050 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26050 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21413 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21413] = 30
                        mem[_21413 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _21968 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21968 + 68] = mem[idx + _21413 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21968 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21968 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24187 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24187] = 30
                        mem[_24187 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25263 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25263 + 68] = mem[idx + _24187 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25263 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25263 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _28649 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28649] = 30
                        mem[_28649 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                        _29723 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29723 + 68] = mem[idx + _28649 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29723 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29723 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21412 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21412] = 30
                        mem[_21412 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _21967 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21967 + 68] = mem[idx + _21412 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21967 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21967 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24186 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24186] = 30
                        mem[_24186 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _25262 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25262 + 68] = mem[idx + _24186 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25262 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25262 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _28648 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28648] = 30
                        mem[_28648 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29722 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29722 + 68] = mem[idx + _28648 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29722 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29722 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23185 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23185] = 30
                    mem[_23185 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _24185 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24185 + 68] = mem[idx + _23185 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24185 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24185 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _27276 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27276] = 30
                    mem[_27276 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _28647 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28647 + 68] = mem[idx + _27276 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28647 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28647 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32098 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32098] = 30
                    mem[_32098 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _33255 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33255 + 68] = mem[idx + _32098 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33255 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33255 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        _21411 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21411] = 30
                        mem[_21411 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _21966 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21966 + 68] = mem[idx + _21411 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21966 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21966 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24184 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24184] = 30
                        mem[_24184 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _25261 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25261 + 68] = mem[idx + _24184 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25261 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25261 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _28646 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28646] = 30
                        mem[_28646 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                        _29721 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _29721 + 68] = mem[idx + _28646 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29721 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _29721 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _23183 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23183] = 30
                    mem[_23183 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24183 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24183 + 68] = mem[idx + _23183 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24183 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24183 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27274 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27274] = 30
                    mem[_27274 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _28645 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28645 + 68] = mem[idx + _27274 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28645 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28645 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _32096 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32096] = 30
                    mem[_32096 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                    _33254 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33254 + 68] = mem[idx + _32096 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33254 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33254 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    _23182 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23182] = 30
                    mem[_23182 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _24182 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _24182 + 68] = mem[idx + _23182 + 32]
                            idx = idx + 32
                            continue 
                        mem[_24182 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _24182 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _27273 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27273] = 30
                    mem[_27273 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _28644 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28644 + 68] = mem[idx + _27273 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28644 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28644 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _32095 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_32095] = 30
                    mem[_32095 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _33253 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _33253 + 68] = mem[idx + _32095 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33253 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _33253 + -mem[64] + 100
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _26046 = mem[64]
                mem[64] = mem[64] + 64
                mem[_26046] = 30
                mem[_26046 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _27272 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _27272 + 68] = mem[idx + _26046 + 32]
                        idx = idx + 32
                        continue 
                    mem[_27272 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _27272 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _30794 = mem[64]
                mem[64] = mem[64] + 64
                mem[_30794] = 30
                mem[_30794 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _32094 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32094 + 68] = mem[idx + _30794 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32094 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32094 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _34896 = mem[64]
                mem[64] = mem[64] + 64
                mem[_34896] = 30
                mem[_34896 + 32] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                _35744 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _35744 + 68] = mem[idx + _34896 + 32]
                    idx = idx + 32
                    continue 
                mem[_35744 + 98] = 0
                revert with memory
                  from mem[64]
                   len _35744 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor15 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            return (-1 * 0 / stor13 / 100 * t / s)
                        if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            return (arg1 * t / s)
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0 / stor13 / 100 * t / s:
                            revert with 0, 17
                        return ((arg1 * t / s) - (0 / stor13 / 100 * t / s))
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                            revert with 0, 17
                        return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s))
                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            return 0
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (-1 * 0 / stor13 / 100 * stor15 / totalSupply)
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 and stor15 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not 0 / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                    revert with 0, 17
                if not 0 / stor13 / 100:
                    revert with 0, 18
                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 0 / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                revert with 0, 17
            if not 0 / stor13 / 100:
                revert with 0, 18
            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply))
        if arg1 and _CHARITY_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[352] = 26
        mem[384] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[416] = 26
        mem[448] = 'SafeMath: division by zero'
        mem[480] = 30
        mem[512] = 'SafeMath: subtraction overflow'
        if arg1 * _TAX_FEE / stor13 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * _TAX_FEE / stor13 / 100:
            revert with 0, 17
        mem[544] = 30
        mem[576] = 'SafeMath: subtraction overflow'
        if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
            revert with 0, 17
        mem[64] = 672
        mem[608] = 30
        mem[640] = 'SafeMath: subtraction overflow'
        if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
            revert with 0, 17
        idx = 0
        s = totalSupply
        t = stor15
        while idx < stor6.length:
            mem[0] = stor6[idx]
            mem[32] = 1
            if stor1[stor6[idx]] > t:
                _19147 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19147] = 26
                mem[_19147 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _19227 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _19227 + 68] = mem[idx + _19147 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19227 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _19227 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20270 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20270] = 30
                            mem[_20270 + 32] = 'SafeMath: subtraction overflow'
                            _21385 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21385] = 30
                            mem[_21385 + 32] = 'SafeMath: subtraction overflow'
                            _24143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24143] = 30
                            mem[_24143 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                            _25221 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25221 + 68] = mem[idx + _24143 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25221 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25221 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20269] = 30
                            mem[_20269 + 32] = 'SafeMath: subtraction overflow'
                            _21384 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21384] = 30
                            mem[_21384 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _21942 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21942 + 68] = mem[idx + _21384 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21942 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21942 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24142 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24142] = 30
                            mem[_24142 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                            _25220 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25220 + 68] = mem[idx + _24142 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25220 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25220 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20951 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20951] = 30
                        mem[_20951 + 32] = 'SafeMath: subtraction overflow'
                        _23140 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23140] = 30
                        mem[_23140 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24141 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24141 + 68] = mem[idx + _23140 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24141 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24141 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27220 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27220] = 30
                        mem[_27220 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28603 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28603 + 68] = mem[idx + _27220 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28603 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28603 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20268 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20268] = 30
                            mem[_20268 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20540 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20540 + 68] = mem[idx + _20268 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20540 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20540 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _21383 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21383] = 30
                            mem[_21383 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _21941 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21941 + 68] = mem[idx + _21383 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21941 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21941 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24140 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24140] = 30
                            mem[_24140 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                            _25219 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25219 + 68] = mem[idx + _24140 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25219 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25219 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20949 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20949] = 30
                        mem[_20949 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _21382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21382 + 68] = mem[idx + _20949 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21382 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _23138 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23138] = 30
                        mem[_23138 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _24139 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24139 + 68] = mem[idx + _23138 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24139 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24139 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27218 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27218] = 30
                        mem[_27218 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28602 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28602 + 68] = mem[idx + _27218 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28602 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28602 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20948 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20948] = 30
                        mem[_20948 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _21381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21381 + 68] = mem[idx + _20948 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21381 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21381 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _23137 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23137] = 30
                        mem[_23137 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _24138 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24138 + 68] = mem[idx + _23137 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24138 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24138 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27217 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27217] = 30
                        mem[_27217 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28601 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28601 + 68] = mem[idx + _27217 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28601 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28601 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22539 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22539] = 30
                    mem[_22539 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _23136 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23136 + 68] = mem[idx + _22539 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23136 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23136 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _25996 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25996] = 30
                    mem[_25996 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _27216 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27216 + 68] = mem[idx + _25996 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27216 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27216 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _30737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30737] = 30
                    mem[_30737 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _32060 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32060 + 68] = mem[idx + _30737 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32060 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32060 + -mem[64] + 100
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20266 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20266] = 30
                            mem[_20266 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20539 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20539 + 68] = mem[idx + _20266 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20539 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20539 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _21380 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21380] = 30
                            mem[_21380 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21939 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21939 + 68] = mem[idx + _21380 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21939 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21939 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24137 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24137] = 30
                            mem[_24137 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _25217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25217 + 68] = mem[idx + _24137 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25217 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25217 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20946 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20946] = 30
                        mem[_20946 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _21379 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21379 + 68] = mem[idx + _20946 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21379 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21379 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _23134 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23134] = 30
                        mem[_23134 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24136 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24136 + 68] = mem[idx + _23134 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24136 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24136 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27214 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27214] = 30
                        mem[_27214 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28600 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28600 + 68] = mem[idx + _27214 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28600 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28600 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20945 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20945] = 30
                        mem[_20945 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _21378 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21378 + 68] = mem[idx + _20945 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21378 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21378 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _23133 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23133] = 30
                        mem[_23133 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24135 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24135 + 68] = mem[idx + _23133 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24135 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24135 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27213 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27213] = 30
                        mem[_27213 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28599 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28599 + 68] = mem[idx + _27213 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28599 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28599 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22536 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22536] = 30
                    mem[_22536 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _23132 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23132 + 68] = mem[idx + _22536 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23132 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23132 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _25993 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25993] = 30
                    mem[_25993 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27212 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27212 + 68] = mem[idx + _25993 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27212 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27212 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _30733 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30733] = 30
                    mem[_30733 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _32059 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32059 + 68] = mem[idx + _30733 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32059 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32059 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20944 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20944] = 30
                        mem[_20944 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _21377 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21377 + 68] = mem[idx + _20944 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21377 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21377 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _23131 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23131] = 30
                        mem[_23131 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _24134 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24134 + 68] = mem[idx + _23131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24134 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24134 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _27211 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27211] = 30
                        mem[_27211 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                        _28598 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28598 + 68] = mem[idx + _27211 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28598 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28598 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _22534 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22534] = 30
                    mem[_22534 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _23130 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23130 + 68] = mem[idx + _22534 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23130 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23130 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _25991 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25991] = 30
                    mem[_25991 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _27210 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27210 + 68] = mem[idx + _25991 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27210 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27210 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _30731 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30731] = 30
                    mem[_30731 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _32058 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32058 + 68] = mem[idx + _30731 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32058 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32058 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _22533 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22533] = 30
                    mem[_22533 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _23129 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23129 + 68] = mem[idx + _22533 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23129 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23129 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _25990 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25990] = 30
                    mem[_25990 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _27209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27209 + 68] = mem[idx + _25990 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27209 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27209 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _30730 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_30730] = 30
                    mem[_30730 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _32057 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _32057 + 68] = mem[idx + _30730 + 32]
                        idx = idx + 32
                        continue 
                    mem[_32057 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _32057 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _25213 = mem[64]
                mem[64] = mem[64] + 64
                mem[_25213] = 30
                mem[_25213 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _25989 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _25989 + 68] = mem[idx + _25213 + 32]
                        idx = idx + 32
                        continue 
                    mem[_25989 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _25989 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _29681 = mem[64]
                mem[64] = mem[64] + 64
                mem[_29681] = 30
                mem[_29681 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _30729 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _30729 + 68] = mem[idx + _29681 + 32]
                        idx = idx + 32
                        continue 
                    mem[_30729 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _30729 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _33945 = mem[64]
                mem[64] = mem[64] + 64
                mem[_33945] = 30
                mem[_33945 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _34875 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _34875 + 68] = mem[idx + _33945 + 32]
                    idx = idx + 32
                    continue 
                mem[_34875 + 98] = 0
                revert with memory
                  from mem[64]
                   len _34875 + -mem[64] + 100
            if idx >= stor6.length:
                revert with 0, 50
            mem[0] = stor6[idx]
            mem[32] = 2
            if stor2[stor6[idx]] <= s:
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 1
                _19196 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19196] = 30
                mem[_19196 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor6[idx]] > t:
                    _19260 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19260 + 68] = mem[idx + _19196 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19260 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19260 + -mem[64] + 100
                if t < stor1[stor6[idx]]:
                    revert with 0, 17
                if idx >= stor6.length:
                    revert with 0, 50
                mem[0] = stor6[idx]
                mem[32] = 2
                _19579 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19579] = 30
                mem[_19579 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor6[idx]] <= s:
                    if s < stor2[stor6[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor6[idx]]
                    t = t - stor1[stor6[idx]]
                    continue 
                _19661 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _19661 + 68] = mem[idx + _19579 + 32]
                    idx = idx + 32
                    continue 
                mem[_19661 + 98] = 0
                revert with memory
                  from mem[64]
                   len _19661 + -mem[64] + 100
            _19228 = mem[64]
            mem[64] = mem[64] + 64
            mem[_19228] = 26
            mem[_19228 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _19294 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _19294 + 68] = mem[idx + _19228 + 32]
                    idx = idx + 32
                    continue 
                mem[_19294 + 94] = 0
                revert with memory
                  from mem[64]
                   len _19294 + -mem[64] + 100
            if not arg1:
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20547 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20547] = 30
                        mem[_20547 + 32] = 'SafeMath: subtraction overflow'
                        _21952 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21952] = 30
                        mem[_21952 + 32] = 'SafeMath: subtraction overflow'
                        _25232 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25232] = 30
                        mem[_25232 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                        _26008 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26008 + 68] = mem[idx + _25232 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26008 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26008 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20546 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20546] = 30
                        mem[_20546 + 32] = 'SafeMath: subtraction overflow'
                        _21951 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21951] = 30
                        mem[_21951 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _22547 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22547 + 68] = mem[idx + _21951 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22547 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22547 + -mem[64] + 100
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _25231 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25231] = 30
                        mem[_25231 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                        _26007 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26007 + 68] = mem[idx + _25231 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26007 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26007 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21394 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21394] = 30
                    mem[_21394 + 32] = 'SafeMath: subtraction overflow'
                    _24155 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24155] = 30
                    mem[_24155 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _25230 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25230 + 68] = mem[idx + _24155 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25230 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25230 + -mem[64] + 100
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _28615 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28615] = 30
                    mem[_28615 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _29692 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29692 + 68] = mem[idx + _28615 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29692 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29692 + -mem[64] + 100
                if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20545 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20545] = 30
                        mem[_20545 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _20737 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20737 + 68] = mem[idx + _20545 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20737 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20737 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _21950 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21950] = 30
                        mem[_21950 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _22546 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22546 + 68] = mem[idx + _21950 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22546 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22546 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _25229 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25229] = 30
                        mem[_25229 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                        _26006 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26006 + 68] = mem[idx + _25229 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26006 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26006 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21392] = 30
                    mem[_21392 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _21949 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21949 + 68] = mem[idx + _21392 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21949 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21949 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _24153 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24153] = 30
                    mem[_24153 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _25228 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25228 + 68] = mem[idx + _24153 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25228 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25228 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _28613 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28613] = 30
                    mem[_28613 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _29691 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29691 + 68] = mem[idx + _28613 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29691 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29691 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _21391 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21391] = 30
                    mem[_21391 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        _21948 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21948 + 68] = mem[idx + _21391 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21948 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21948 + -mem[64] + 100
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _24152 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24152] = 30
                    mem[_24152 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        _25227 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25227 + 68] = mem[idx + _24152 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25227 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25227 + -mem[64] + 100
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _28612 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28612] = 30
                    mem[_28612 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _29690 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29690 + 68] = mem[idx + _28612 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29690 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29690 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23148 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23148] = 30
                mem[_23148 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    _24151 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24151 + 68] = mem[idx + _23148 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24151 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24151 + -mem[64] + 100
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _27231 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27231] = 30
                mem[_27231 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    _28611 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28611 + 68] = mem[idx + _27231 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28611 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28611 + -mem[64] + 100
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _32069 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32069] = 30
                mem[_32069 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _33241 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33241 + 68] = mem[idx + _32069 + 32]
                    idx = idx + 32
                    continue 
                mem[_33241 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33241 + -mem[64] + 100
            if arg1 and stor15 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _20543 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20543] = 30
                        mem[_20543 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _20736 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20736 + 68] = mem[idx + _20543 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20736 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20736 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _21947 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21947] = 30
                        mem[_21947 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22544 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22544 + 68] = mem[idx + _21947 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22544 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22544 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _25226 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25226] = 30
                        mem[_25226 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _26004 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26004 + 68] = mem[idx + _25226 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26004 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26004 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _21389 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21389] = 30
                    mem[_21389 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _21946 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21946 + 68] = mem[idx + _21389 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21946 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21946 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _24149 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24149] = 30
                    mem[_24149 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _25225 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25225 + 68] = mem[idx + _24149 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25225 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25225 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _28609 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28609] = 30
                    mem[_28609 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                        if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                    _29689 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29689 + 68] = mem[idx + _28609 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29689 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29689 + -mem[64] + 100
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _21388 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21388] = 30
                    mem[_21388 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor15 / totalSupply:
                        _21945 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21945 + 68] = mem[idx + _21388 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21945 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21945 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    _24148 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24148] = 30
                    mem[_24148 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _25224 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25224 + 68] = mem[idx + _24148 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25224 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25224 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _28608 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28608] = 30
                    mem[_28608 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                    _29688 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29688 + 68] = mem[idx + _28608 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29688 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29688 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23145 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23145] = 30
                mem[_23145 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    _24147 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24147 + 68] = mem[idx + _23145 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24147 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24147 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                _27228 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27228] = 30
                mem[_27228 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _28607 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28607 + 68] = mem[idx + _27228 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28607 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28607 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _32065 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32065] = 30
                mem[_32065 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _33240 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33240 + 68] = mem[idx + _32065 + 32]
                    idx = idx + 32
                    continue 
                mem[_33240 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33240 + -mem[64] + 100
            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    _21387 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21387] = 30
                    mem[_21387 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _21944 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21944 + 68] = mem[idx + _21387 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21944 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21944 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _24146 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24146] = 30
                    mem[_24146 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _25223 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25223 + 68] = mem[idx + _24146 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25223 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25223 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    _28606 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28606] = 30
                    mem[_28606 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
                    _29687 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _29687 + 68] = mem[idx + _28606 + 32]
                        idx = idx + 32
                        continue 
                    mem[_29687 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _29687 + -mem[64] + 100
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _23143 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23143] = 30
                mem[_23143 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _24145 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24145 + 68] = mem[idx + _23143 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24145 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24145 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _27226 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27226] = 30
                mem[_27226 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _28605 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28605 + 68] = mem[idx + _27226 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28605 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28605 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                _32063 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32063] = 30
                mem[_32063 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
                _33239 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33239 + 68] = mem[idx + _32063 + 32]
                    idx = idx + 32
                    continue 
                mem[_33239 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33239 + -mem[64] + 100
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                _23142 = mem[64]
                mem[64] = mem[64] + 64
                mem[_23142] = 30
                mem[_23142 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    _24144 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _24144 + 68] = mem[idx + _23142 + 32]
                        idx = idx + 32
                        continue 
                    mem[_24144 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _24144 + -mem[64] + 100
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _27225 = mem[64]
                mem[64] = mem[64] + 64
                mem[_27225] = 30
                mem[_27225 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    _28604 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _28604 + 68] = mem[idx + _27225 + 32]
                        idx = idx + 32
                        continue 
                    mem[_28604 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _28604 + -mem[64] + 100
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                _32062 = mem[64]
                mem[64] = mem[64] + 64
                mem[_32062] = 30
                mem[_32062 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
                _33238 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _33238 + 68] = mem[idx + _32062 + 32]
                    idx = idx + 32
                    continue 
                mem[_33238 + 98] = 0
                revert with memory
                  from mem[64]
                   len _33238 + -mem[64] + 100
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _26000 = mem[64]
            mem[64] = mem[64] + 64
            mem[_26000] = 30
            mem[_26000 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                _27224 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _27224 + 68] = mem[idx + _26000 + 32]
                    idx = idx + 32
                    continue 
                mem[_27224 + 98] = 0
                revert with memory
                  from mem[64]
                   len _27224 + -mem[64] + 100
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            _30744 = mem[64]
            mem[64] = mem[64] + 64
            mem[_30744] = 30
            mem[_30744 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                _32061 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _32061 + 68] = mem[idx + _30744 + 32]
                    idx = idx + 32
                    continue 
                mem[_32061 + 98] = 0
                revert with memory
                  from mem[64]
                   len _32061 + -mem[64] + 100
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            _34876 = mem[64]
            mem[64] = mem[64] + 64
            mem[_34876] = 30
            mem[_34876 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            _35741 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _35741 + 68] = mem[idx + _34876 + 32]
                idx = idx + 32
                continue 
            mem[_35741 + 98] = 0
            revert with memory
              from mem[64]
               len _35741 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor15 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            return 0
                        if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * t / s)
                    if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s))
                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s))
            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) - (arg1 * _CHARITY_FEE / stor13 / 100 * t / s))
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * _TAX_FEE / stor13 / 100:
                if not arg1 * _BURN_FEE / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        return 0
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply)
                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply)
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _TAX_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply)
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 and stor15 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _TAX_FEE / stor13 / 100:
            if not arg1 * _BURN_FEE / stor13 / 100:
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor15 / totalSupply)
                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                if not arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _BURN_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if 0 > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < 0:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
            revert with 0, 17
        if not arg1 * _TAX_FEE / stor13 / 100:
            revert with 0, 18
        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _BURN_FEE / stor13 / 100:
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply))
            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 17
            if not arg1 * _CHARITY_FEE / stor13 / 100:
                revert with 0, 18
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
            revert with 0, 17
        if not arg1 * _BURN_FEE / stor13 / 100:
            revert with 0, 18
        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _CHARITY_FEE / stor13 / 100:
            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply))
        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
            revert with 0, 17
        if not arg1 * _CHARITY_FEE / stor13 / 100:
            revert with 0, 18
        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
            revert with 0, 17
        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
            revert with 0, 17
        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
            revert with 0, 17
        return ((arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (2 * 0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19192 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19192] = 26
                        mem[_19192 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19257 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19257 + 68] = mem[idx + _19192 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19257 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19257 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20442 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20442] = 30
                                mem[_20442 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20666 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20666 + 68] = mem[idx + _20442 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20666 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20666 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21713 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21713] = 30
                                mem[_21713 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22221 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22221 + 68] = mem[idx + _21713 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22221 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22221 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24644] = 30
                                mem[_24644 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25717 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25717 + 68] = mem[idx + _24644 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25717 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25717 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21261 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21261] = 30
                                mem[_21261 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21712 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21712 + 68] = mem[idx + _21261 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21712 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21712 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23657 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23657] = 30
                                mem[_23657 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24643 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24643 + 68] = mem[idx + _23657 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24643 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24643 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27843 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27843] = 30
                                mem[_27843 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29131 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29131 + 68] = mem[idx + _27843 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29131 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29131 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22989 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22989] = 30
                            mem[_22989 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23656 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23656 + 68] = mem[idx + _22989 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23656 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23656 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26596 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26596] = 30
                            mem[_26596 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _27842 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27842 + 68] = mem[idx + _26596 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27842 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27842 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31389 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31389] = 30
                            mem[_31389 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32491 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32491 + 68] = mem[idx + _31389 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32491 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32491 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20440] = 30
                            mem[_20440 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20665 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20665 + 68] = mem[idx + _20440 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20665 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20665 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _21711 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21711] = 30
                            mem[_21711 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22219 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22219 + 68] = mem[idx + _21711 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22219 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22219 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24642] = 30
                            mem[_24642 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _25715 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25715 + 68] = mem[idx + _24642 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25715 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25715 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21259 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21259] = 30
                            mem[_21259 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21710 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21710 + 68] = mem[idx + _21259 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21710 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21710 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23654 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23654] = 30
                            mem[_23654 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _24641 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24641 + 68] = mem[idx + _23654 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24641 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24641 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27840 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27840] = 30
                            mem[_27840 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29130 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29130 + 68] = mem[idx + _27840 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29130 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29130 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22987] = 30
                            mem[_22987 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23653 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23653 + 68] = mem[idx + _22987 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23653 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23653 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26594 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26594] = 30
                            mem[_26594 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27839 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27839 + 68] = mem[idx + _26594 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27839 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27839 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31386 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31386] = 30
                            mem[_31386 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32490 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32490 + 68] = mem[idx + _31386 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32490 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32490 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25713] = 30
                        mem[_25713 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26593 + 68] = mem[idx + _25713 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26593 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26593 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30125 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30125] = 30
                        mem[_30125 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31385 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31385 + 68] = mem[idx + _30125 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31385 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31385 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34493 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34493] = 30
                        mem[_34493 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35141 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35141 + 68] = mem[idx + _34493 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35141 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35141 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19226 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19226] = 30
                        mem[_19226 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19290 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19290 + 68] = mem[idx + _19226 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19290 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19290 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19624 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19624] = 30
                        mem[_19624 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19706 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19706 + 68] = mem[idx + _19624 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19706 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19706 + -mem[64] + 100
                    _19258 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19258] = 26
                    mem[_19258 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19354 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19354 + 68] = mem[idx + _19258 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19354 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19354 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            return 0
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20670] = 30
                            mem[_20670 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _20837 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20837 + 68] = mem[idx + _20670 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20837 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20837 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22226 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22226] = 30
                            mem[_22226 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _22993 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22993 + 68] = mem[idx + _22226 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22993 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22993 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25722 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25722] = 30
                            mem[_25722 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26602 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26602 + 68] = mem[idx + _25722 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26602 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26602 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21717 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21717] = 30
                            mem[_21717 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22225 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22225 + 68] = mem[idx + _21717 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22225 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22225 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24649 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24649] = 30
                            mem[_24649 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25721 + 68] = mem[idx + _24649 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25721 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25721 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29136 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29136] = 30
                            mem[_29136 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30130 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30130 + 68] = mem[idx + _29136 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30130 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30130 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23661 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23661] = 30
                        mem[_23661 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24648 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24648 + 68] = mem[idx + _23661 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24648 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24648 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27849 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27849] = 30
                        mem[_27849 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29135 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29135 + 68] = mem[idx + _27849 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29135 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29135 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32496 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32496] = 30
                        mem[_32496 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33442 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33442 + 68] = mem[idx + _32496 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33442 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33442 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _20668 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20668] = 30
                        mem[_20668 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _20836 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20836 + 68] = mem[idx + _20668 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20836 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20836 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _22224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22224] = 30
                        mem[_22224 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22991 + 68] = mem[idx + _22224 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22991 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22991 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _25720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25720] = 30
                        mem[_25720 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _26600 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _26600 + 68] = mem[idx + _25720 + 32]
                            idx = idx + 32
                            continue 
                        mem[_26600 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _26600 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21715 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21715] = 30
                        mem[_21715 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22223 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22223 + 68] = mem[idx + _21715 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22223 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22223 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24646 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24646] = 30
                        mem[_24646 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _25719 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25719 + 68] = mem[idx + _24646 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25719 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25719 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _29133 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29133] = 30
                        mem[_29133 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _30129 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30129 + 68] = mem[idx + _29133 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30129 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30129 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23659 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23659] = 30
                        mem[_23659 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24645 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24645 + 68] = mem[idx + _23659 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24645 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24645 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27847 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27847] = 30
                        mem[_27847 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29132 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29132 + 68] = mem[idx + _27847 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29132 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29132 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32493 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32493] = 30
                        mem[_32493 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33441 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33441 + 68] = mem[idx + _32493 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33441 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33441 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26598 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26598] = 30
                    mem[_26598 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27846 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27846 + 68] = mem[idx + _26598 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27846 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27846 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31392 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31392] = 30
                    mem[_31392 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32492 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32492 + 68] = mem[idx + _31392 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32492 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32492 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35142 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35142] = 30
                    mem[_35142 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35786 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35786 + 68] = mem[idx + _35142 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35786 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35786 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if 0 / stor13 / 100:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if 0 / stor13 / 100:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        return 0
                    else:
                        return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor15 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor15 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (2 * 0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (2 * 0 / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19189 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19189] = 26
                        mem[_19189 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19255 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19255 + 68] = mem[idx + _19189 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19255 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19255 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20434] = 30
                                mem[_20434 + 32] = 'SafeMath: subtraction overflow'
                                _21696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21696] = 30
                                mem[_21696 + 32] = 'SafeMath: subtraction overflow'
                                _24622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24622] = 30
                                mem[_24622 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25696 + 68] = mem[idx + _24622 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25696 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25696 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20433 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20433] = 30
                                    mem[_20433 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20659 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20659 + 68] = mem[idx + _20433 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20659 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20659 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21695 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21695] = 30
                                    mem[_21695 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22210 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22210 + 68] = mem[idx + _21695 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22210 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22210 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24621 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24621] = 30
                                    mem[_24621 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25695 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25695 + 68] = mem[idx + _24621 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25695 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25695 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21248 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21248] = 30
                                mem[_21248 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21694 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21694 + 68] = mem[idx + _21248 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21694 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21694 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23636 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23636] = 30
                                mem[_23636 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24620 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24620 + 68] = mem[idx + _23636 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24620 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24620 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27817 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27817] = 30
                                mem[_27817 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29107 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29107 + 68] = mem[idx + _27817 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29107 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29107 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21247 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21247] = 30
                                mem[_21247 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21693 + 68] = mem[idx + _21247 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21693 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21693 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23635 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23635] = 30
                                mem[_23635 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24619 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24619 + 68] = mem[idx + _23635 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24619 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24619 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27816 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27816] = 30
                                mem[_27816 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29106 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29106 + 68] = mem[idx + _27816 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29106 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29106 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22969] = 30
                            mem[_22969 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23634 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23634 + 68] = mem[idx + _22969 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23634 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23634 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26571] = 30
                            mem[_26571 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _27815 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27815 + 68] = mem[idx + _26571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27815 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27815 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31362 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31362] = 30
                            mem[_31362 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32472 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32472 + 68] = mem[idx + _31362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32472 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32472 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20431] = 30
                                mem[_20431 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20658 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20658 + 68] = mem[idx + _20431 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20658 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20658 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21692 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21692] = 30
                                mem[_21692 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22208 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22208 + 68] = mem[idx + _21692 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22208 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22208 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24618] = 30
                                mem[_24618 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25693 + 68] = mem[idx + _24618 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25693 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25693 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21245 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21245] = 30
                            mem[_21245 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _21691 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21691 + 68] = mem[idx + _21245 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21691 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21691 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _23632 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23632] = 30
                            mem[_23632 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _24617 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24617 + 68] = mem[idx + _23632 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24617 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24617 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _27813 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27813] = 30
                            mem[_27813 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29105 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29105 + 68] = mem[idx + _27813 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29105 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29105 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21244 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21244] = 30
                                mem[_21244 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21690 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21690 + 68] = mem[idx + _21244 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21690 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21690 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23631 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23631] = 30
                                mem[_23631 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24616 + 68] = mem[idx + _23631 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24616 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24616 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27812 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27812] = 30
                                mem[_27812 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29104 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29104 + 68] = mem[idx + _27812 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29104 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29104 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22966] = 30
                            mem[_22966 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23630 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23630 + 68] = mem[idx + _22966 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23630 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23630 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26568] = 30
                            mem[_26568 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27811 + 68] = mem[idx + _26568 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27811 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27811 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31358 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31358] = 30
                            mem[_31358 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32471 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32471 + 68] = mem[idx + _31358 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32471 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32471 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _22965 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22965] = 30
                            mem[_22965 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23629 + 68] = mem[idx + _22965 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23629 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23629 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26567 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26567] = 30
                            mem[_26567 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27810 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27810 + 68] = mem[idx + _26567 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27810 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27810 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31357 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31357] = 30
                            mem[_31357 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32470 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32470 + 68] = mem[idx + _31357 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32470 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32470 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25690 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25690] = 30
                        mem[_25690 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26566 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26566 + 68] = mem[idx + _25690 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26566 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26566 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30106 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30106] = 30
                        mem[_30106 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31356 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31356 + 68] = mem[idx + _30106 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31356 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31356 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34470 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34470] = 30
                        mem[_34470 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35128 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35128 + 68] = mem[idx + _34470 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35128 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35128 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19224] = 30
                        mem[_19224 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19288 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19288 + 68] = mem[idx + _19224 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19288 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19288 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19621 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19621] = 30
                        mem[_19621 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19703 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19703 + 68] = mem[idx + _19621 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19703 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19703 + -mem[64] + 100
                    _19256 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19256] = 26
                    mem[_19256 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19350 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19350 + 68] = mem[idx + _19256 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19350 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19350 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                return 0
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20664 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20664] = 30
                            mem[_20664 + 32] = 'SafeMath: subtraction overflow'
                            _22218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22218] = 30
                            mem[_22218 + 32] = 'SafeMath: subtraction overflow'
                            _25704 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25704] = 30
                            mem[_25704 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26580 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26580 + 68] = mem[idx + _25704 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26580 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26580 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20663 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20663] = 30
                                mem[_20663 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20834 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20834 + 68] = mem[idx + _20663 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20834 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20834 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22217 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22217] = 30
                                mem[_22217 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22975 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22975 + 68] = mem[idx + _22217 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22975 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22975 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25703 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25703] = 30
                                mem[_25703 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26579 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26579 + 68] = mem[idx + _25703 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26579 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26579 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21702 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21702] = 30
                            mem[_21702 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22216 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22216 + 68] = mem[idx + _21702 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22216 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22216 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24630 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24630] = 30
                            mem[_24630 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25702 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25702 + 68] = mem[idx + _24630 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25702 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25702 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29115 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29115] = 30
                            mem[_29115 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30114 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30114 + 68] = mem[idx + _29115 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30114 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30114 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21701 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21701] = 30
                            mem[_21701 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22215 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22215 + 68] = mem[idx + _21701 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22215 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22215 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24629 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24629] = 30
                            mem[_24629 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25701 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25701 + 68] = mem[idx + _24629 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25701 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25701 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29114 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29114] = 30
                            mem[_29114 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30113 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30113 + 68] = mem[idx + _29114 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30113 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30113 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23642 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23642] = 30
                        mem[_23642 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24628 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24628 + 68] = mem[idx + _23642 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24628 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24628 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27826 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27826] = 30
                        mem[_27826 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29113 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29113 + 68] = mem[idx + _27826 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29113 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29113 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32479 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32479] = 30
                        mem[_32479 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33433 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33433 + 68] = mem[idx + _32479 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33433 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33433 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _20661 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20661] = 30
                            mem[_20661 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20833 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20833 + 68] = mem[idx + _20661 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20833 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20833 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22214 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22214] = 30
                            mem[_22214 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22973 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22973 + 68] = mem[idx + _22214 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22973 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22973 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25700 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25700] = 30
                            mem[_25700 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26577 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26577 + 68] = mem[idx + _25700 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26577 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26577 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _21699 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21699] = 30
                        mem[_21699 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _22213 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22213 + 68] = mem[idx + _21699 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22213 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22213 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _24626 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24626] = 30
                        mem[_24626 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _25699 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25699 + 68] = mem[idx + _24626 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25699 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25699 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _29111 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29111] = 30
                        mem[_29111 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _30112 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30112 + 68] = mem[idx + _29111 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30112 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30112 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21698 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21698] = 30
                            mem[_21698 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22212 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22212 + 68] = mem[idx + _21698 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22212 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22212 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24625 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24625] = 30
                            mem[_24625 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25698 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25698 + 68] = mem[idx + _24625 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25698 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25698 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29110 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29110] = 30
                            mem[_29110 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30111 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30111 + 68] = mem[idx + _29110 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30111 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30111 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23639 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23639] = 30
                        mem[_23639 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24624 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24624 + 68] = mem[idx + _23639 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24624 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24624 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27823 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27823] = 30
                        mem[_27823 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29109 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29109 + 68] = mem[idx + _27823 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29109 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29109 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32475] = 30
                        mem[_32475 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33432 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33432 + 68] = mem[idx + _32475 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33432 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33432 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23638 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23638] = 30
                        mem[_23638 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24623 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24623 + 68] = mem[idx + _23638 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24623 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24623 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27822 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27822] = 30
                        mem[_27822 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29108 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29108 + 68] = mem[idx + _27822 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29108 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29108 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32474 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32474] = 30
                        mem[_32474 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33431 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33431 + 68] = mem[idx + _32474 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33431 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33431 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26574 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26574] = 30
                    mem[_26574 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27821 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27821 + 68] = mem[idx + _26574 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27821 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27821 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31367 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31367] = 30
                    mem[_31367 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32473 + 68] = mem[idx + _31367 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32473 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32473 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35129 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35129] = 30
                    mem[_35129 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35783 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35783 + 68] = mem[idx + _35129 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35783 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35783 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                else:
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
        else:
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19186 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19186] = 26
                        mem[_19186 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19253 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19253 + 68] = mem[idx + _19186 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19253 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19253 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not 0 / stor13 / 100:
                                        return 0
                                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20425] = 30
                                    mem[_20425 + 32] = 'SafeMath: subtraction overflow'
                                    _21674 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21674] = 30
                                    mem[_21674 + 32] = 'SafeMath: subtraction overflow'
                                    _24591 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24591] = 30
                                    mem[_24591 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25664 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25664 + 68] = mem[idx + _24591 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25664 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25664 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20424] = 30
                                    mem[_20424 + 32] = 'SafeMath: subtraction overflow'
                                    _21673 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21673] = 30
                                    mem[_21673 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22192 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22192 + 68] = mem[idx + _21673 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22192 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22192 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24590 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24590] = 30
                                    mem[_24590 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25663 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25663 + 68] = mem[idx + _24590 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25663 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25663 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21231 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21231] = 30
                                mem[_21231 + 32] = 'SafeMath: subtraction overflow'
                                _23604 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23604] = 30
                                mem[_23604 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24589 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24589 + 68] = mem[idx + _23604 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24589 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24589 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27779 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27779] = 30
                                mem[_27779 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29073 + 68] = mem[idx + _27779 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29073 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29073 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20423 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20423] = 30
                                    mem[_20423 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20650 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20650 + 68] = mem[idx + _20423 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20650 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20650 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21672] = 30
                                    mem[_21672 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22191 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22191 + 68] = mem[idx + _21672 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22191 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22191 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24588 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24588] = 30
                                    mem[_24588 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25662 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25662 + 68] = mem[idx + _24588 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25662 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25662 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21229] = 30
                                mem[_21229 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21671 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21671 + 68] = mem[idx + _21229 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21671 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21671 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23602 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23602] = 30
                                mem[_23602 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24587 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24587 + 68] = mem[idx + _23602 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24587 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24587 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27777] = 30
                                mem[_27777 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29072 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29072 + 68] = mem[idx + _27777 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29072 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29072 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21228 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21228] = 30
                                mem[_21228 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21670 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21670 + 68] = mem[idx + _21228 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21670 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21670 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23601 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23601] = 30
                                mem[_23601 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24586 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24586 + 68] = mem[idx + _23601 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24586 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24586 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27776 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27776] = 30
                                mem[_27776 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29071 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29071 + 68] = mem[idx + _27776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29071 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29071 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22941 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22941] = 30
                            mem[_22941 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23600 + 68] = mem[idx + _22941 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23600 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23600 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26535 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26535] = 30
                            mem[_26535 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _27775 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27775 + 68] = mem[idx + _26535 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27775 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27775 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31322 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31322] = 30
                            mem[_31322 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32444 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32444 + 68] = mem[idx + _31322 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32444 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32444 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20421 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20421] = 30
                                    mem[_20421 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20649 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20649 + 68] = mem[idx + _20421 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20649 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20649 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21669 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21669] = 30
                                    mem[_21669 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22189 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22189 + 68] = mem[idx + _21669 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22189 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22189 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24585 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24585] = 30
                                    mem[_24585 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25660 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25660 + 68] = mem[idx + _24585 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25660 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25660 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21226 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21226] = 30
                                mem[_21226 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21668 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21668 + 68] = mem[idx + _21226 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21668 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21668 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23598 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23598] = 30
                                mem[_23598 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24584 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24584 + 68] = mem[idx + _23598 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24584 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24584 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27773 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27773] = 30
                                mem[_27773 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29070 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29070 + 68] = mem[idx + _27773 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29070 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29070 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21225 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21225] = 30
                                mem[_21225 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21667 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21667 + 68] = mem[idx + _21225 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21667 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21667 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23597 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23597] = 30
                                mem[_23597 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24583 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24583 + 68] = mem[idx + _23597 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24583 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24583 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27772] = 30
                                mem[_27772 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29069 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29069 + 68] = mem[idx + _27772 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29069 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29069 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22938 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22938] = 30
                            mem[_22938 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23596 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23596 + 68] = mem[idx + _22938 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23596 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23596 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26532 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26532] = 30
                            mem[_26532 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27771 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27771 + 68] = mem[idx + _26532 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27771 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27771 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31318 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31318] = 30
                            mem[_31318 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32443 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32443 + 68] = mem[idx + _31318 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32443 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32443 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _21224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21224] = 30
                                mem[_21224 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21666 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21666 + 68] = mem[idx + _21224 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21666 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21666 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23595 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23595] = 30
                                mem[_23595 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24582 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24582 + 68] = mem[idx + _23595 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24582 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24582 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27770 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27770] = 30
                                mem[_27770 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29068 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29068 + 68] = mem[idx + _27770 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29068 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29068 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22936 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22936] = 30
                            mem[_22936 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23594 + 68] = mem[idx + _22936 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23594 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23594 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26530 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26530] = 30
                            mem[_26530 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27769 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27769 + 68] = mem[idx + _26530 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27769 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27769 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31316 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31316] = 30
                            mem[_31316 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32442 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32442 + 68] = mem[idx + _31316 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32442 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32442 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22935 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22935] = 30
                            mem[_22935 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23593 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23593 + 68] = mem[idx + _22935 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23593 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23593 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26529 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26529] = 30
                            mem[_26529 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27768 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27768 + 68] = mem[idx + _26529 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27768 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27768 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31315 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31315] = 30
                            mem[_31315 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32441 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32441 + 68] = mem[idx + _31315 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32441 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32441 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25656 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25656] = 30
                        mem[_25656 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26528 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26528 + 68] = mem[idx + _25656 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26528 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26528 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30078 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30078] = 30
                        mem[_30078 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31314 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31314 + 68] = mem[idx + _30078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31314 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31314 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34436] = 30
                        mem[_34436 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35110 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35110 + 68] = mem[idx + _34436 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35110 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35110 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19222] = 30
                        mem[_19222 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19286 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19286 + 68] = mem[idx + _19222 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19286 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19286 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19618 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19618] = 30
                        mem[_19618 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19700 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19700 + 68] = mem[idx + _19618 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19700 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19700 + -mem[64] + 100
                    _19254 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19254] = 26
                    mem[_19254 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19346 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19346 + 68] = mem[idx + _19254 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19346 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19346 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20657 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20657] = 30
                                mem[_20657 + 32] = 'SafeMath: subtraction overflow'
                                _22202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22202] = 30
                                mem[_22202 + 32] = 'SafeMath: subtraction overflow'
                                _25675 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25675] = 30
                                mem[_25675 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26547 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26547 + 68] = mem[idx + _25675 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26547 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26547 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20656 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20656] = 30
                                mem[_20656 + 32] = 'SafeMath: subtraction overflow'
                                _22201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22201] = 30
                                mem[_22201 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22949 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22949 + 68] = mem[idx + _22201 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22949 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22949 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25674 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25674] = 30
                                mem[_25674 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26546 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26546 + 68] = mem[idx + _25674 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26546 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26546 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21683] = 30
                            mem[_21683 + 32] = 'SafeMath: subtraction overflow'
                            _24603 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24603] = 30
                            mem[_24603 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25673 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25673 + 68] = mem[idx + _24603 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25673 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25673 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29085 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29085] = 30
                            mem[_29085 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30089 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30089 + 68] = mem[idx + _29085 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30089 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30089 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20655 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20655] = 30
                                mem[_20655 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20827 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20827 + 68] = mem[idx + _20655 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20827 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20827 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22200 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22200] = 30
                                mem[_22200 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22948 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22948 + 68] = mem[idx + _22200 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22948 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22948 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25672 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25672] = 30
                                mem[_25672 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26545 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26545 + 68] = mem[idx + _25672 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26545 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26545 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21681 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21681] = 30
                            mem[_21681 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22199 + 68] = mem[idx + _21681 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22199 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24601 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24601] = 30
                            mem[_24601 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25671 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25671 + 68] = mem[idx + _24601 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25671 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25671 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29083 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29083] = 30
                            mem[_29083 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30088 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30088 + 68] = mem[idx + _29083 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30088 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30088 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21680 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21680] = 30
                            mem[_21680 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22198 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22198 + 68] = mem[idx + _21680 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22198 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22198 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24600] = 30
                            mem[_24600 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25670 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25670 + 68] = mem[idx + _24600 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25670 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25670 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29082 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29082] = 30
                            mem[_29082 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30087 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30087 + 68] = mem[idx + _29082 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30087 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30087 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23612 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23612] = 30
                        mem[_23612 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24599 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24599 + 68] = mem[idx + _23612 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24599 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24599 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27790] = 30
                        mem[_27790 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29081 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29081 + 68] = mem[idx + _27790 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29081 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29081 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32453 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32453] = 30
                        mem[_32453 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33421 + 68] = mem[idx + _32453 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33421 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33421 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20653 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20653] = 30
                                mem[_20653 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20826 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20826 + 68] = mem[idx + _20653 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20826 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20826 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22197 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22197] = 30
                                mem[_22197 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22946 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22946 + 68] = mem[idx + _22197 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22946 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22946 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25669 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25669] = 30
                                mem[_25669 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26543 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26543 + 68] = mem[idx + _25669 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26543 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26543 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21678 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21678] = 30
                            mem[_21678 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22196 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22196 + 68] = mem[idx + _21678 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22196 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22196 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24597 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24597] = 30
                            mem[_24597 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25668 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25668 + 68] = mem[idx + _24597 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25668 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25668 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29079] = 30
                            mem[_29079 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30086 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30086 + 68] = mem[idx + _29079 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30086 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30086 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21677 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21677] = 30
                            mem[_21677 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22195 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22195 + 68] = mem[idx + _21677 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22195 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22195 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24596 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24596] = 30
                            mem[_24596 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25667 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25667 + 68] = mem[idx + _24596 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25667 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25667 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29078] = 30
                            mem[_29078 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30085 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30085 + 68] = mem[idx + _29078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30085 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30085 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23609 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23609] = 30
                        mem[_23609 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24595 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24595 + 68] = mem[idx + _23609 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24595 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24595 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27787 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27787] = 30
                        mem[_27787 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29077 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29077 + 68] = mem[idx + _27787 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29077 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29077 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32449 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32449] = 30
                        mem[_32449 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33420 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33420 + 68] = mem[idx + _32449 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33420 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33420 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _21676 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21676] = 30
                            mem[_21676 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22194 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22194 + 68] = mem[idx + _21676 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22194 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22194 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24594 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24594] = 30
                            mem[_24594 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25666 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25666 + 68] = mem[idx + _24594 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25666 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25666 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29076 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29076] = 30
                            mem[_29076 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30084 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30084 + 68] = mem[idx + _29076 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30084 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30084 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23607] = 30
                        mem[_23607 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24593 + 68] = mem[idx + _23607 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24593 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24593 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27785 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27785] = 30
                        mem[_27785 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29075 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29075 + 68] = mem[idx + _27785 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29075 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29075 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32447 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32447] = 30
                        mem[_32447 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33419 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33419 + 68] = mem[idx + _32447 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33419 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33419 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23606 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23606] = 30
                        mem[_23606 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24592 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24592 + 68] = mem[idx + _23606 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24592 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24592 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27784] = 30
                        mem[_27784 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29074 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29074 + 68] = mem[idx + _27784 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29074 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29074 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32446 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32446] = 30
                        mem[_32446 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33418 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33418 + 68] = mem[idx + _32446 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33418 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33418 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26539 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26539] = 30
                    mem[_26539 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27783 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27783 + 68] = mem[idx + _26539 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27783 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27783 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31329 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31329] = 30
                    mem[_31329 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32445 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32445 + 68] = mem[idx + _31329 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32445 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32445 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35111 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35111] = 30
                    mem[_35111 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35780 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35780 + 68] = mem[idx + _35111 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35780 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35780 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if 0 / stor13 / 100:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if 0 / stor13 / 100:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0 / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (0 / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19183 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19183] = 26
                        mem[_19183 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19251 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19251 + 68] = mem[idx + _19183 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19251 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19251 + -mem[64] + 100
                        if not arg1:
                            if not 0 / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20412] = 30
                                    mem[_20412 + 32] = 'SafeMath: subtraction overflow'
                                    _21650 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21650] = 30
                                    mem[_21650 + 32] = 'SafeMath: subtraction overflow'
                                    _24553 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24553] = 30
                                    mem[_24553 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25626 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25626 + 68] = mem[idx + _24553 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25626 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25626 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20411 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20411] = 30
                                    mem[_20411 + 32] = 'SafeMath: subtraction overflow'
                                    _21649 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21649] = 30
                                    mem[_21649 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22170 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22170 + 68] = mem[idx + _21649 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22170 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22170 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24552 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24552] = 30
                                    mem[_24552 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25625 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25625 + 68] = mem[idx + _24552 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25625 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25625 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21207] = 30
                                mem[_21207 + 32] = 'SafeMath: subtraction overflow'
                                _23564 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23564] = 30
                                mem[_23564 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24551 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24551 + 68] = mem[idx + _23564 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24551 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24551 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27731 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27731] = 30
                                mem[_27731 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29033 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29033 + 68] = mem[idx + _27731 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29033 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29033 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20410] = 30
                                    mem[_20410 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20641 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20641 + 68] = mem[idx + _20410 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20641 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20641 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21648 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21648] = 30
                                    mem[_21648 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        _22169 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22169 + 68] = mem[idx + _21648 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22169 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22169 + -mem[64] + 100
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24550 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24550] = 30
                                    mem[_24550 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25624 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25624 + 68] = mem[idx + _24550 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25624 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25624 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21205 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21205] = 30
                                mem[_21205 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21647 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21647 + 68] = mem[idx + _21205 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21647 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21647 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23562 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23562] = 30
                                mem[_23562 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24549 + 68] = mem[idx + _23562 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24549 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24549 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27729 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27729] = 30
                                mem[_27729 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29032 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29032 + 68] = mem[idx + _27729 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29032 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29032 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21204 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21204] = 30
                                mem[_21204 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21646 + 68] = mem[idx + _21204 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21646 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21646 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23561 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23561] = 30
                                mem[_23561 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _24548 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24548 + 68] = mem[idx + _23561 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24548 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24548 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27728] = 30
                                mem[_27728 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _29031 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29031 + 68] = mem[idx + _27728 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29031 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29031 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22907] = 30
                            mem[_22907 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _23560 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23560 + 68] = mem[idx + _22907 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23560 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23560 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26489 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26489] = 30
                            mem[_26489 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _27727 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27727 + 68] = mem[idx + _26489 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27727 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27727 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31272 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31272] = 30
                            mem[_31272 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32411 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32411 + 68] = mem[idx + _31272 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32411 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32411 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20408] = 30
                                    mem[_20408 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20640 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20640 + 68] = mem[idx + _20408 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20640 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20640 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21645 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21645] = 30
                                    mem[_21645 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22167 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22167 + 68] = mem[idx + _21645 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22167 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22167 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24547 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24547] = 30
                                    mem[_24547 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25622 + 68] = mem[idx + _24547 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25622 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25622 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21202] = 30
                                mem[_21202 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21644 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21644 + 68] = mem[idx + _21202 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21644 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21644 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23558 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23558] = 30
                                mem[_23558 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24546 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24546 + 68] = mem[idx + _23558 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24546 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24546 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27725 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27725] = 30
                                mem[_27725 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29030 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29030 + 68] = mem[idx + _27725 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29030 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29030 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21201] = 30
                                mem[_21201 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21643 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21643 + 68] = mem[idx + _21201 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21643 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21643 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23557 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23557] = 30
                                mem[_23557 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24545 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24545 + 68] = mem[idx + _23557 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24545 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24545 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27724] = 30
                                mem[_27724 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29029 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29029 + 68] = mem[idx + _27724 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29029 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29029 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22904 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22904] = 30
                            mem[_22904 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23556 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23556 + 68] = mem[idx + _22904 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23556 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23556 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26486 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26486] = 30
                            mem[_26486 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27723 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27723 + 68] = mem[idx + _26486 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27723 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27723 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31268 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31268] = 30
                            mem[_31268 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32410 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32410 + 68] = mem[idx + _31268 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32410 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32410 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21200 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21200] = 30
                                mem[_21200 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21642 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21642 + 68] = mem[idx + _21200 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21642 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21642 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23555 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23555] = 30
                                mem[_23555 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    _24544 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24544 + 68] = mem[idx + _23555 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24544 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24544 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27722 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27722] = 30
                                mem[_27722 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _29028 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _29028 + 68] = mem[idx + _27722 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29028 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _29028 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22902 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22902] = 30
                            mem[_22902 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23554 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23554 + 68] = mem[idx + _22902 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23554 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23554 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26484 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26484] = 30
                            mem[_26484 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27721 + 68] = mem[idx + _26484 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27721 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27721 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31266 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31266] = 30
                            mem[_31266 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32409 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32409 + 68] = mem[idx + _31266 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32409 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32409 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _22901 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22901] = 30
                            mem[_22901 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23553 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23553 + 68] = mem[idx + _22901 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23553 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23553 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26483 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26483] = 30
                            mem[_26483 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _27720 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27720 + 68] = mem[idx + _26483 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27720 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27720 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31265 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31265] = 30
                            mem[_31265 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32408 + 68] = mem[idx + _31265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32408 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32408 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25618 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25618] = 30
                        mem[_25618 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26482 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26482 + 68] = mem[idx + _25618 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26482 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26482 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30044 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30044] = 30
                        mem[_30044 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _31264 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31264 + 68] = mem[idx + _30044 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31264 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31264 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34394 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34394] = 30
                        mem[_34394 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35090 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35090 + 68] = mem[idx + _34394 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35090 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35090 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19220 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19220] = 30
                        mem[_19220 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19284 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19284 + 68] = mem[idx + _19220 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19284 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19284 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19615] = 30
                        mem[_19615 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19697 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19697 + 68] = mem[idx + _19615 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19697 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19697 + -mem[64] + 100
                    _19252 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19252] = 26
                    mem[_19252 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19342 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19342 + 68] = mem[idx + _19252 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19342 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19342 + -mem[64] + 100
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20648 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20648] = 30
                                mem[_20648 + 32] = 'SafeMath: subtraction overflow'
                                _22180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22180] = 30
                                mem[_22180 + 32] = 'SafeMath: subtraction overflow'
                                _25637 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25637] = 30
                                mem[_25637 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26501 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26501 + 68] = mem[idx + _25637 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26501 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26501 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20647 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20647] = 30
                                mem[_20647 + 32] = 'SafeMath: subtraction overflow'
                                _22179 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22179] = 30
                                mem[_22179 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22915 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22915 + 68] = mem[idx + _22179 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22915 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22915 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25636 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25636] = 30
                                mem[_25636 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26500 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26500 + 68] = mem[idx + _25636 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26500 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26500 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21659] = 30
                            mem[_21659 + 32] = 'SafeMath: subtraction overflow'
                            _24565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24565] = 30
                            mem[_24565 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25635 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25635 + 68] = mem[idx + _24565 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25635 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25635 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29045 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29045] = 30
                            mem[_29045 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30055 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30055 + 68] = mem[idx + _29045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30055 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30055 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20646 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20646] = 30
                                mem[_20646 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20819 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20819 + 68] = mem[idx + _20646 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20819 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20819 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22178] = 30
                                mem[_22178 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    _22914 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22914 + 68] = mem[idx + _22178 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22914 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22914 + -mem[64] + 100
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25634 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25634] = 30
                                mem[_25634 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26499 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26499 + 68] = mem[idx + _25634 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26499 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26499 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21657 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21657] = 30
                            mem[_21657 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22177 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22177 + 68] = mem[idx + _21657 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22177 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22177 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24563] = 30
                            mem[_24563 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25633 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25633 + 68] = mem[idx + _24563 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25633 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25633 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29043 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29043] = 30
                            mem[_29043 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30054 + 68] = mem[idx + _29043 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30054 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30054 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21656] = 30
                            mem[_21656 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _22176 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22176 + 68] = mem[idx + _21656 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22176 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22176 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24562] = 30
                            mem[_24562 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                _25632 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25632 + 68] = mem[idx + _24562 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25632 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25632 + -mem[64] + 100
                            if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29042] = 30
                            mem[_29042 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30053 + 68] = mem[idx + _29042 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30053 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30053 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23572 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23572] = 30
                        mem[_23572 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                            _24561 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24561 + 68] = mem[idx + _23572 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24561 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24561 + -mem[64] + 100
                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27742 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27742] = 30
                        mem[_27742 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                            _29041 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29041 + 68] = mem[idx + _27742 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29041 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29041 + -mem[64] + 100
                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32420 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32420] = 30
                        mem[_32420 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33406 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33406 + 68] = mem[idx + _32420 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33406 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33406 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20644] = 30
                                mem[_20644 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20818 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20818 + 68] = mem[idx + _20644 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20818 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20818 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22175 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22175] = 30
                                mem[_22175 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22912 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22912 + 68] = mem[idx + _22175 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22912 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22912 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25631 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25631] = 30
                                mem[_25631 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26497 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26497 + 68] = mem[idx + _25631 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26497 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26497 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21654 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21654] = 30
                            mem[_21654 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22174 + 68] = mem[idx + _21654 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22174 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22174 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24559] = 30
                            mem[_24559 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25630 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25630 + 68] = mem[idx + _24559 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25630 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25630 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _29039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29039] = 30
                            mem[_29039 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30052 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30052 + 68] = mem[idx + _29039 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30052 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30052 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21653] = 30
                            mem[_21653 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22173 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22173 + 68] = mem[idx + _21653 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22173 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22173 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24558 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24558] = 30
                            mem[_24558 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25629 + 68] = mem[idx + _24558 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25629 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25629 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29038 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29038] = 30
                            mem[_29038 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30051 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30051 + 68] = mem[idx + _29038 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30051 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30051 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23569 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23569] = 30
                        mem[_23569 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24557 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24557 + 68] = mem[idx + _23569 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24557 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24557 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27739] = 30
                        mem[_27739 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29037 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29037 + 68] = mem[idx + _27739 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29037 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29037 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32416 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32416] = 30
                        mem[_32416 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33405 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33405 + 68] = mem[idx + _32416 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33405 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33405 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21652 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21652] = 30
                            mem[_21652 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22172 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22172 + 68] = mem[idx + _21652 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22172 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22172 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24556] = 30
                            mem[_24556 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                _25628 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25628 + 68] = mem[idx + _24556 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25628 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25628 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _29036 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29036] = 30
                            mem[_29036 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30050 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30050 + 68] = mem[idx + _29036 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30050 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30050 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23567 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23567] = 30
                        mem[_23567 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24555 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24555 + 68] = mem[idx + _23567 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24555 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24555 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27737 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27737] = 30
                        mem[_27737 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29035 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29035 + 68] = mem[idx + _27737 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29035 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29035 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32414] = 30
                        mem[_32414 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33404 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33404 + 68] = mem[idx + _32414 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33404 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33404 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23566 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23566] = 30
                        mem[_23566 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24554 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24554 + 68] = mem[idx + _23566 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24554 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24554 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27736 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27736] = 30
                        mem[_27736 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            _29034 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29034 + 68] = mem[idx + _27736 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29034 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29034 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32413 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32413] = 30
                        mem[_32413 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33403 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33403 + 68] = mem[idx + _32413 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33403 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33403 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26493 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26493] = 30
                    mem[_26493 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27735 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27735 + 68] = mem[idx + _26493 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27735 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27735 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31279 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31279] = 30
                    mem[_31279 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        _32412 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32412 + 68] = mem[idx + _31279 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32412 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32412 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35091 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35091] = 30
                    mem[_35091 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35777 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35777 + 68] = mem[idx + _35091 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35777 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35777 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not 0 / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * 0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not 0 / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * 0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 0 / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
    else:
        if arg1 and _TAX_FEE > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _TAX_FEE / arg1 != _TAX_FEE:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not stor13:
            revert with 0, 'SafeMath: division by zero', 0
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19180 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19180] = 26
                        mem[_19180 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19249 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19249 + 68] = mem[idx + _19180 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19249 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19249 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20400 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20400] = 30
                                    mem[_20400 + 32] = 'SafeMath: subtraction overflow'
                                    _21628 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21628] = 30
                                    mem[_21628 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22151 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22151 + 68] = mem[idx + _21628 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22151 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22151 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24518 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24518] = 30
                                    mem[_24518 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25591 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25591 + 68] = mem[idx + _24518 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25591 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25591 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21185 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21185] = 30
                                mem[_21185 + 32] = 'SafeMath: subtraction overflow'
                                _23527 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23527] = 30
                                mem[_23527 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24517 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24517 + 68] = mem[idx + _23527 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24517 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24517 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27687 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27687] = 30
                                mem[_27687 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28997 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28997 + 68] = mem[idx + _27687 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28997 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28997 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20399 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20399] = 30
                                mem[_20399 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20633 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20633 + 68] = mem[idx + _20399 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20633 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20633 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _21627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21627] = 30
                                mem[_21627 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22150 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22150 + 68] = mem[idx + _21627 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22150 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22150 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24516 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24516] = 30
                                mem[_24516 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _25590 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25590 + 68] = mem[idx + _24516 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25590 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25590 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21183 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21183] = 30
                                mem[_21183 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21626 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21626 + 68] = mem[idx + _21183 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21626 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21626 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23525 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23525] = 30
                                mem[_23525 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24515 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24515 + 68] = mem[idx + _23525 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24515 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24515 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27685 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27685] = 30
                                mem[_27685 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28996 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28996 + 68] = mem[idx + _27685 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28996 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28996 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22875 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22875] = 30
                            mem[_22875 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23524 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23524 + 68] = mem[idx + _22875 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23524 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23524 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26446] = 30
                            mem[_26446 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _27684 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27684 + 68] = mem[idx + _26446 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27684 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27684 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31225 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31225] = 30
                            mem[_31225 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32382 + 68] = mem[idx + _31225 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32382 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20397 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20397] = 30
                                mem[_20397 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20632 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20632 + 68] = mem[idx + _20397 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20632 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20632 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _21625 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21625] = 30
                                mem[_21625 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22148 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22148 + 68] = mem[idx + _21625 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22148 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22148 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _24514 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24514] = 30
                                mem[_24514 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _25588 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25588 + 68] = mem[idx + _24514 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25588 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25588 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21181] = 30
                                mem[_21181 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21624 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21624 + 68] = mem[idx + _21181 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21624 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21624 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23522] = 30
                                mem[_23522 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24513 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24513 + 68] = mem[idx + _23522 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24513 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24513 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27682 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27682] = 30
                                mem[_27682 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28995 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28995 + 68] = mem[idx + _27682 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28995 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28995 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22873 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22873] = 30
                            mem[_22873 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23521 + 68] = mem[idx + _22873 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23521 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23521 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26444 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26444] = 30
                            mem[_26444 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27681 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27681 + 68] = mem[idx + _26444 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27681 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27681 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31222 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31222] = 30
                            mem[_31222 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32381 + 68] = mem[idx + _31222 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32381 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32381 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21180 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21180] = 30
                            mem[_21180 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _21623 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21623 + 68] = mem[idx + _21180 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21623 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21623 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _23520 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23520] = 30
                            mem[_23520 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _24512 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _24512 + 68] = mem[idx + _23520 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24512 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _24512 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _27680 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27680] = 30
                            mem[_27680 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _28994 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28994 + 68] = mem[idx + _27680 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28994 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28994 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22871 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22871] = 30
                            mem[_22871 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23519 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23519 + 68] = mem[idx + _22871 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23519 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23519 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26442 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26442] = 30
                            mem[_26442 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27679 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27679 + 68] = mem[idx + _26442 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27679 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27679 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31220 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31220] = 30
                            mem[_31220 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32380 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32380 + 68] = mem[idx + _31220 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32380 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32380 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25585 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25585] = 30
                        mem[_25585 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26441 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26441 + 68] = mem[idx + _25585 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26441 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26441 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _30013 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_30013] = 30
                        mem[_30013 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31219 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31219 + 68] = mem[idx + _30013 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31219 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31219 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34355 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34355] = 30
                        mem[_34355 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35073 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35073 + 68] = mem[idx + _34355 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35073 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35073 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19218 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19218] = 30
                        mem[_19218 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19282 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19282 + 68] = mem[idx + _19218 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19282 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19282 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19612 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19612] = 30
                        mem[_19612 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19694 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19694 + 68] = mem[idx + _19612 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19694 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19694 + -mem[64] + 100
                    _19250 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19250] = 26
                    mem[_19250 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19338 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19338 + 68] = mem[idx + _19250 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19338 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19338 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                return 0
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20639 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20639] = 30
                                mem[_20639 + 32] = 'SafeMath: subtraction overflow'
                                _22158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22158] = 30
                                mem[_22158 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22881 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22881 + 68] = mem[idx + _22158 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22881 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22881 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25599 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25599] = 30
                                mem[_25599 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26455 + 68] = mem[idx + _25599 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26455 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26455 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21635] = 30
                            mem[_21635 + 32] = 'SafeMath: subtraction overflow'
                            _24527 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24527] = 30
                            mem[_24527 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _25598 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25598 + 68] = mem[idx + _24527 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25598 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25598 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29006 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29006] = 30
                            mem[_29006 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30021 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30021 + 68] = mem[idx + _29006 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30021 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30021 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _20638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20638] = 30
                            mem[_20638 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _20811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20811 + 68] = mem[idx + _20638 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20811 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20811 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _22157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22157] = 30
                            mem[_22157 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _22880 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22880 + 68] = mem[idx + _22157 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22880 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22880 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25597 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25597] = 30
                            mem[_25597 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _26454 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26454 + 68] = mem[idx + _25597 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26454 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26454 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21633 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21633] = 30
                            mem[_21633 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22156 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22156 + 68] = mem[idx + _21633 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22156 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22156 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24525 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24525] = 30
                            mem[_24525 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25596 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25596 + 68] = mem[idx + _24525 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25596 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25596 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29004 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29004] = 30
                            mem[_29004 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _30020 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30020 + 68] = mem[idx + _29004 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30020 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30020 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23533 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23533] = 30
                        mem[_23533 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24524 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24524 + 68] = mem[idx + _23533 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24524 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24524 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27695 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27695] = 30
                        mem[_27695 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _29003 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29003 + 68] = mem[idx + _27695 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29003 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29003 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32389 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32389] = 30
                        mem[_32389 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33391 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33391 + 68] = mem[idx + _32389 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33391 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33391 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _20636 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20636] = 30
                            mem[_20636 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _20810 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20810 + 68] = mem[idx + _20636 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20810 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20810 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _22155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22155] = 30
                            mem[_22155 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22878 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22878 + 68] = mem[idx + _22155 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22878 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22878 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _25595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25595] = 30
                            mem[_25595 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _26452 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26452 + 68] = mem[idx + _25595 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26452 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26452 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21631 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21631] = 30
                            mem[_21631 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22154 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22154 + 68] = mem[idx + _21631 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22154 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22154 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24522] = 30
                            mem[_24522 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25594 + 68] = mem[idx + _24522 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25594 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25594 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _29001 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29001] = 30
                            mem[_29001 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _30019 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _30019 + 68] = mem[idx + _29001 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30019 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _30019 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23531 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23531] = 30
                        mem[_23531 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24521 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24521 + 68] = mem[idx + _23531 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24521 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24521 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27693 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27693] = 30
                        mem[_27693 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _29000 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29000 + 68] = mem[idx + _27693 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29000 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29000 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32386] = 30
                        mem[_32386 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33390 + 68] = mem[idx + _32386 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33390 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33390 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _21630 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21630] = 30
                        mem[_21630 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _22153 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22153 + 68] = mem[idx + _21630 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22153 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22153 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _24520 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24520] = 30
                        mem[_24520 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _25593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25593 + 68] = mem[idx + _24520 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25593 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25593 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _28999 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28999] = 30
                        mem[_28999 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _30018 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _30018 + 68] = mem[idx + _28999 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30018 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _30018 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23529 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23529] = 30
                        mem[_23529 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24519 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24519 + 68] = mem[idx + _23529 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24519 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24519 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27691 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27691] = 30
                        mem[_27691 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _28998 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28998 + 68] = mem[idx + _27691 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28998 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28998 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32384 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32384] = 30
                        mem[_32384 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33389 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33389 + 68] = mem[idx + _32384 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33389 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33389 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26449 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26449] = 30
                    mem[_26449 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27690 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27690 + 68] = mem[idx + _26449 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27690 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27690 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31230 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31230] = 30
                    mem[_31230 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32383 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32383 + 68] = mem[idx + _31230 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32383 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32383 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35074 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35074] = 30
                    mem[_35074 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35774 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35774 + 68] = mem[idx + _35074 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35774 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35774 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if 0 / stor13 / 100:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if 0 / stor13 / 100:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (0 / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19177] = 26
                        mem[_19177 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19247 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19247 + 68] = mem[idx + _19177 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19247 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19247 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20388 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20388] = 30
                                    mem[_20388 + 32] = 'SafeMath: subtraction overflow'
                                    _21607 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21607] = 30
                                    mem[_21607 + 32] = 'SafeMath: subtraction overflow'
                                    _24485 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24485] = 30
                                    mem[_24485 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25561 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25561 + 68] = mem[idx + _24485 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25561 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25561 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20387] = 30
                                    mem[_20387 + 32] = 'SafeMath: subtraction overflow'
                                    _21606 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21606] = 30
                                    mem[_21606 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22134 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22134 + 68] = mem[idx + _21606 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22134 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22134 + -mem[64] + 100
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24484 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24484] = 30
                                    mem[_24484 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25560 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25560 + 68] = mem[idx + _24484 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25560 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25560 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21165] = 30
                                mem[_21165 + 32] = 'SafeMath: subtraction overflow'
                                _23496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23496] = 30
                                mem[_23496 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24483 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24483 + 68] = mem[idx + _23496 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24483 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24483 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27648 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27648] = 30
                                mem[_27648 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28963 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28963 + 68] = mem[idx + _27648 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28963 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28963 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20386] = 30
                                    mem[_20386 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20624 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20624 + 68] = mem[idx + _20386 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20624 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20624 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21605 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21605] = 30
                                    mem[_21605 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        _22133 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22133 + 68] = mem[idx + _21605 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22133 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22133 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24482 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24482] = 30
                                    mem[_24482 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25559 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25559 + 68] = mem[idx + _24482 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25559 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25559 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21163] = 30
                                mem[_21163 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21604 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21604 + 68] = mem[idx + _21163 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21604 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21604 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23494] = 30
                                mem[_23494 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24481 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24481 + 68] = mem[idx + _23494 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24481 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24481 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27646 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27646] = 30
                                mem[_27646 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28962 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28962 + 68] = mem[idx + _27646 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28962 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28962 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21162 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21162] = 30
                                mem[_21162 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21603 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21603 + 68] = mem[idx + _21162 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21603 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21603 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23493 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23493] = 30
                                mem[_23493 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24480 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24480 + 68] = mem[idx + _23493 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24480 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24480 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27645 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27645] = 30
                                mem[_27645 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28961 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28961 + 68] = mem[idx + _27645 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28961 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28961 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22847] = 30
                            mem[_22847 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23492 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23492 + 68] = mem[idx + _22847 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23492 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23492 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26408 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26408] = 30
                            mem[_26408 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _27644 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27644 + 68] = mem[idx + _26408 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27644 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27644 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31185] = 30
                            mem[_31185 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32354 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32354 + 68] = mem[idx + _31185 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32354 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32354 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20384 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20384] = 30
                                    mem[_20384 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20623 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20623 + 68] = mem[idx + _20384 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20623 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20623 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21602 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21602] = 30
                                    mem[_21602 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22131 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22131 + 68] = mem[idx + _21602 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22131 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22131 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24479 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24479] = 30
                                    mem[_24479 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25557 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25557 + 68] = mem[idx + _24479 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25557 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25557 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21160 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21160] = 30
                                mem[_21160 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21601 + 68] = mem[idx + _21160 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21601 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21601 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23490 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23490] = 30
                                mem[_23490 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24478 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24478 + 68] = mem[idx + _23490 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24478 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24478 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27642] = 30
                                mem[_27642 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28960 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28960 + 68] = mem[idx + _27642 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28960 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28960 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21159] = 30
                                mem[_21159 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21600 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21600 + 68] = mem[idx + _21159 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21600 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21600 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23489] = 30
                                mem[_23489 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24477 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24477 + 68] = mem[idx + _23489 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24477 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24477 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27641] = 30
                                mem[_27641 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28959 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28959 + 68] = mem[idx + _27641 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28959 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28959 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22844 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22844] = 30
                            mem[_22844 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23488 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23488 + 68] = mem[idx + _22844 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23488 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23488 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26405] = 30
                            mem[_26405 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27640 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27640 + 68] = mem[idx + _26405 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27640 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27640 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31181 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31181] = 30
                            mem[_31181 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32353 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32353 + 68] = mem[idx + _31181 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32353 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32353 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21158] = 30
                                mem[_21158 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21599 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21599 + 68] = mem[idx + _21158 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21599 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21599 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23487] = 30
                                mem[_23487 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    _24476 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24476 + 68] = mem[idx + _23487 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24476 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24476 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27639 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27639] = 30
                                mem[_27639 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28958 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28958 + 68] = mem[idx + _27639 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28958 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28958 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22842 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22842] = 30
                            mem[_22842 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23486 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23486 + 68] = mem[idx + _22842 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23486 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23486 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26403] = 30
                            mem[_26403 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27638 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27638 + 68] = mem[idx + _26403 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27638 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27638 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31179 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31179] = 30
                            mem[_31179 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32352 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32352 + 68] = mem[idx + _31179 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32352 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32352 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _22841 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22841] = 30
                            mem[_22841 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23485 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23485 + 68] = mem[idx + _22841 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23485 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23485 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26402 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26402] = 30
                            mem[_26402 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27637 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27637 + 68] = mem[idx + _26402 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27637 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27637 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31178 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31178] = 30
                            mem[_31178 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32351 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32351 + 68] = mem[idx + _31178 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32351 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32351 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25553] = 30
                        mem[_25553 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26401 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26401 + 68] = mem[idx + _25553 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26401 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26401 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29985 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29985] = 30
                        mem[_29985 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31177 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31177 + 68] = mem[idx + _29985 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31177 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31177 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34321 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34321] = 30
                        mem[_34321 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35055 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35055 + 68] = mem[idx + _34321 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35055 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35055 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19216 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19216] = 30
                        mem[_19216 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19280 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19280 + 68] = mem[idx + _19216 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19280 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19280 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19609 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19609] = 30
                        mem[_19609 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19691 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19691 + 68] = mem[idx + _19609 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19691 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19691 + -mem[64] + 100
                    _19248 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19248] = 26
                    mem[_19248 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19334 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19334 + 68] = mem[idx + _19248 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19334 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19334 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20631 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20631] = 30
                                mem[_20631 + 32] = 'SafeMath: subtraction overflow'
                                _22144 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22144] = 30
                                mem[_22144 + 32] = 'SafeMath: subtraction overflow'
                                _25572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25572] = 30
                                mem[_25572 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26420 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26420 + 68] = mem[idx + _25572 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26420 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26420 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20630 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20630] = 30
                                mem[_20630 + 32] = 'SafeMath: subtraction overflow'
                                _22143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22143] = 30
                                mem[_22143 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22855 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22855 + 68] = mem[idx + _22143 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22855 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22855 + -mem[64] + 100
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25571] = 30
                                mem[_25571 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26419 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26419 + 68] = mem[idx + _25571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26419 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26419 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21616 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21616] = 30
                            mem[_21616 + 32] = 'SafeMath: subtraction overflow'
                            _24497 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24497] = 30
                            mem[_24497 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                _25570 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25570 + 68] = mem[idx + _24497 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25570 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25570 + -mem[64] + 100
                            if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28975 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28975] = 30
                            mem[_28975 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29996 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29996 + 68] = mem[idx + _28975 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29996 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29996 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20629] = 30
                                mem[_20629 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20807 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20807 + 68] = mem[idx + _20629 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20807 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20807 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22142 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22142] = 30
                                mem[_22142 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22854 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22854 + 68] = mem[idx + _22142 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22854 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22854 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25569] = 30
                                mem[_25569 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26418 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26418 + 68] = mem[idx + _25569 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26418 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26418 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21614] = 30
                            mem[_21614 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22141 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22141 + 68] = mem[idx + _21614 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22141 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22141 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24495 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24495] = 30
                            mem[_24495 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25568 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25568 + 68] = mem[idx + _24495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25568 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25568 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28973 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28973] = 30
                            mem[_28973 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29995 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29995 + 68] = mem[idx + _28973 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29995 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29995 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21613 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21613] = 30
                            mem[_21613 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22140 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22140 + 68] = mem[idx + _21613 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22140 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22140 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24494 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24494] = 30
                            mem[_24494 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25567 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25567 + 68] = mem[idx + _24494 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25567 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25567 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28972 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28972] = 30
                            mem[_28972 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29994 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29994 + 68] = mem[idx + _28972 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29994 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29994 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23504 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23504] = 30
                        mem[_23504 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24493 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24493 + 68] = mem[idx + _23504 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24493 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24493 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27659 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27659] = 30
                        mem[_27659 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _28971 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28971 + 68] = mem[idx + _27659 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28971 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28971 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32363] = 30
                        mem[_32363 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33379 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33379 + 68] = mem[idx + _32363 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33379 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33379 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20627] = 30
                                mem[_20627 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20806 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20806 + 68] = mem[idx + _20627 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20806 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20806 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22139 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22139] = 30
                                mem[_22139 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22852 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22852 + 68] = mem[idx + _22139 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22852 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22852 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25566 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25566] = 30
                                mem[_25566 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26416 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26416 + 68] = mem[idx + _25566 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26416 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26416 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21611 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21611] = 30
                            mem[_21611 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22138 + 68] = mem[idx + _21611 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22138 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22138 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24491 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24491] = 30
                            mem[_24491 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25565 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25565 + 68] = mem[idx + _24491 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25565 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25565 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28969] = 30
                            mem[_28969 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29993 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29993 + 68] = mem[idx + _28969 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29993 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29993 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21610 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21610] = 30
                            mem[_21610 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22137 + 68] = mem[idx + _21610 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22137 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22137 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24490] = 30
                            mem[_24490 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25564 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25564 + 68] = mem[idx + _24490 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25564 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25564 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28968 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28968] = 30
                            mem[_28968 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29992 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29992 + 68] = mem[idx + _28968 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29992 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29992 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23501 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23501] = 30
                        mem[_23501 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24489 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24489 + 68] = mem[idx + _23501 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24489 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24489 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27656 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27656] = 30
                        mem[_27656 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _28967 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28967 + 68] = mem[idx + _27656 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28967 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28967 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32359 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32359] = 30
                        mem[_32359 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33378 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33378 + 68] = mem[idx + _32359 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33378 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33378 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21609 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21609] = 30
                            mem[_21609 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22136 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22136 + 68] = mem[idx + _21609 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22136 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22136 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24488 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24488] = 30
                            mem[_24488 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _25563 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25563 + 68] = mem[idx + _24488 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25563 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25563 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _28966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28966] = 30
                            mem[_28966 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29991 + 68] = mem[idx + _28966 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29991 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29991 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23499 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23499] = 30
                        mem[_23499 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24487 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24487 + 68] = mem[idx + _23499 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24487 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24487 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27654 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27654] = 30
                        mem[_27654 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _28965 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28965 + 68] = mem[idx + _27654 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28965 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28965 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32357] = 30
                        mem[_32357 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33377 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33377 + 68] = mem[idx + _32357 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33377 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33377 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23498 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23498] = 30
                        mem[_23498 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24486 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24486 + 68] = mem[idx + _23498 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24486 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24486 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27653 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27653] = 30
                        mem[_27653 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _28964 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28964 + 68] = mem[idx + _27653 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28964 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28964 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32356 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32356] = 30
                        mem[_32356 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33376 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33376 + 68] = mem[idx + _32356 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33376 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33376 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26412 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26412] = 30
                    mem[_26412 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27652 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27652 + 68] = mem[idx + _26412 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27652 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27652 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31192 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31192] = 30
                    mem[_31192 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32355 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32355 + 68] = mem[idx + _31192 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32355 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32355 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35056 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35056] = 30
                    mem[_35056 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35771 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35771 + 68] = mem[idx + _35056 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35771 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35771 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * 0 / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * 0 / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (0 / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * 0 / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (0 / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
        else:
            if arg1 and _BURN_FEE > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _BURN_FEE / arg1 != _BURN_FEE:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not stor13:
                revert with 0, 'SafeMath: division by zero', 0
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if not arg1:
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if 0 / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < 0 / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19174 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19174] = 26
                        mem[_19174 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19245 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19245 + 68] = mem[idx + _19174 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19245 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19245 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not 0 / stor13 / 100:
                                        return 0
                                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20375 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20375] = 30
                                    mem[_20375 + 32] = 'SafeMath: subtraction overflow'
                                    _21583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21583] = 30
                                    mem[_21583 + 32] = 'SafeMath: subtraction overflow'
                                    _24447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24447] = 30
                                    mem[_24447 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25523 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25523 + 68] = mem[idx + _24447 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25523 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25523 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    _20374 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20374] = 30
                                    mem[_20374 + 32] = 'SafeMath: subtraction overflow'
                                    _21582 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21582] = 30
                                    mem[_21582 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22112 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22112 + 68] = mem[idx + _21582 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22112 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22112 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24446 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24446] = 30
                                    mem[_24446 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25522 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25522 + 68] = mem[idx + _24446 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25522 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25522 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21141] = 30
                                mem[_21141 + 32] = 'SafeMath: subtraction overflow'
                                _23456 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23456] = 30
                                mem[_23456 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24445 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24445 + 68] = mem[idx + _23456 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24445 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24445 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27600 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27600] = 30
                                mem[_27600 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28923 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28923 + 68] = mem[idx + _27600 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28923 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28923 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20373] = 30
                                    mem[_20373 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20615 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20615 + 68] = mem[idx + _20373 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20615 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20615 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21581 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21581] = 30
                                    mem[_21581 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        _22111 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22111 + 68] = mem[idx + _21581 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22111 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22111 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24444 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24444] = 30
                                    mem[_24444 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25521 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25521 + 68] = mem[idx + _24444 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25521 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25521 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21139 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21139] = 30
                                mem[_21139 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21580 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21580 + 68] = mem[idx + _21139 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21580 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21580 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23454 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23454] = 30
                                mem[_23454 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24443 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24443 + 68] = mem[idx + _23454 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24443 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24443 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27598 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27598] = 30
                                mem[_27598 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28922 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28922 + 68] = mem[idx + _27598 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28922 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28922 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21138 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21138] = 30
                                mem[_21138 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21579 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21579 + 68] = mem[idx + _21138 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21579 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21579 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23453] = 30
                                mem[_23453 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24442 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24442 + 68] = mem[idx + _23453 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24442 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24442 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27597 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27597] = 30
                                mem[_27597 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28921 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28921 + 68] = mem[idx + _27597 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28921 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28921 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22813 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22813] = 30
                            mem[_22813 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23452 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23452 + 68] = mem[idx + _22813 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23452 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23452 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26362 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26362] = 30
                            mem[_26362 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _27596 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27596 + 68] = mem[idx + _26362 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27596 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27596 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31135] = 30
                            mem[_31135 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32321 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32321 + 68] = mem[idx + _31135 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32321 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32321 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    _20371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20371] = 30
                                    mem[_20371 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20614 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20614 + 68] = mem[idx + _20371 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20614 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20614 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21578] = 30
                                    mem[_21578 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22109 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22109 + 68] = mem[idx + _21578 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22109 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22109 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24441] = 30
                                    mem[_24441 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25519 + 68] = mem[idx + _24441 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25519 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25519 + -mem[64] + 100
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21136 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21136] = 30
                                mem[_21136 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21577 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21577 + 68] = mem[idx + _21136 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21577 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21577 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23450 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23450] = 30
                                mem[_23450 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24440 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24440 + 68] = mem[idx + _23450 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24440 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24440 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27594 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27594] = 30
                                mem[_27594 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28920 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28920 + 68] = mem[idx + _27594 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28920 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28920 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _21135 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21135] = 30
                                mem[_21135 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21576 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21576 + 68] = mem[idx + _21135 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21576 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21576 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23449 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23449] = 30
                                mem[_23449 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24439 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24439 + 68] = mem[idx + _23449 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24439 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24439 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27593 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27593] = 30
                                mem[_27593 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28919 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28919 + 68] = mem[idx + _27593 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28919 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28919 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22810 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22810] = 30
                            mem[_22810 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23448 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23448 + 68] = mem[idx + _22810 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23448 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23448 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26359 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26359] = 30
                            mem[_26359 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27592 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27592 + 68] = mem[idx + _26359 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27592 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27592 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31131 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31131] = 30
                            mem[_31131 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32320 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32320 + 68] = mem[idx + _31131 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32320 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32320 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _21134 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21134] = 30
                                mem[_21134 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21575 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21575 + 68] = mem[idx + _21134 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21575 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21575 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23447 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23447] = 30
                                mem[_23447 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    _24438 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24438 + 68] = mem[idx + _23447 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24438 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24438 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27591 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27591] = 30
                                mem[_27591 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28918 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28918 + 68] = mem[idx + _27591 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28918 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28918 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22808 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22808] = 30
                            mem[_22808 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23446 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23446 + 68] = mem[idx + _22808 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23446 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23446 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26357 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26357] = 30
                            mem[_26357 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27590 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27590 + 68] = mem[idx + _26357 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27590 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27590 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31129] = 30
                            mem[_31129 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32319 + 68] = mem[idx + _31129 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32319 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32319 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _22807 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22807] = 30
                            mem[_22807 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23445 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23445 + 68] = mem[idx + _22807 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23445 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23445 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26356 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26356] = 30
                            mem[_26356 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27589 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27589 + 68] = mem[idx + _26356 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27589 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27589 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31128 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31128] = 30
                            mem[_31128 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32318 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32318 + 68] = mem[idx + _31128 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32318 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32318 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25515 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25515] = 30
                        mem[_25515 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26355 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26355 + 68] = mem[idx + _25515 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26355 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26355 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29951 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29951] = 30
                        mem[_29951 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31127 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31127 + 68] = mem[idx + _29951 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31127 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31127 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34279 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34279] = 30
                        mem[_34279 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35035 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35035 + 68] = mem[idx + _34279 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35035 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35035 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19214 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19214] = 30
                        mem[_19214 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19278 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19278 + 68] = mem[idx + _19214 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19278 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19278 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19606 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19606] = 30
                        mem[_19606 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19688 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19688 + 68] = mem[idx + _19606 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19688 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19688 + -mem[64] + 100
                    _19246 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19246] = 26
                    mem[_19246 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19330 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19330 + 68] = mem[idx + _19246 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19330 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19330 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    return 0
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20622] = 30
                                mem[_20622 + 32] = 'SafeMath: subtraction overflow'
                                _22122 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22122] = 30
                                mem[_22122 + 32] = 'SafeMath: subtraction overflow'
                                _25534 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25534] = 30
                                mem[_25534 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26374 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26374 + 68] = mem[idx + _25534 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26374 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26374 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                _20621 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20621] = 30
                                mem[_20621 + 32] = 'SafeMath: subtraction overflow'
                                _22121 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22121] = 30
                                mem[_22121 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22821 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22821 + 68] = mem[idx + _22121 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22821 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22821 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25533 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25533] = 30
                                mem[_25533 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26373 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26373 + 68] = mem[idx + _25533 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26373 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26373 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21592 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21592] = 30
                            mem[_21592 + 32] = 'SafeMath: subtraction overflow'
                            _24459 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24459] = 30
                            mem[_24459 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25532 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25532 + 68] = mem[idx + _24459 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25532 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25532 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28935 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28935] = 30
                            mem[_28935 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29962 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29962 + 68] = mem[idx + _28935 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29962 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29962 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20620 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20620] = 30
                                mem[_20620 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20799 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20799 + 68] = mem[idx + _20620 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20799 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20799 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22120 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22120] = 30
                                mem[_22120 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22820 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22820 + 68] = mem[idx + _22120 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22820 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22820 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25531 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25531] = 30
                                mem[_25531 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26372 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26372 + 68] = mem[idx + _25531 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26372 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26372 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21590 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21590] = 30
                            mem[_21590 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22119 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22119 + 68] = mem[idx + _21590 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22119 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22119 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24457 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24457] = 30
                            mem[_24457 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25530 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25530 + 68] = mem[idx + _24457 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25530 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25530 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28933 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28933] = 30
                            mem[_28933 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29961 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29961 + 68] = mem[idx + _28933 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29961 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29961 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21589 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21589] = 30
                            mem[_21589 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22118 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22118 + 68] = mem[idx + _21589 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22118 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22118 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24456 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24456] = 30
                            mem[_24456 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25529 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25529 + 68] = mem[idx + _24456 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25529 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25529 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28932 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28932] = 30
                            mem[_28932 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29960 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29960 + 68] = mem[idx + _28932 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29960 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29960 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23464 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23464] = 30
                        mem[_23464 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24455 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24455 + 68] = mem[idx + _23464 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24455 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24455 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27611 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27611] = 30
                        mem[_27611 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _28931 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28931 + 68] = mem[idx + _27611 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28931 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28931 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32330 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32330] = 30
                        mem[_32330 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33364 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33364 + 68] = mem[idx + _32330 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33364 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33364 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                _20618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20618] = 30
                                mem[_20618 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20798 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20798 + 68] = mem[idx + _20618 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20798 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20798 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22117] = 30
                                mem[_22117 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22818 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22818 + 68] = mem[idx + _22117 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22818 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22818 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25528 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25528] = 30
                                mem[_25528 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26370 + 68] = mem[idx + _25528 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26370 + -mem[64] + 100
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21587 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21587] = 30
                            mem[_21587 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22116 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22116 + 68] = mem[idx + _21587 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22116 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22116 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24453 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24453] = 30
                            mem[_24453 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25527 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25527 + 68] = mem[idx + _24453 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25527 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25527 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28929 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28929] = 30
                            mem[_28929 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29959 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29959 + 68] = mem[idx + _28929 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29959 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29959 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            _21586 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21586] = 30
                            mem[_21586 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22115 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22115 + 68] = mem[idx + _21586 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22115 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22115 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24452 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24452] = 30
                            mem[_24452 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25526 + 68] = mem[idx + _24452 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25526 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25526 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28928 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28928] = 30
                            mem[_28928 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29958 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29958 + 68] = mem[idx + _28928 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29958 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29958 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23461 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23461] = 30
                        mem[_23461 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24451 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24451 + 68] = mem[idx + _23461 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24451 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24451 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27608 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27608] = 30
                        mem[_27608 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _28927 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28927 + 68] = mem[idx + _27608 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28927 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28927 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32326 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32326] = 30
                        mem[_32326 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33363 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33363 + 68] = mem[idx + _32326 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33363 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33363 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            _21585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21585] = 30
                            mem[_21585 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22114 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22114 + 68] = mem[idx + _21585 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22114 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22114 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24450] = 30
                            mem[_24450 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _25525 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25525 + 68] = mem[idx + _24450 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25525 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25525 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _28926 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28926] = 30
                            mem[_28926 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29957 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29957 + 68] = mem[idx + _28926 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29957 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29957 + -mem[64] + 100
                        if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                            revert with 0, 17
                        if not 0 / stor13 / 100:
                            revert with 0, 18
                        if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23459 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23459] = 30
                        mem[_23459 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24449 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24449 + 68] = mem[idx + _23459 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24449 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24449 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27606 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27606] = 30
                        mem[_27606 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _28925 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28925 + 68] = mem[idx + _27606 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28925 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28925 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32324 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32324] = 30
                        mem[_32324 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33362 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33362 + 68] = mem[idx + _32324 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33362 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33362 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 0 / stor13 / 100:
                        _23458 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23458] = 30
                        mem[_23458 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24448 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24448 + 68] = mem[idx + _23458 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24448 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24448 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27605 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27605] = 30
                        mem[_27605 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _28924 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28924 + 68] = mem[idx + _27605 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28924 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28924 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32323 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32323] = 30
                        mem[_32323 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33361 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33361 + 68] = mem[idx + _32323 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33361 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33361 + -mem[64] + 100
                    if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                        revert with 0, 17
                    if not 0 / stor13 / 100:
                        revert with 0, 18
                    if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26366 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26366] = 30
                    mem[_26366 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27604 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27604 + 68] = mem[idx + _26366 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27604 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27604 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31142 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31142] = 30
                    mem[_31142 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32322 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32322 + 68] = mem[idx + _31142 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32322 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32322 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35036 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35036] = 30
                    mem[_35036 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35768 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35768 + 68] = mem[idx + _35036 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35768 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35768 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if 0 / stor13 / 100:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not 0 / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 0 / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                        revert with 0, 17
                                    if not 0 / stor13 / 100:
                                        revert with 0, 18
                                    if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and t / s > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * t / s / 0 / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0 / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if 0 / stor13 / 100:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 0 / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                    revert with 0, 17
                                if not 0 / stor13 / 100:
                                    revert with 0, 18
                                if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 0 / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if 0 / stor13 / 100 and stor15 / totalSupply > -1 / 0 / stor13 / 100:
                                revert with 0, 17
                            if not 0 / stor13 / 100:
                                revert with 0, 18
                            if 0 / stor13 / 100 * stor15 / totalSupply / 0 / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0 / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
            else:
                if arg1 and _CHARITY_FEE > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _CHARITY_FEE / arg1 != _CHARITY_FEE:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if not stor13:
                    revert with 0, 'SafeMath: division by zero', 0
                mem[416] = 26
                mem[448] = 'SafeMath: division by zero'
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * _TAX_FEE / stor13 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _TAX_FEE / stor13 / 100:
                    revert with 0, 17
                mem[544] = 30
                mem[576] = 'SafeMath: subtraction overflow'
                if arg1 * _BURN_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) < arg1 * _BURN_FEE / stor13 / 100:
                    revert with 0, 17
                mem[64] = 672
                mem[608] = 30
                mem[640] = 'SafeMath: subtraction overflow'
                if arg1 * _CHARITY_FEE / stor13 / 100 > arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _TAX_FEE / stor13 / 100) - (arg1 * _BURN_FEE / stor13 / 100) < arg1 * _CHARITY_FEE / stor13 / 100:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor15
                while idx < stor6.length:
                    mem[0] = stor6[idx]
                    mem[32] = 1
                    if stor1[stor6[idx]] > t:
                        _19171 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19171] = 26
                        mem[_19171 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _19243 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _19243 + 68] = mem[idx + _19171 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19243 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _19243 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        return 0
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20362 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20362] = 30
                                    mem[_20362 + 32] = 'SafeMath: subtraction overflow'
                                    _21559 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21559] = 30
                                    mem[_21559 + 32] = 'SafeMath: subtraction overflow'
                                    _24409 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24409] = 30
                                    mem[_24409 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                        if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25485 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25485 + 68] = mem[idx + _24409 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25485 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25485 + -mem[64] + 100
                                if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20361 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20361] = 30
                                    mem[_20361 + 32] = 'SafeMath: subtraction overflow'
                                    _21558 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21558] = 30
                                    mem[_21558 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _22090 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22090 + 68] = mem[idx + _21558 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22090 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22090 + -mem[64] + 100
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _24408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24408] = 30
                                    mem[_24408 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25484 + 68] = mem[idx + _24408 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25484 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25484 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21117] = 30
                                mem[_21117 + 32] = 'SafeMath: subtraction overflow'
                                _23416 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23416] = 30
                                mem[_23416 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _24407 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24407 + 68] = mem[idx + _23416 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24407 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24407 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27552 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27552] = 30
                                mem[_27552 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28883 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28883 + 68] = mem[idx + _27552 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28883 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28883 + -mem[64] + 100
                            if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20360 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20360] = 30
                                    mem[_20360 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                        _20606 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20606 + 68] = mem[idx + _20360 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20606 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20606 + -mem[64] + 100
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    _21557 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21557] = 30
                                    mem[_21557 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        _22089 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22089 + 68] = mem[idx + _21557 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22089 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22089 + -mem[64] + 100
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24406] = 30
                                    mem[_24406 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _25483 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25483 + 68] = mem[idx + _24406 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25483 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25483 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21115] = 30
                                mem[_21115 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21556 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21556 + 68] = mem[idx + _21115 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21556 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21556 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23414 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23414] = 30
                                mem[_23414 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24405 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24405 + 68] = mem[idx + _23414 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24405 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24405 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27550 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27550] = 30
                                mem[_27550 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28882 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28882 + 68] = mem[idx + _27550 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28882 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28882 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21114 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21114] = 30
                                mem[_21114 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _21555 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21555 + 68] = mem[idx + _21114 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21555 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21555 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23413 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23413] = 30
                                mem[_23413 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _24404 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24404 + 68] = mem[idx + _23413 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24404 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24404 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27549 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27549] = 30
                                mem[_27549 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _28881 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28881 + 68] = mem[idx + _27549 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28881 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28881 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22779] = 30
                            mem[_22779 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _23412 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23412 + 68] = mem[idx + _22779 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23412 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23412 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26316 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26316] = 30
                            mem[_26316 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _27548 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27548 + 68] = mem[idx + _26316 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27548 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27548 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31085 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31085] = 30
                            mem[_31085 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _32288 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32288 + 68] = mem[idx + _31085 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32288 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32288 + -mem[64] + 100
                        if arg1 and stor15 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    _20358 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20358] = 30
                                    mem[_20358 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _20605 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20605 + 68] = mem[idx + _20358 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20605 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20605 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _21554 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21554] = 30
                                    mem[_21554 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor15 / totalSupply:
                                        _22087 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22087 + 68] = mem[idx + _21554 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22087 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22087 + -mem[64] + 100
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    _24403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24403] = 30
                                    mem[_24403 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor15 / totalSupply:
                                        if arg1 * stor15 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor15 / totalSupply)
                                    _25481 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25481 + 68] = mem[idx + _24403 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25481 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25481 + -mem[64] + 100
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21112 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21112] = 30
                                mem[_21112 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21553 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21553 + 68] = mem[idx + _21112 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21553 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21553 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23410 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23410] = 30
                                mem[_23410 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _24402 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24402 + 68] = mem[idx + _23410 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24402 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24402 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _27546 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27546] = 30
                                mem[_27546 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28880 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28880 + 68] = mem[idx + _27546 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28880 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28880 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21111 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21111] = 30
                                mem[_21111 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _21552 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21552 + 68] = mem[idx + _21111 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21552 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21552 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _23409 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23409] = 30
                                mem[_23409 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _24401 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24401 + 68] = mem[idx + _23409 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24401 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24401 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _27545 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27545] = 30
                                mem[_27545 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28879 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28879 + 68] = mem[idx + _27545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28879 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28879 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22776] = 30
                            mem[_22776 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _23408 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23408 + 68] = mem[idx + _22776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23408 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23408 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _26313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26313] = 30
                            mem[_26313 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _27544 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27544 + 68] = mem[idx + _26313 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27544 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27544 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31081 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31081] = 30
                            mem[_31081 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32287 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32287 + 68] = mem[idx + _31081 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32287 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32287 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _21110 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21110] = 30
                                mem[_21110 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                    _21551 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21551 + 68] = mem[idx + _21110 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21551 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21551 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _23407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23407] = 30
                                mem[_23407 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    _24400 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24400 + 68] = mem[idx + _23407 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24400 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24400 + -mem[64] + 100
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                _27543 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27543] = 30
                                mem[_27543 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _28878 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28878 + 68] = mem[idx + _27543 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28878 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28878 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _22774 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22774] = 30
                            mem[_22774 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23406 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23406 + 68] = mem[idx + _22774 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23406 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23406 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26311 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26311] = 30
                            mem[_26311 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27542 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27542 + 68] = mem[idx + _26311 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27542 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27542 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _31079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31079] = 30
                            mem[_31079 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32286 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32286 + 68] = mem[idx + _31079 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32286 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32286 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _22773 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22773] = 30
                            mem[_22773 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _23405 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23405 + 68] = mem[idx + _22773 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23405 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23405 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _26310 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26310] = 30
                            mem[_26310 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _27541 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27541 + 68] = mem[idx + _26310 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27541 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27541 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _31078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_31078] = 30
                            mem[_31078 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _32285 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _32285 + 68] = mem[idx + _31078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32285 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _32285 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _25477 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25477] = 30
                        mem[_25477 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _26309 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26309 + 68] = mem[idx + _25477 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26309 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26309 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _29917 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_29917] = 30
                        mem[_29917 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _31077 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _31077 + 68] = mem[idx + _29917 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31077 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _31077 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _34237 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_34237] = 30
                        mem[_34237 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _35015 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _35015 + 68] = mem[idx + _34237 + 32]
                            idx = idx + 32
                            continue 
                        mem[_35015 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _35015 + -mem[64] + 100
                    if idx >= stor6.length:
                        revert with 0, 50
                    mem[0] = stor6[idx]
                    mem[32] = 2
                    if stor2[stor6[idx]] <= s:
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 1
                        _19212 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19212] = 30
                        mem[_19212 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor6[idx]] > t:
                            _19276 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19276 + 68] = mem[idx + _19212 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19276 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19276 + -mem[64] + 100
                        if t < stor1[stor6[idx]]:
                            revert with 0, 17
                        if idx >= stor6.length:
                            revert with 0, 50
                        mem[0] = stor6[idx]
                        mem[32] = 2
                        _19603 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19603] = 30
                        mem[_19603 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor6[idx]] <= s:
                            if s < stor2[stor6[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor6[idx]]
                            t = t - stor1[stor6[idx]]
                            continue 
                        _19685 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19685 + 68] = mem[idx + _19603 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19685 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19685 + -mem[64] + 100
                    _19244 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19244] = 26
                    mem[_19244 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _19326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _19326 + 68] = mem[idx + _19244 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19326 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _19326 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    return 0
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20613 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20613] = 30
                                mem[_20613 + 32] = 'SafeMath: subtraction overflow'
                                _22100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22100] = 30
                                mem[_22100 + 32] = 'SafeMath: subtraction overflow'
                                _25496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25496] = 30
                                mem[_25496 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= 0:
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26328 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26328 + 68] = mem[idx + _25496 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26328 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26328 + -mem[64] + 100
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20612] = 30
                                mem[_20612 + 32] = 'SafeMath: subtraction overflow'
                                _22099 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22099] = 30
                                mem[_22099 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _22787 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22787 + 68] = mem[idx + _22099 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22787 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22787 + -mem[64] + 100
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _25495 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25495] = 30
                                mem[_25495 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26327 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26327 + 68] = mem[idx + _25495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26327 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26327 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21568] = 30
                            mem[_21568 + 32] = 'SafeMath: subtraction overflow'
                            _24421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24421] = 30
                            mem[_24421 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _25494 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25494 + 68] = mem[idx + _24421 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25494 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25494 + -mem[64] + 100
                            if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28895 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28895] = 30
                            mem[_28895 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29928 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29928 + 68] = mem[idx + _28895 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29928 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29928 + -mem[64] + 100
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20611 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20611] = 30
                                mem[_20611 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    _20791 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20791 + 68] = mem[idx + _20611 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20791 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20791 + -mem[64] + 100
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                _22098 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22098] = 30
                                mem[_22098 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    _22786 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22786 + 68] = mem[idx + _22098 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22786 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22786 + -mem[64] + 100
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25493 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25493] = 30
                                mem[_25493 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _26326 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26326 + 68] = mem[idx + _25493 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26326 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26326 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21566 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21566] = 30
                            mem[_21566 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22097 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22097 + 68] = mem[idx + _21566 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22097 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22097 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24419 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24419] = 30
                            mem[_24419 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25492 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25492 + 68] = mem[idx + _24419 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25492 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25492 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28893] = 30
                            mem[_28893 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29927 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29927 + 68] = mem[idx + _28893 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29927 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29927 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21565] = 30
                            mem[_21565 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                _22096 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22096 + 68] = mem[idx + _21565 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22096 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22096 + -mem[64] + 100
                            if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24418 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24418] = 30
                            mem[_24418 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                _25491 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25491 + 68] = mem[idx + _24418 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25491 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25491 + -mem[64] + 100
                            if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28892 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28892] = 30
                            mem[_28892 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _29926 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29926 + 68] = mem[idx + _28892 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29926 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29926 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23424] = 30
                        mem[_23424 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                            _24417 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24417 + 68] = mem[idx + _23424 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24417 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24417 + -mem[64] + 100
                        if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27563 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27563] = 30
                        mem[_27563 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            _28891 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28891 + 68] = mem[idx + _27563 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28891 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28891 + -mem[64] + 100
                        if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32297 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32297] = 30
                        mem[_32297 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _33349 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33349 + 68] = mem[idx + _32297 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33349 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33349 + -mem[64] + 100
                    if arg1 and stor15 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                _20609 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20609] = 30
                                mem[_20609 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _20790 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20790 + 68] = mem[idx + _20609 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20790 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20790 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _22095 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22095] = 30
                                mem[_22095 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor15 / totalSupply:
                                    _22784 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22784 + 68] = mem[idx + _22095 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22784 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22784 + -mem[64] + 100
                                if arg1 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                _25490 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25490] = 30
                                mem[_25490 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor15 / totalSupply:
                                    if arg1 * stor15 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor15 / totalSupply)
                                _26324 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26324 + 68] = mem[idx + _25490 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26324 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26324 + -mem[64] + 100
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21563 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21563] = 30
                            mem[_21563 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22094 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22094 + 68] = mem[idx + _21563 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22094 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22094 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24415 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24415] = 30
                            mem[_24415 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _25489 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25489 + 68] = mem[idx + _24415 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25489 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25489 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _28889 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28889] = 30
                            mem[_28889 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= arg1 * stor15 / totalSupply:
                                if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29925 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29925 + 68] = mem[idx + _28889 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29925 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29925 + -mem[64] + 100
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21562] = 30
                            mem[_21562 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                _22093 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22093 + 68] = mem[idx + _21562 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22093 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22093 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            _24414 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24414] = 30
                            mem[_24414 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _25488 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25488 + 68] = mem[idx + _24414 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25488 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25488 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _28888 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28888] = 30
                            mem[_28888 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29924 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29924 + 68] = mem[idx + _28888 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29924 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29924 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23421 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23421] = 30
                        mem[_23421 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor15 / totalSupply:
                            _24413 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24413 + 68] = mem[idx + _23421 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24413 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24413 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < 0:
                            revert with 0, 17
                        _27560 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27560] = 30
                        mem[_27560 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _28887 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28887 + 68] = mem[idx + _27560 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28887 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28887 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32293 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32293] = 30
                        mem[_32293 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33348 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33348 + 68] = mem[idx + _32293 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33348 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33348 + -mem[64] + 100
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            _21561 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21561] = 30
                            mem[_21561 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                _22092 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22092 + 68] = mem[idx + _21561 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22092 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22092 + -mem[64] + 100
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            _24412 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24412] = 30
                            mem[_24412 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                _25487 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25487 + 68] = mem[idx + _24412 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25487 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25487 + -mem[64] + 100
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            _28886 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28886] = 30
                            mem[_28886 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor15 / totalSupply)
                            _29923 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _29923 + 68] = mem[idx + _28886 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29923 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _29923 + -mem[64] + 100
                        if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _23419 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23419] = 30
                        mem[_23419 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24411 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24411 + 68] = mem[idx + _23419 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24411 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24411 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27558 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27558] = 30
                        mem[_27558 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _28885 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28885 + 68] = mem[idx + _27558 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28885 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28885 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                            revert with 0, 17
                        _32291 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32291] = 30
                        mem[_32291 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33347 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33347 + 68] = mem[idx + _32291 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33347 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33347 + -mem[64] + 100
                    if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        _23418 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23418] = 30
                        mem[_23418 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                            _24410 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24410 + 68] = mem[idx + _23418 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24410 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24410 + -mem[64] + 100
                        if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _27557 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27557] = 30
                        mem[_27557 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                            _28884 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28884 + 68] = mem[idx + _27557 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28884 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28884 + -mem[64] + 100
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        _32290 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_32290] = 30
                        mem[_32290 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor15 / totalSupply)
                        _33346 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _33346 + 68] = mem[idx + _32290 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33346 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _33346 + -mem[64] + 100
                    if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _26320 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26320] = 30
                    mem[_26320 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                        _27556 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27556 + 68] = mem[idx + _26320 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27556 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27556 + -mem[64] + 100
                    if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _31092 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_31092] = 30
                    mem[_31092 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                        _32289 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _32289 + 68] = mem[idx + _31092 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32289 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _32289 + -mem[64] + 100
                    if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                        revert with 0, 17
                    _35016 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_35016] = 30
                    mem[_35016 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply <= (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                        if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor15 / totalSupply)
                    _35765 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _35765 + 68] = mem[idx + _35016 + 32]
                        idx = idx + 32
                        continue 
                    mem[_35765 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _35765 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor15 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _BURN_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _TAX_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _BURN_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 17
                                    if not arg1 * _CHARITY_FEE / stor13 / 100:
                                        revert with 0, 18
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _TAX_FEE / stor13 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _BURN_FEE / stor13 / 100 * t / s > -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _TAX_FEE / stor13 / 100 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                                    if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and t / s > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * t / s / arg1 * _TAX_FEE / stor13 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and t / s > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * t / s / arg1 * _BURN_FEE / stor13 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and t / s > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s / arg1 * _CHARITY_FEE / stor13 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _TAX_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) < arg1 * _BURN_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * t / s > (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _TAX_FEE / stor13 / 100 * t / s) - (arg1 * _BURN_FEE / stor13 / 100 * t / s) < arg1 * _CHARITY_FEE / stor13 / 100 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _TAX_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _BURN_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 17
                                if not arg1 * _CHARITY_FEE / stor13 / 100:
                                    revert with 0, 18
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor15 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor15 / totalSupply / arg1 != stor15 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _TAX_FEE / stor13 / 100:
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _TAX_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 17
                    if not arg1 * _TAX_FEE / stor13 / 100:
                        revert with 0, 18
                    if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _TAX_FEE / stor13 / 100 != stor15 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _BURN_FEE / stor13 / 100:
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _BURN_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 17
                        if not arg1 * _BURN_FEE / stor13 / 100:
                            revert with 0, 18
                        if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _BURN_FEE / stor13 / 100 != stor15 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _CHARITY_FEE / stor13 / 100:
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _CHARITY_FEE / stor13 / 100 and stor15 / totalSupply > -1 / arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 17
                            if not arg1 * _CHARITY_FEE / stor13 / 100:
                                revert with 0, 18
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply / arg1 * _CHARITY_FEE / stor13 / 100 != stor15 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply > arg1 * stor15 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor15 / totalSupply < arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
                            if arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply > (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor15 / totalSupply) - (arg1 * _TAX_FEE / stor13 / 100 * stor15 / totalSupply) - (arg1 * _BURN_FEE / stor13 / 100 * stor15 / totalSupply) < arg1 * _CHARITY_FEE / stor13 / 100 * stor15 / totalSupply:
                                revert with 0, 17
    return (arg1 * stor15 / totalSupply)
}



}
