contract main {




// =====================  Runtime code  =====================


#
#  - beforeTokenTransfer(address arg1, address arg2, uint256 arg3)
#  - withdrawInstantlyFrom(address arg1, uint256 arg2, address arg3, uint256 arg4)
#  - sub_cfa24007(?)
#
const VERSION = ''


uint8 stor0;
uint8 stor0; offset 8
uint256 stor0; offset 8
array of address stor1;
address owner;
uint256 stor101;
address reserveRegistryAddress;
array of struct stor152;
address prizeStrategyAddress;
uint256 maxExitFeeMantissa;
uint256 reserveTotalSupply;
uint256 liquidityCap;
uint256 awardBalance;
mapping of struct creditPlanOf;
mapping of struct stor159;
address yieldSourceAddress;
uint256 stor160;

function awardBalance() payable {
    return awardBalance
}

function liquidityCap() payable {
    return liquidityCap
}

function owner() payable {
    return owner
}

function reserveRegistry() payable {
    return reserveRegistryAddress
}

function prizeStrategy() payable {
    return prizeStrategyAddress
}

function maxExitFeeMantissa() payable {
    return maxExitFeeMantissa
}

function yieldSource() payable {
    return address(yieldSourceAddress)
}

function creditPlanOf(address arg1) payable {
    require calldata.size - 4 >= 32
    return creditPlanOf[address(arg1)].field_0, creditPlanOf[address(arg1)].field_128
}

function reserveTotalSupply() payable {
    return reserveTotalSupply
}

function _fallback() payable {
    revert
}

function canAwardExternal(address arg1) payable {
    require calldata.size - 4 >= 32
    return arg1 != address(yieldSourceAddress)
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setLiquidityCap(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    liquidityCap = arg1
    emit LiquidityCapSet(arg1);
}

function token() payable {
    require ext_code.size(address(yieldSourceAddress))
    staticcall address(yieldSourceAddress).depositToken() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[12 len 20]
}

function balance() payable {
    require ext_code.size(address(yieldSourceAddress))
    call address(yieldSourceAddress).balanceOfToken(address arg1) with:
         gas gas_remaining wei
        args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x654f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_78b3d327(?) payable {
    require calldata.size - 4 >= 32
    if stor152.length:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    idx = 0
    while idx < stor152.length:
        require idx < stor152.length
        if mem[(32 * idx) + 140 len 20] != arg1:
            idx = idx + 1
            continue 
        return 1
    return 0
}

function sub_2f7627e3(?) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > 0:
        require ext_code.size(arg1)
        call arg1.delegate(address arg1) with:
             gas gas_remaining wei
            args arg2
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function setCreditPlanOf(address arg1, uint128 arg2, uint128 arg3) payable {
    require calldata.size - 4 >= 96
    if stor152.length:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    idx = 0
    while idx < stor152.length:
        require idx < stor152.length
        if mem[(32 * idx) + 140 len 20] != arg1:
            idx = idx + 1
            continue 
        if owner != msg.sender:
            revert with 0, 'wOwnable: caller is not the owne'
        creditPlanOf[address(arg1)].field_0 = arg3
        creditPlanOf[address(arg1)].field_128 = arg2
        emit CreditPlanSet(address(arg1), arg3 << 128, arg2);
    revert with 0, 'mPrizePool/unknown-token'
}

function tokens() payable {
    if not stor152.length:
        mem[(32 * stor152.length) + 128] = 32
        mem[(32 * stor152.length) + 160] = stor152.length
        mem[(32 * stor152.length) + 192 len floor32(stor152.length)] = mem[128 len floor32(stor152.length)]
        return memory
          from (32 * stor152.length) + 128
           len (96 * stor152.length) + 64
    mem[128] = address(stor152.field_0)
    idx = 128
    s = 0
    while (32 * stor152.length) + 96 > idx:
        mem[idx + 32] = stor152[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * stor152.length) + 192 len floor32(stor152.length)] = mem[128 len floor32(stor152.length)]
    return Array(len=stor152.length, data=mem[128 len floor32(stor152.length)], mem[(32 * stor152.length) + floor32(stor152.length) + 192 len (32 * stor152.length) - floor32(stor152.length)]), 
}

function estimateCreditAccrualTime(address arg1, uint256 arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if not creditPlanOf[address(arg1)].field_128:
        return 0
    if arg2 * creditPlanOf[address(arg1)].field_128 / creditPlanOf[address(arg1)].field_128 != arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if not arg2 * creditPlanOf[address(arg1)].field_128 / 10^18:
        return 0
    if arg2 * creditPlanOf[address(arg1)].field_128 / 10^18 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require arg2 * creditPlanOf[address(arg1)].field_128 / 10^18
    return (arg3 / arg2 * creditPlanOf[address(arg1)].field_128 / 10^18)
}

function calculateReserveFee(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(reserveRegistryAddress)
    staticcall reserveRegistryAddress.lookup() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[12 len 20]:
        return 0
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0]:
        return 0
    if arg1 * ext_call.return_data[0] / ext_call.return_data[0] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    return (arg1 * ext_call.return_data[0] / 10^18)
}

function accountedBalance() payable {
    if not stor152.length:
        idx = 0
        s = reserveTotalSupply
        while idx < stor152.length:
            require idx < stor152.length
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].0x18160ddd with:
                    gas gas_remaining wei
            mem[(32 * stor152.length) + 128] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = ext_call.return_data[0] + s
            continue 
        return (reserveTotalSupply + (_21 * stor152.length))
    mem[128] = address(stor152.field_0)
    idx = 128
    s = 0
    while (32 * stor152.length) + 96 > idx:
        mem[idx + 32] = stor152[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    idx = 0
    s = reserveTotalSupply
    while idx < stor152.length:
        require idx < stor152.length
        require ext_code.size(mem[(32 * idx) + 140 len 20])
        staticcall mem[(32 * idx) + 140 len 20].0x18160ddd with:
                gas gas_remaining wei
        mem[(32 * stor152.length) + 128] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        _42 = ext_call.return_data[0]
        if ext_call.return_data[0] + s < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = ext_call.return_data[0] + s
        continue 
    return (reserveTotalSupply + (_42 * stor152.length))
}

function awardExternalERC20(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if prizeStrategyAddress != msg.sender:
        revert with 0, 'PrizePool/only-prizeStrategy'
    if arg2 == address(yieldSourceAddress):
        revert with 0, 'PrizePool/invalid-external-token'
    if arg3:
        if eth.balance(this.address) < 0:
            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
        if not ext_code.size(arg2):
            revert with 0, 'Address: call to non-contract'
        mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg1) << 64, 0, Mask(224, 32, arg3) >> 32
        call arg2 with:
             gas gas_remaining wei
            args Mask(224, 32, arg3) << 224, mem[324 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with unknown_0xa9059cbb(?????), address(arg1) << 64, 0, arg3
            if not unknown_0xa9059cbb(?????), address(arg1) << 64:
                revert with 0, 32, 42, 0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
        else:
            mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[292]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 371 len 22]
        emit AwardedExternalERC20(arg3, arg1, arg2);
}

function transferExternalERC20(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if prizeStrategyAddress != msg.sender:
        revert with 0, 'PrizePool/only-prizeStrategy'
    if arg2 == address(yieldSourceAddress):
        revert with 0, 'PrizePool/invalid-external-token'
    if arg3:
        if eth.balance(this.address) < 0:
            revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
        if not ext_code.size(arg2):
            revert with 0, 'Address: call to non-contract'
        mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg1) << 64, 0, Mask(224, 32, arg3) >> 32
        call arg2 with:
             gas gas_remaining wei
            args Mask(224, 32, arg3) << 224, mem[324 len 4]
        if not return_data.size:
            if not ext_call.success:
                revert with unknown_0xa9059cbb(?????), address(arg1) << 64, 0, arg3
            if not unknown_0xa9059cbb(?????), address(arg1) << 64:
                revert with 0, 32, 42, 0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
        else:
            mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[292]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 371 len 22]
        emit TransferredExternalERC20(arg3, arg1, arg2);
}

function withdrawReserve(address arg1) payable {
    require calldata.size - 4 >= 32
    require ext_code.size(reserveRegistryAddress)
    staticcall reserveRegistryAddress.lookup() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[12 len 20] != msg.sender:
        revert with 0, 'PrizePool/only-reserve'
    reserveTotalSupply = 0
    require ext_code.size(address(yieldSourceAddress))
    call address(yieldSourceAddress).redeemToken(uint256 arg1) with:
         gas gas_remaining wei
        args reserveTotalSupply
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(yieldSourceAddress))
    staticcall address(yieldSourceAddress).depositToken() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if eth.balance(this.address) < 0:
        revert with 0, 32, 38, 0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c, mem[366 len 26]
    if not ext_code.size(address(ext_call.return_data[0])):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), address(arg1) << 64, 0, ext_call.return_data[0 len 28]
    mem[324 len 0] = 0
    call address(ext_call.return_data[0]) with:
         gas gas_remaining wei
        args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), address(arg1) << 64, 0, ext_call.return_data[0]
        if not unknown_0xa9059cbb(?????), address(arg1) << 64:
            revert with 0, 32, 42, 0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit ReserveWithdrawal(reserveTotalSupply, arg1);
    return ext_call.return_data[0]
}

function setPrizeStrategy(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'PrizePool/prizeStrategy-not-zero'
    staticcall arg1 with:
         funct Mask(32, 224, supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000) >> 224
            gas 30000 wei
           args Mask(224, 0, supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000), mem[196 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        staticcall arg1 with:
                gas 30000 wei
               args 0xffffffff000000000000000000000000000000000000000000000000, mem[264 len 4]
        if not return_data.size:
            if ext_call.success:
                if supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            staticcall arg1 with:
                    gas 30000 wei
                   args 0xff5e34e7000000000000000000000000000000000000000000000000, mem[332 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            else:
                mem[332 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if return_data.size < 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                require return_data.size >= 32
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not mem[332 len 28], 0:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
        else:
            mem[264 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if return_data.size >= 32:
                require return_data.size >= 32
                if ext_call.success:
                    if mem[264 len 28], 0:
                        revert with 0, 'PrizePool/prizeStrategy-invalid'
            staticcall arg1 with:
                    gas 30000 wei
                   args 0xff5e34e7000000000000000000000000000000000000000000000000, mem[ceil32(return_data.size) + 333 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            else:
                mem[ceil32(return_data.size) + 333 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if return_data.size < 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                require return_data.size >= 32
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not mem[ceil32(return_data.size) + 333 len 28], 0:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
    else:
        mem[196 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if return_data.size < 32:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        require return_data.size >= 32
        if not ext_call.success:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        if not mem[196 len 28], Mask(32, 32, supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000) >> 32:
            revert with 0, 'PrizePool/prizeStrategy-invalid'
        staticcall arg1 with:
                gas 30000 wei
               args 0xffffffff000000000000000000000000000000000000000000000000, mem[ceil32(return_data.size) + 265 len 4]
        if not return_data.size:
            if ext_call.success:
                if supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            staticcall arg1 with:
                    gas 30000 wei
                   args 0xff5e34e7000000000000000000000000000000000000000000000000, mem[ceil32(return_data.size) + 333 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            else:
                mem[ceil32(return_data.size) + 333 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if return_data.size < 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                require return_data.size >= 32
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not mem[ceil32(return_data.size) + 333 len 28], 0:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
        else:
            mem[ceil32(return_data.size) + 265 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if return_data.size >= 32:
                require return_data.size >= 32
                if ext_call.success:
                    if mem[ceil32(return_data.size) + 265 len 28], 0:
                        revert with 0, 'PrizePool/prizeStrategy-invalid'
            staticcall arg1 with:
                    gas 30000 wei
                   args 0xff5e34e7000000000000000000000000000000000000000000000000, mem[(2 * ceil32(return_data.size)) + 334 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not supportsInterface(bytes4 arg1), 0x1ffc9a70000000000000000000000000000000000000000:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
            else:
                mem[(2 * ceil32(return_data.size)) + 334 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if return_data.size < 32:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                require return_data.size >= 32
                if not ext_call.success:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
                if not mem[(2 * ceil32(return_data.size)) + 334 len 28], 0:
                    revert with 0, 'PrizePool/prizeStrategy-invalid'
    prizeStrategyAddress = arg1
    emit PrizeStrategySet(arg1);
}

function captureAwardBalance() payable {
    if stor101 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor101 = 2
    if not stor152.length:
        idx = 0
        s = reserveTotalSupply
        while idx < stor152.length:
            require idx < stor152.length
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].0x18160ddd with:
                    gas gas_remaining wei
            mem[(32 * stor152.length) + 128] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = ext_call.return_data[0] + s
            continue 
        require ext_code.size(address(yieldSourceAddress))
        call address(yieldSourceAddress).balanceOfToken(address arg1) with:
             gas gas_remaining wei
            args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= reserveTotalSupply + (_122 * stor152.length):
            if 0 > awardBalance:
                if awardBalance > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if -awardBalance:
                    require ext_code.size(reserveRegistryAddress)
                    staticcall reserveRegistryAddress.lookup() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[12 len 20]:
                        if 0 < awardBalance:
                            revert with 0, 'SafeMath: addition overflow'
                        awardBalance = 0
                        emit AwardCaptured(-awardBalance);
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if 0 < awardBalance:
                                revert with 0, 'SafeMath: addition overflow'
                            awardBalance = 0
                            emit AwardCaptured(-awardBalance);
                        else:
                            if -1 * awardBalance * ext_call.return_data[0] / ext_call.return_data[0] != -awardBalance:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 229 len 31]
                            if not -1 * awardBalance * ext_call.return_data[0] / 10^18:
                                if 0 < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = 0
                                emit AwardCaptured(-awardBalance);
                            else:
                                if (-1 * awardBalance * ext_call.return_data[0] / 10^18) + reserveTotalSupply < reserveTotalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                reserveTotalSupply += -1 * awardBalance * ext_call.return_data[0] / 10^18
                                if -1 * awardBalance * ext_call.return_data[0] / 10^18 > -awardBalance:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit ReserveFeeCaptured((-1 * awardBalance * ext_call.return_data[0] / 10^18));
                                if --1 * awardBalance * ext_call.return_data[0] / 10^18 < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = --1 * awardBalance * ext_call.return_data[0] / 10^18
                                emit AwardCaptured((-awardBalance - (-1 * awardBalance * ext_call.return_data[0] / 10^18)));
        else:
            if reserveTotalSupply + (_122 * stor152.length) > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) > awardBalance:
                if awardBalance > ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length):
                    revert with 0, 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance:
                    require ext_code.size(reserveRegistryAddress)
                    staticcall reserveRegistryAddress.lookup() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[12 len 20]:
                        if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) < awardBalance:
                            revert with 0, 'SafeMath: addition overflow'
                        awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length)
                        emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance));
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) < awardBalance:
                                revert with 0, 'SafeMath: addition overflow'
                            awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length)
                            emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance));
                        else:
                            if (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / ext_call.return_data[0] != ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 229 len 31]
                            if not (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18:
                                if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length)
                                emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance));
                            else:
                                if ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18) + reserveTotalSupply < reserveTotalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                reserveTotalSupply += (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18
                                if (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18 > ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit ReserveFeeCaptured(((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18));
                                if ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18) < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18)
                                emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_122 * stor152.length) - awardBalance - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_122 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18)));
    else:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        idx = 0
        s = reserveTotalSupply
        while idx < stor152.length:
            require idx < stor152.length
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].0x18160ddd with:
                    gas gas_remaining wei
            mem[(32 * stor152.length) + 128] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            _339 = ext_call.return_data[0]
            if ext_call.return_data[0] + s < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = ext_call.return_data[0] + s
            continue 
        require ext_code.size(address(yieldSourceAddress))
        call address(yieldSourceAddress).balanceOfToken(address arg1) with:
             gas gas_remaining wei
            args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= reserveTotalSupply + (_339 * stor152.length):
            if 0 > awardBalance:
                if awardBalance > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                if -awardBalance:
                    require ext_code.size(reserveRegistryAddress)
                    staticcall reserveRegistryAddress.lookup() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not address(ext_call.return_data[0]):
                        if 0 < awardBalance:
                            revert with 0, 'SafeMath: addition overflow'
                        awardBalance = 0
                        emit AwardCaptured(-awardBalance);
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if 0 < awardBalance:
                                revert with 0, 'SafeMath: addition overflow'
                            awardBalance = 0
                            emit AwardCaptured(-awardBalance);
                        else:
                            if -1 * awardBalance * ext_call.return_data[0] / ext_call.return_data[0] != -awardBalance:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 229 len 31]
                            if not -1 * awardBalance * ext_call.return_data[0] / 10^18:
                                if 0 < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = 0
                                emit AwardCaptured(-awardBalance);
                            else:
                                if (-1 * awardBalance * ext_call.return_data[0] / 10^18) + reserveTotalSupply < reserveTotalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                reserveTotalSupply += -1 * awardBalance * ext_call.return_data[0] / 10^18
                                if -1 * awardBalance * ext_call.return_data[0] / 10^18 > -awardBalance:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit ReserveFeeCaptured((-1 * awardBalance * ext_call.return_data[0] / 10^18));
                                if --1 * awardBalance * ext_call.return_data[0] / 10^18 < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = --1 * awardBalance * ext_call.return_data[0] / 10^18
                                emit AwardCaptured((-awardBalance - (-1 * awardBalance * ext_call.return_data[0] / 10^18)));
        else:
            if reserveTotalSupply + (_339 * stor152.length) > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) > awardBalance:
                if awardBalance > ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length):
                    revert with 0, 'SafeMath: subtraction overflow'
                if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance:
                    require ext_code.size(reserveRegistryAddress)
                    staticcall reserveRegistryAddress.lookup() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not address(ext_call.return_data[0]):
                        if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) < awardBalance:
                            revert with 0, 'SafeMath: addition overflow'
                        awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length)
                        emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance));
                    else:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).reserveRateMantissa(address arg1) with:
                                gas gas_remaining wei
                               args this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) < awardBalance:
                                revert with 0, 'SafeMath: addition overflow'
                            awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length)
                            emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance));
                        else:
                            if (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / ext_call.return_data[0] != ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 229 len 31]
                            if not (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18:
                                if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length)
                                emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance));
                            else:
                                if ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18) + reserveTotalSupply < reserveTotalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                reserveTotalSupply += (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18
                                if (ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18 > ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit ReserveFeeCaptured(((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18));
                                if ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18) < awardBalance:
                                    revert with 0, 'SafeMath: addition overflow'
                                awardBalance = ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18)
                                emit AwardCaptured((ext_call.return_data[0] - reserveTotalSupply - (_339 * stor152.length) - awardBalance - ((ext_call.return_data[0] * ext_call.return_data[0]) - (reserveTotalSupply * ext_call.return_data[0]) - (_339 * stor152.length * ext_call.return_data[0]) - (awardBalance * ext_call.return_data[0]) / 10^18)));
    stor101 = 1
    return awardBalance
}

function balanceOfCredit(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if stor152.length:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    idx = 0
    while idx < stor152.length:
        require idx < stor152.length
        if mem[(32 * idx) + 140 len 20] != arg2:
            idx = idx + 1
            continue 
        require ext_code.size(arg2)
        staticcall arg2.0x70a08231 with:
                gas gas_remaining wei
               args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not stor159[address(arg2)][address(arg1)].field_224:
            if block.timestamp >= 4294967296:
                revert with 0, 
                            32,
                            38,
                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                            mem[(32 * stor152.length) + 330 len 26]
            stor159[address(arg2)][address(arg1)].field_0 = 0
            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
            stor159[address(arg2)][address(arg1)].field_224 = 1
            stor159[address(arg2)][address(arg1)].field_256 = 0
            if stor159[address(arg2)][address(arg1)].field_0 < 0:
                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
            else:
                if 0 < stor159[address(arg2)][address(arg1)].field_0:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
        else:
            if not stor159[address(arg2)][address(arg1)].field_224:
                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                if not creditPlanOf[address(arg2)].field_0:
                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                        if block.timestamp >= 4294967296:
                            revert with 0, 
                                        32,
                                        38,
                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                        mem[(32 * stor152.length) + 394 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        stor159[address(arg2)][address(arg1)].field_256 = 0
                        if stor159[address(arg2)][address(arg1)].field_0 < 0:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                    else:
                        if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                            revert with 0, 
                                        32,
                                        39,
                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                        mem[(32 * stor152.length) + 395 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 
                                        32,
                                        38,
                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                        mem[(32 * stor152.length) + 394 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(0, arg1, arg2);
                else:
                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * stor152.length) + 229 len 31]
                    if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                        if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                            revert with 0, 
                                        32,
                                        39,
                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                        mem[(32 * stor152.length) + 395 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 
                                        32,
                                        38,
                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                        mem[(32 * stor152.length) + 394 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(0, arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                            revert with 0, 
                                        32,
                                        39,
                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                        mem[(32 * stor152.length) + 395 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 
                                        32,
                                        38,
                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                        mem[(32 * stor152.length) + 394 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
            else:
                if stor159[address(arg2)][address(arg1)].field_192 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.timestamp - stor159[address(arg2)][address(arg1)].field_192:
                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not creditPlanOf[address(arg2)].field_0:
                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            stor159[address(arg2)][address(arg1)].field_256 = 0
                            if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 
                                            32,
                                            39,
                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                            mem[(32 * stor152.length) + 459 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(0, arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 
                                            32,
                                            39,
                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                            mem[(32 * stor152.length) + 459 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(0, arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                revert with 0, 
                                            32,
                                            39,
                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                            mem[(32 * stor152.length) + 459 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
                else:
                    if (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128) / block.timestamp - stor159[address(arg2)][address(arg1)].field_192 != creditPlanOf[address(arg2)].field_128:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * stor152.length) + 229 len 31]
                    if not (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128):
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                stor159[address(arg2)][address(arg1)].field_256 = 0
                                if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                                else:
                                    if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(0, arg1, arg2);
                                else:
                                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(0, arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 293 len 31]
                            if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(0, arg1, arg2);
                                else:
                                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(0, arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                                else:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
                    else:
                        if (block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128) != ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 229 len 31]
                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > 0:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                stor159[address(arg2)][address(arg1)].field_256 = 0
                                if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                                else:
                                    if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0)
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                                else:
                                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            33,
                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * stor152.length) + 293 len 31]
                            if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0)
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                                else:
                                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                    revert with 0, 
                                                32,
                                                39,
                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                mem[(32 * stor152.length) + 459 len 25]
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                                stor159[address(arg2)][address(arg1)].field_128 = 0
                                stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg2)][address(arg1)].field_224 = 1
                                if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                                else:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
        return stor159[address(arg2)][address(arg1)].field_0
    revert with 0, 'mPrizePool/unknown-token'
}

function sub_3ede50c6(?) payable {
    require calldata.size - 4 >= 96
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    if uint8(stor0.field_8):
        if not arg1:
            revert with 0, 32, 34, 0x735072697a65506f6f6c2f7265736572766552656769737472792d6e6f742d7a6572, mem[(32 * arg2.length) + 230 len 30]
        require arg2.length <= test266151307()
        mem[(32 * arg2.length) + 128] = arg2.length
        if not arg2.length:
            stor152.length = arg2.length
            if not arg2.length:
                idx = 0
                while stor152.length > idx:
                    stor152[idx].field_0 = 0
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < arg2.length:
                    require idx < arg2.length
                    _19074 = mem[(32 * idx) + 128]
                    mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                    require ext_code.size(address(_19074))
                    staticcall address(_19074).controller() with:
                            gas gas_remaining wei
                           args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                    mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[12 len 20] == this.address:
                        require idx < stor152.length
                        mem[0] = 152
                        stor152[idx].field_0 = address(_19074)
                        emit ControlledTokenAdded(address(_19074));
                        idx = idx + 1
                        continue 
                    mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[(64 * arg2.length) + 164] = 32
                    mem[(64 * arg2.length) + 196] = 30
                    mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                    revert with memory
                      from (64 * arg2.length) + 160
                       len (127 * arg2.length) + 100
            else:
                s = 0
                idx = (32 * arg2.length) + 160
                while (64 * arg2.length) + 160 > idx:
                    stor152[s].field_0 = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                while stor152.length > idx:
                    stor152[idx].field_0 = 0
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < arg2.length:
                    require idx < arg2.length
                    _28574 = mem[(32 * idx) + 128]
                    mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                    require ext_code.size(address(_28574))
                    staticcall address(_28574).controller() with:
                            gas gas_remaining wei
                           args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                    mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[12 len 20] == this.address:
                        require idx < stor152.length
                        mem[0] = 152
                        stor152[idx].field_0 = address(_28574)
                        emit ControlledTokenAdded(address(_28574));
                        idx = idx + 1
                        continue 
                    mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[(64 * arg2.length) + 164] = 32
                    mem[(64 * arg2.length) + 196] = 30
                    mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                    revert with memory
                      from (64 * arg2.length) + 160
                       len (127 * arg2.length) + 100
        else:
            mem[(32 * arg2.length) + 160 len 32 * arg2.length] = call.data[calldata.size len 32 * arg2.length]
            stor152.length = arg2.length
            if not arg2.length:
                idx = 0
                while stor152.length > idx:
                    stor152[idx].field_0 = 0
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < arg2.length:
                    require idx < arg2.length
                    _19075 = mem[(32 * idx) + 128]
                    mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                    require ext_code.size(address(_19075))
                    staticcall address(_19075).controller() with:
                            gas gas_remaining wei
                           args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                    mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[12 len 20] == this.address:
                        require idx < stor152.length
                        mem[0] = 152
                        stor152[idx].field_0 = address(_19075)
                        emit ControlledTokenAdded(address(_19075));
                        idx = idx + 1
                        continue 
                    mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[(64 * arg2.length) + 164] = 32
                    mem[(64 * arg2.length) + 196] = 30
                    mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                    revert with memory
                      from (64 * arg2.length) + 160
                       len (127 * arg2.length) + 100
            else:
                s = 0
                idx = (32 * arg2.length) + 160
                while (64 * arg2.length) + 160 > idx:
                    stor152[s].field_0 = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                while stor152.length > idx:
                    stor152[idx].field_0 = 0
                    idx = idx + 1
                    continue 
                idx = 0
                while idx < arg2.length:
                    require idx < arg2.length
                    _28575 = mem[(32 * idx) + 128]
                    mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                    require ext_code.size(address(_28575))
                    staticcall address(_28575).controller() with:
                            gas gas_remaining wei
                           args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                    mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[12 len 20] == this.address:
                        require idx < stor152.length
                        mem[0] = 152
                        stor152[idx].field_0 = address(_28575)
                        emit ControlledTokenAdded(address(_28575));
                        idx = idx + 1
                        continue 
                    mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[(64 * arg2.length) + 164] = 32
                    mem[(64 * arg2.length) + 196] = 30
                    mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                    revert with memory
                      from (64 * arg2.length) + 160
                       len (127 * arg2.length) + 100
    else:
        if not ext_code.size(this.address):
            if uint8(stor0.field_8):
                if not arg1:
                    revert with 0, 32, 34, 0x735072697a65506f6f6c2f7265736572766552656769737472792d6e6f742d7a6572, mem[(32 * arg2.length) + 230 len 30]
                require arg2.length <= test266151307()
                mem[(32 * arg2.length) + 128] = arg2.length
                if not arg2.length:
                    stor152.length = arg2.length
                    if not arg2.length:
                        idx = 0
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _19076 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_19076))
                            staticcall address(_19076).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_19076)
                                emit ControlledTokenAdded(address(_19076));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                    else:
                        s = 0
                        idx = (32 * arg2.length) + 160
                        while (64 * arg2.length) + 160 > idx:
                            stor152[s].field_0 = mem[idx + 12 len 20]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _28576 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_28576))
                            staticcall address(_28576).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_28576)
                                emit ControlledTokenAdded(address(_28576));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                else:
                    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = call.data[calldata.size len 32 * arg2.length]
                    stor152.length = arg2.length
                    if not arg2.length:
                        idx = 0
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _19077 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_19077))
                            staticcall address(_19077).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_19077)
                                emit ControlledTokenAdded(address(_19077));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                    else:
                        s = 0
                        idx = (32 * arg2.length) + 160
                        while (64 * arg2.length) + 160 > idx:
                            stor152[s].field_0 = mem[idx + 12 len 20]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _28577 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_28577))
                            staticcall address(_28577).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_28577)
                                emit ControlledTokenAdded(address(_28577));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
            else:
                uint8(stor0.field_0) = 1
                uint8(stor0.field_8) = 1
                Mask(248, 0, stor0.field_8) = 0
                if not arg1:
                    revert with 0, 32, 34, 0x735072697a65506f6f6c2f7265736572766552656769737472792d6e6f742d7a6572, mem[(32 * arg2.length) + 230 len 30]
                require arg2.length <= test266151307()
                mem[(32 * arg2.length) + 128] = arg2.length
                if not arg2.length:
                    stor152.length = arg2.length
                    if not arg2.length:
                        idx = 0
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _19078 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_19078))
                            staticcall address(_19078).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_19078)
                                emit ControlledTokenAdded(address(_19078));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                    else:
                        s = 0
                        idx = (32 * arg2.length) + 160
                        while (64 * arg2.length) + 160 > idx:
                            stor152[s].field_0 = mem[idx + 12 len 20]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _28578 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_28578))
                            staticcall address(_28578).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_28578)
                                emit ControlledTokenAdded(address(_28578));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                else:
                    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = call.data[calldata.size len 32 * arg2.length]
                    stor152.length = arg2.length
                    if not arg2.length:
                        idx = 0
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _19079 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_19079))
                            staticcall address(_19079).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_19079)
                                emit ControlledTokenAdded(address(_19079));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                    else:
                        s = 0
                        idx = (32 * arg2.length) + 160
                        while (64 * arg2.length) + 160 > idx:
                            stor152[s].field_0 = mem[idx + 12 len 20]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _28579 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_28579))
                            staticcall address(_28579).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_28579)
                                emit ControlledTokenAdded(address(_28579));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
        else:
            if uint8(stor0.field_0):
                revert with 0, 
                            32,
                            46,
                            0x6c496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65,
                            mem[(32 * arg2.length) + 242 len 18]
            if uint8(stor0.field_8):
                if not arg1:
                    revert with 0, 32, 34, 0x735072697a65506f6f6c2f7265736572766552656769737472792d6e6f742d7a6572, mem[(32 * arg2.length) + 230 len 30]
                require arg2.length <= test266151307()
                mem[(32 * arg2.length) + 128] = arg2.length
                if not arg2.length:
                    stor152.length = arg2.length
                    if not arg2.length:
                        idx = 0
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _19080 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_19080))
                            staticcall address(_19080).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_19080)
                                emit ControlledTokenAdded(address(_19080));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                    else:
                        s = 0
                        idx = (32 * arg2.length) + 160
                        while (64 * arg2.length) + 160 > idx:
                            stor152[s].field_0 = mem[idx + 12 len 20]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _28580 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_28580))
                            staticcall address(_28580).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_28580)
                                emit ControlledTokenAdded(address(_28580));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                else:
                    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = call.data[calldata.size len 32 * arg2.length]
                    stor152.length = arg2.length
                    if not arg2.length:
                        idx = 0
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _19081 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_19081))
                            staticcall address(_19081).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_19081)
                                emit ControlledTokenAdded(address(_19081));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                    else:
                        s = 0
                        idx = (32 * arg2.length) + 160
                        while (64 * arg2.length) + 160 > idx:
                            stor152[s].field_0 = mem[idx + 12 len 20]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _28581 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_28581))
                            staticcall address(_28581).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_28581)
                                emit ControlledTokenAdded(address(_28581));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
            else:
                uint8(stor0.field_0) = 1
                uint8(stor0.field_8) = 1
                Mask(248, 0, stor0.field_8) = 0
                if not arg1:
                    revert with 0, 32, 34, 0x735072697a65506f6f6c2f7265736572766552656769737472792d6e6f742d7a6572, mem[(32 * arg2.length) + 230 len 30]
                require arg2.length <= test266151307()
                mem[(32 * arg2.length) + 128] = arg2.length
                if not arg2.length:
                    stor152.length = arg2.length
                    if not arg2.length:
                        idx = 0
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _19082 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_19082))
                            staticcall address(_19082).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_19082)
                                emit ControlledTokenAdded(address(_19082));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                    else:
                        s = 0
                        idx = (32 * arg2.length) + 160
                        while (64 * arg2.length) + 160 > idx:
                            stor152[s].field_0 = mem[idx + 12 len 20]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _28582 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_28582))
                            staticcall address(_28582).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_28582)
                                emit ControlledTokenAdded(address(_28582));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                else:
                    mem[(32 * arg2.length) + 160 len 32 * arg2.length] = call.data[calldata.size len 32 * arg2.length]
                    stor152.length = arg2.length
                    if not arg2.length:
                        idx = 0
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _19083 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_19083))
                            staticcall address(_19083).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_19083)
                                emit ControlledTokenAdded(address(_19083));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
                    else:
                        s = 0
                        idx = (32 * arg2.length) + 160
                        while (64 * arg2.length) + 160 > idx:
                            stor152[s].field_0 = mem[idx + 12 len 20]
                            s = s + 1
                            idx = idx + 32
                            continue 
                        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
                        while stor152.length > idx:
                            stor152[idx].field_0 = 0
                            idx = idx + 1
                            continue 
                        idx = 0
                        while idx < arg2.length:
                            require idx < arg2.length
                            _28583 = mem[(32 * idx) + 128]
                            mem[(64 * arg2.length) + 160] = 0xf77c479100000000000000000000000000000000000000000000000000000000
                            require ext_code.size(address(_28583))
                            staticcall address(_28583).controller() with:
                                    gas gas_remaining wei
                                   args mem[(64 * arg2.length) + 164 len 127 * arg2.length]
                            mem[(64 * arg2.length) + 160] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[12 len 20] == this.address:
                                require idx < stor152.length
                                mem[0] = 152
                                stor152[idx].field_0 = address(_28583)
                                emit ControlledTokenAdded(address(_28583));
                                idx = idx + 1
                                continue 
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 30
                            mem[(64 * arg2.length) + 228] = 'PrizePool/token-ctrlr-mismatch'
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 100
    if uint8(stor0.field_8):
        owner = msg.sender
        emit OwnershipTransferred(0, msg.sender);
        stor101 = 1
        liquidityCap = -1
        mem[(64 * arg2.length) + 160] = -1
        emit LiquidityCapSet(mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 32]);
        reserveRegistryAddress = arg1
        maxExitFeeMantissa = arg3
        mem[(64 * arg2.length) + 160] = arg1
        mem[(64 * arg2.length) + 192] = arg3
        emit Initialized(address arg1, uint256 arg2):
                         mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 64],
    else:
        if ext_code.size(this.address):
            if uint8(stor0.field_0):
                mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[(64 * arg2.length) + 164] = 32
                mem[(64 * arg2.length) + 196] = 46
                mem[(64 * arg2.length) + 228 len 46] = 0x6c496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65
                revert with memory
                  from (64 * arg2.length) + 160
                   len (127 * arg2.length) + 132
        if uint8(stor0.field_8):
            owner = msg.sender
            emit OwnershipTransferred(0, msg.sender);
            stor101 = 1
            liquidityCap = -1
            mem[(64 * arg2.length) + 160] = -1
            emit LiquidityCapSet(mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 32]);
            reserveRegistryAddress = arg1
            maxExitFeeMantissa = arg3
            mem[(64 * arg2.length) + 160] = arg1
            mem[(64 * arg2.length) + 192] = arg3
            emit Initialized(address arg1, uint256 arg2):
                             mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 64],
        else:
            uint8(stor0.field_0) = 1
            uint8(stor0.field_8) = 1
            Mask(248, 0, stor0.field_8) = 0
            if ext_code.size(this.address):
                if uint8(stor0.field_0):
                    mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[(64 * arg2.length) + 164] = 32
                    mem[(64 * arg2.length) + 196] = 46
                    mem[(64 * arg2.length) + 228 len 46] = 0x6c496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65
                    revert with memory
                      from (64 * arg2.length) + 160
                       len (127 * arg2.length) + 132
            if uint8(stor0.field_8):
                owner = msg.sender
                emit OwnershipTransferred(0, msg.sender);
                stor101 = 1
                liquidityCap = -1
                mem[(64 * arg2.length) + 160] = -1
                emit LiquidityCapSet(mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 32]);
                reserveRegistryAddress = arg1
                maxExitFeeMantissa = arg3
                mem[(64 * arg2.length) + 160] = arg1
                mem[(64 * arg2.length) + 192] = arg3
                emit Initialized(address arg1, uint256 arg2):
                                 mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 64],
            else:
                uint8(stor0.field_0) = 1
                uint8(stor0.field_8) = 1
                Mask(248, 0, stor0.field_8) = 0
                uint8(stor0.field_8) = 0
                if ext_code.size(this.address):
                    if uint8(stor0.field_0):
                        mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * arg2.length) + 164] = 32
                        mem[(64 * arg2.length) + 196] = 46
                        mem[(64 * arg2.length) + 228 len 46] = 0x6c496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65
                        revert with memory
                          from (64 * arg2.length) + 160
                           len (127 * arg2.length) + 132
                if uint8(stor0.field_8):
                    owner = msg.sender
                    emit OwnershipTransferred(0, msg.sender);
                    stor101 = 1
                    liquidityCap = -1
                    mem[(64 * arg2.length) + 160] = -1
                    emit LiquidityCapSet(mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 32]);
                    reserveRegistryAddress = arg1
                    maxExitFeeMantissa = arg3
                    mem[(64 * arg2.length) + 160] = arg1
                    mem[(64 * arg2.length) + 192] = arg3
                    emit Initialized(address arg1, uint256 arg2):
                                     mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 64],
                else:
                    uint8(stor0.field_0) = 1
                    uint8(stor0.field_8) = 1
                    Mask(248, 0, stor0.field_8) = 0
                    owner = msg.sender
                    emit OwnershipTransferred(0, msg.sender);
                    uint8(stor0.field_8) = 0
                    uint8(stor0.field_8) = 0
                    if ext_code.size(this.address):
                        if uint8(stor0.field_0):
                            mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * arg2.length) + 164] = 32
                            mem[(64 * arg2.length) + 196] = 46
                            mem[(64 * arg2.length) + 228 len 46] = 0x6c496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65
                            revert with memory
                              from (64 * arg2.length) + 160
                               len (127 * arg2.length) + 132
                    if uint8(stor0.field_8):
                        stor101 = 1
                        liquidityCap = -1
                        mem[(64 * arg2.length) + 160] = -1
                        emit LiquidityCapSet(mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 32]);
                        reserveRegistryAddress = arg1
                        maxExitFeeMantissa = arg3
                        mem[(64 * arg2.length) + 160] = arg1
                        mem[(64 * arg2.length) + 192] = arg3
                        emit Initialized(address arg1, uint256 arg2):
                                         mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 64],
                    else:
                        uint8(stor0.field_0) = 1
                        uint8(stor0.field_8) = 1
                        Mask(248, 0, stor0.field_8) = 0
                        if ext_code.size(this.address):
                            if uint8(stor0.field_0):
                                mem[(64 * arg2.length) + 160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * arg2.length) + 164] = 32
                                mem[(64 * arg2.length) + 196] = 46
                                mem[(64 * arg2.length) + 228 len 46] = 0x6c496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a65
                                revert with memory
                                  from (64 * arg2.length) + 160
                                   len (127 * arg2.length) + 132
                        if uint8(stor0.field_8):
                            stor101 = 1
                            liquidityCap = -1
                            mem[(64 * arg2.length) + 160] = -1
                            emit LiquidityCapSet(mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 32]);
                            reserveRegistryAddress = arg1
                            maxExitFeeMantissa = arg3
                            mem[(64 * arg2.length) + 160] = arg1
                            mem[(64 * arg2.length) + 192] = arg3
                            emit Initialized(address arg1, uint256 arg2):
                                             mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 64],
                        else:
                            uint8(stor0.field_0) = 1
                            uint8(stor0.field_8) = 1
                            Mask(248, 0, stor0.field_8) = 0
                            stor101 = 1
                            uint8(stor0.field_8) = 0
                            uint8(stor0.field_8) = 0
                            liquidityCap = -1
                            mem[(64 * arg2.length) + 160] = -1
                            emit LiquidityCapSet(mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 32]);
                            reserveRegistryAddress = arg1
                            maxExitFeeMantissa = arg3
                            mem[(64 * arg2.length) + 160] = arg1
                            mem[(64 * arg2.length) + 192] = arg3
                            emit Initialized(address arg1, uint256 arg2):
                                             mem[(64 * arg2.length) + 160 len (127 * arg2.length) + 64],
                            uint8(stor0.field_8) = 0
}

function depositTo(address arg1, uint256 arg2, address arg3, address arg4) payable {
    require calldata.size - 4 >= 128
    if stor101 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor101 = 2
    mem[64] = (32 * stor152.length) + 128
    mem[96] = stor152.length
    if not stor152.length:
        idx = 0
        while idx < stor152.length:
            require idx < stor152.length
            if mem[(32 * idx) + 140 len 20] != arg3:
                idx = idx + 1
                continue 
            mem[(32 * stor152.length) + 128] = stor152.length
            if not stor152.length:
                idx = 0
                s = reserveTotalSupply
                while idx < stor152.length:
                    require idx < mem[(32 * stor152.length) + 128]
                    require ext_code.size(mem[(32 * idx) + (32 * stor152.length) + 172 len 20])
                    staticcall mem[(32 * idx) + (32 * stor152.length) + 172 len 20].0x18160ddd with:
                            gas gas_remaining wei
                    mem[(64 * stor152.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = ext_call.return_data[0] + s
                    continue 
                if arg2 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if arg2 + reserveTotalSupply + (_2598 * stor152.length) > liquidityCap:
                    revert with 0, 'PrizePool/exceeds-liquidity-cap'
                if prizeStrategyAddress:
                    require ext_code.size(prizeStrategyAddress)
                    call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                         gas gas_remaining wei
                        args address(arg1), arg2, address(arg3), arg4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(arg3)
                call arg3.controllerMint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).depositToken() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(64 * stor152.length) + 196] = msg.sender
                mem[(64 * stor152.length) + 228] = this.address
                mem[(64 * stor152.length) + 260] = arg2
                mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                mem[(64 * stor152.length) + 292] = 32
                if eth.balance(this.address) < 0:
                    revert with 0, 
                                32,
                                38,
                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                mem[(64 * stor152.length) + 462 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                s = (64 * stor152.length) + 192
                t = (64 * stor152.length) + 356
                idx = 100
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                     gas gas_remaining wei
                    args mem[(64 * stor152.length) + 360 len 96]
                if not return_data.size:
                    if not ext_call.success:
                        if stor152.length:
                            revert with memory
                              from 128
                               len stor152.length
                        mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * stor152.length) + 360] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeERC20: low-level call failed'
                    if stor152.length:
                        require stor152.length >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(64 * stor152.length) + 466 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).depositToken() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[(64 * stor152.length) + 478 len 10]
                    mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                    mem[(64 * stor152.length) + 424] = arg2
                    mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                    mem[(64 * stor152.length) + 456] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 626 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 388
                    t = (64 * stor152.length) + 520
                    idx = 68
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 524 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 524] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 630 len 22]
                    else:
                        mem[(64 * stor152.length) + 520] = return_data.size
                        mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 552]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                else:
                    mem[(64 * stor152.length) + 356] = return_data.size
                    mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[(64 * stor152.length) + 388]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).depositToken() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + ceil32(return_data.size) + 389
                    t = (64 * stor152.length) + ceil32(return_data.size) + 521
                    idx = 68
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                    else:
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                require ext_code.size(address(yieldSourceAddress))
                call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                     gas gas_remaining wei
                    args arg2, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
            else:
                mem[0] = 152
                mem[(32 * stor152.length) + 160] = address(stor152.field_0)
                idx = (32 * stor152.length) + 160
                s = sha3(152)
                while (64 * stor152.length) + 128 > idx:
                    mem[idx + 32] = stor1[s]
                    idx = idx + 32
                    s = s + 1
                    continue 
                idx = 0
                s = reserveTotalSupply
                while idx < stor152.length:
                    require idx < mem[(32 * stor152.length) + 128]
                    require ext_code.size(mem[(32 * idx) + (32 * stor152.length) + 172 len 20])
                    staticcall mem[(32 * idx) + (32 * stor152.length) + 172 len 20].0x18160ddd with:
                            gas gas_remaining wei
                    mem[(64 * stor152.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _9100 = ext_call.return_data[0]
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = ext_call.return_data[0] + s
                    continue 
                if arg2 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if arg2 + reserveTotalSupply + (_9100 * stor152.length) > liquidityCap:
                    revert with 0, 'PrizePool/exceeds-liquidity-cap'
                if not prizeStrategyAddress:
                    require ext_code.size(arg3)
                    call arg3.controllerMint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).depositToken() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(64 * stor152.length) + 196] = msg.sender
                    mem[(64 * stor152.length) + 228] = this.address
                    mem[(64 * stor152.length) + 260] = arg2
                    mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                    mem[(64 * stor152.length) + 292] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 462 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 192
                    t = (64 * stor152.length) + 356
                    idx = 100
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 360 len 96]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 360] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 466 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).depositToken() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + 478 len 10]
                        mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + 424] = arg2
                        mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + 456] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + 626 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + 388
                        t = (64 * stor152.length) + 520
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + 524 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + 524] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + 630 len 22]
                        else:
                            mem[(64 * stor152.length) + 520] = return_data.size
                            mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + 552]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    else:
                        mem[(64 * stor152.length) + 356] = return_data.size
                        mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            require ext_code.size(address(yieldSourceAddress))
                            staticcall address(yieldSourceAddress).depositToken() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2:
                                require ext_code.size(address(ext_call.return_data[0]))
                                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args this.address, address(yieldSourceAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0]:
                                    revert with 0, 
                                                32,
                                                54,
                                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                            if eth.balance(this.address) < 0:
                                revert with 0, 
                                            32,
                                            38,
                                            0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            s = (64 * stor152.length) + ceil32(return_data.size) + 389
                            t = (64 * stor152.length) + ceil32(return_data.size) + 521
                            idx = 68
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                            call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                 gas gas_remaining wei
                                args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    if stor152.length:
                                        revert with memory
                                          from 128
                                           len stor152.length
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if stor152.length:
                                    require stor152.length >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                            else:
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                        else:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            staticcall address(yieldSourceAddress).depositToken() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not arg2:
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 489] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                                if not ext_code.size(address(ext_call.return_data[0])):
                                    revert with 0, 'Address: call to non-contract'
                                s = (64 * stor152.length) + ceil32(return_data.size) + 389
                                t = (64 * stor152.length) + ceil32(return_data.size) + 521
                                idx = 68
                                while idx >= 32:
                                    mem[t] = mem[s]
                                    s = s + 32
                                    t = t + 32
                                    idx = idx - 32
                                    continue 
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                                call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                     gas gas_remaining wei
                                    args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if stor152.length:
                                            revert with memory
                                              from 128
                                               len stor152.length
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if stor152.length:
                                        require stor152.length >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                                    require ext_code.size(address(yieldSourceAddress))
                                    call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                         gas gas_remaining wei
                                        args arg2, this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                else:
                                    mem[64] = (64 * stor152.length) + (2 * ceil32(return_data.size)) + 522
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 558] = 32
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = 'SafeERC20: low-level call failed'
                                        idx = 32
                                        while idx < mem[(64 * stor152.length) + ceil32(return_data.size) + 457]:
                                            mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 
                                                    32,
                                                    32,
                                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
                                    require ext_code.size(address(yieldSourceAddress))
                                    call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                         gas gas_remaining wei
                                        args arg2, this.address, mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Deposited(address arg1, address arg2, address arg3, uint256 arg4, address arg5):
                                                   arg2,
                                                   address(arg4),
                                                   mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 586 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
                                                   msg.sender,
                                                   arg1,
                                                   arg3,
                            else:
                                require ext_code.size(address(ext_call.return_data[0]))
                                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args this.address, address(yieldSourceAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0]:
                                    revert with 0, 
                                                32,
                                                54,
                                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                                if not ext_code.size(address(ext_call.return_data[0])):
                                    revert with 0, 'Address: call to non-contract'
                                s = (64 * stor152.length) + ceil32(return_data.size) + 389
                                t = (64 * stor152.length) + ceil32(return_data.size) + 521
                                idx = 68
                                while idx >= 32:
                                    mem[t] = mem[s]
                                    s = s + 32
                                    t = t + 32
                                    idx = idx - 32
                                    continue 
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                                call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                     gas gas_remaining wei
                                    args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if stor152.length:
                                            revert with memory
                                              from 128
                                               len stor152.length
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if stor152.length:
                                        require stor152.length >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                                else:
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                else:
                    require ext_code.size(prizeStrategyAddress)
                    call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                         gas gas_remaining wei
                        args address(arg1), arg2, address(arg3), arg4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(arg3)
                    call arg3.controllerMint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).depositToken() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(64 * stor152.length) + 196] = msg.sender
                    mem[(64 * stor152.length) + 228] = this.address
                    mem[(64 * stor152.length) + 260] = arg2
                    mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                    mem[(64 * stor152.length) + 292] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 462 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 192
                    t = (64 * stor152.length) + 356
                    idx = 100
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 360 len 96]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 360] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 466 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).depositToken() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + 478 len 10]
                        mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + 424] = arg2
                        mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + 456] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + 626 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + 388
                        t = (64 * stor152.length) + 520
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + 524 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + 524] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + 630 len 22]
                        else:
                            mem[(64 * stor152.length) + 520] = return_data.size
                            mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + 552]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    else:
                        mem[(64 * stor152.length) + 356] = return_data.size
                        mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            require ext_code.size(address(yieldSourceAddress))
                            staticcall address(yieldSourceAddress).depositToken() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not arg2:
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                                if not ext_code.size(address(ext_call.return_data[0])):
                                    revert with 0, 'Address: call to non-contract'
                                s = (64 * stor152.length) + ceil32(return_data.size) + 389
                                t = (64 * stor152.length) + ceil32(return_data.size) + 521
                                idx = 68
                                while idx >= 32:
                                    mem[t] = mem[s]
                                    s = s + 32
                                    t = t + 32
                                    idx = idx - 32
                                    continue 
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                                call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                     gas gas_remaining wei
                                    args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if stor152.length:
                                            revert with memory
                                              from 128
                                               len stor152.length
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if stor152.length:
                                        require stor152.length >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                                else:
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            else:
                                require ext_code.size(address(ext_call.return_data[0]))
                                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args this.address, address(yieldSourceAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0]:
                                    revert with 0, 
                                                32,
                                                54,
                                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 489] = 'SafeERC20: low-level call failed'
                                if eth.balance(this.address) < 0:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                                if not ext_code.size(address(ext_call.return_data[0])):
                                    revert with 0, 'Address: call to non-contract'
                                s = (64 * stor152.length) + ceil32(return_data.size) + 389
                                t = (64 * stor152.length) + ceil32(return_data.size) + 521
                                idx = 68
                                while idx >= 32:
                                    mem[t] = mem[s]
                                    s = s + 32
                                    t = t + 32
                                    idx = idx - 32
                                    continue 
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                                call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                     gas gas_remaining wei
                                    args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                                if not return_data.size:
                                    if not ext_call.success:
                                        if stor152.length:
                                            revert with memory
                                              from 128
                                               len stor152.length
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                        idx = 32
                                        while idx < 32:
                                            mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if stor152.length:
                                        require stor152.length >= 32
                                        if not mem[128]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                                    require ext_code.size(address(yieldSourceAddress))
                                    call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                         gas gas_remaining wei
                                        args arg2, this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                                else:
                                    mem[64] = (64 * stor152.length) + (2 * ceil32(return_data.size)) + 522
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 558] = 32
                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = 'SafeERC20: low-level call failed'
                                        idx = 32
                                        while idx < mem[(64 * stor152.length) + ceil32(return_data.size) + 457]:
                                            mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 
                                                    32,
                                                    32,
                                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
                                    require ext_code.size(address(yieldSourceAddress))
                                    call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                         gas gas_remaining wei
                                        args arg2, this.address, mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    emit Deposited(address arg1, address arg2, address arg3, uint256 arg4, address arg5):
                                                   arg2,
                                                   address(arg4),
                                                   mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 586 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
                                                   msg.sender,
                                                   arg1,
                                                   arg3,
                        else:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            staticcall address(yieldSourceAddress).depositToken() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2:
                                require ext_code.size(address(ext_call.return_data[0]))
                                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args this.address, address(yieldSourceAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0]:
                                    revert with 0, 
                                                32,
                                                54,
                                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                            if eth.balance(this.address) < 0:
                                revert with 0, 
                                            32,
                                            38,
                                            0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            s = (64 * stor152.length) + ceil32(return_data.size) + 389
                            t = (64 * stor152.length) + ceil32(return_data.size) + 521
                            idx = 68
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                            call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                 gas gas_remaining wei
                                args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    if stor152.length:
                                        revert with memory
                                          from 128
                                           len stor152.length
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if stor152.length:
                                    require stor152.length >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                            else:
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
            stor101 = 1
    else:
        mem[0] = 152
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
        idx = 0
        while idx < stor152.length:
            require idx < stor152.length
            if mem[(32 * idx) + 140 len 20] != arg3:
                idx = idx + 1
                continue 
            mem[(32 * stor152.length) + 128] = stor152.length
            if not stor152.length:
                idx = 0
                s = reserveTotalSupply
                while idx < stor152.length:
                    require idx < mem[(32 * stor152.length) + 128]
                    require ext_code.size(mem[(32 * idx) + (32 * stor152.length) + 172 len 20])
                    staticcall mem[(32 * idx) + (32 * stor152.length) + 172 len 20].0x18160ddd with:
                            gas gas_remaining wei
                    mem[(64 * stor152.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _9101 = ext_call.return_data[0]
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = ext_call.return_data[0] + s
                    continue 
                if arg2 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if arg2 + reserveTotalSupply + (_9101 * stor152.length) > liquidityCap:
                    revert with 0, 'PrizePool/exceeds-liquidity-cap'
                if prizeStrategyAddress:
                    require ext_code.size(prizeStrategyAddress)
                    call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                         gas gas_remaining wei
                        args address(arg1), arg2, address(arg3), arg4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(arg3)
                call arg3.controllerMint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(address(yieldSourceAddress))
                staticcall address(yieldSourceAddress).depositToken() with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[(64 * stor152.length) + 196] = msg.sender
                mem[(64 * stor152.length) + 228] = this.address
                mem[(64 * stor152.length) + 260] = arg2
                mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                mem[(64 * stor152.length) + 292] = 32
                if eth.balance(this.address) < 0:
                    revert with 0, 
                                32,
                                38,
                                0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                mem[(64 * stor152.length) + 462 len 26]
                if not ext_code.size(address(ext_call.return_data[0])):
                    revert with 0, 'Address: call to non-contract'
                s = (64 * stor152.length) + 192
                t = (64 * stor152.length) + 356
                idx = 100
                while idx >= 32:
                    mem[t] = mem[s]
                    s = s + 32
                    t = t + 32
                    idx = idx - 32
                    continue 
                mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                     gas gas_remaining wei
                    args mem[(64 * stor152.length) + 360 len 96]
                if not return_data.size:
                    if not ext_call.success:
                        if stor152.length:
                            revert with memory
                              from 128
                               len stor152.length
                        mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * stor152.length) + 360] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeERC20: low-level call failed'
                    if stor152.length:
                        require stor152.length >= 32
                        if not mem[128]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(64 * stor152.length) + 466 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).depositToken() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[(64 * stor152.length) + 478 len 10]
                    mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                    mem[(64 * stor152.length) + 424] = arg2
                    mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                    mem[(64 * stor152.length) + 456] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 626 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 388
                    t = (64 * stor152.length) + 520
                    idx = 68
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 524 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 524] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 630 len 22]
                    else:
                        mem[(64 * stor152.length) + 520] = return_data.size
                        mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 552]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                else:
                    mem[(64 * stor152.length) + 356] = return_data.size
                    mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                        idx = 32
                        while idx < 32:
                            mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[(64 * stor152.length) + 388]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).depositToken() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2:
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                gas gas_remaining wei
                               args this.address, address(yieldSourceAddress)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0]:
                            revert with 0, 
                                        32,
                                        54,
                                        0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + ceil32(return_data.size) + 389
                    t = (64 * stor152.length) + ceil32(return_data.size) + 521
                    idx = 68
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                    else:
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                require ext_code.size(address(yieldSourceAddress))
                call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                     gas gas_remaining wei
                    args arg2, this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
            else:
                mem[0] = 152
                mem[(32 * stor152.length) + 160] = address(stor152.field_0)
                idx = (32 * stor152.length) + 160
                s = sha3(152)
                while (64 * stor152.length) + 128 > idx:
                    mem[idx + 32] = stor1[s]
                    idx = idx + 32
                    s = s + 1
                    continue 
                idx = 0
                s = reserveTotalSupply
                while idx < stor152.length:
                    require idx < mem[(32 * stor152.length) + 128]
                    require ext_code.size(mem[(32 * idx) + (32 * stor152.length) + 172 len 20])
                    staticcall mem[(32 * idx) + (32 * stor152.length) + 172 len 20].0x18160ddd with:
                            gas gas_remaining wei
                    mem[(64 * stor152.length) + 160] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    _16586 = ext_call.return_data[0]
                    if ext_call.return_data[0] + s < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = ext_call.return_data[0] + s
                    continue 
                if arg2 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if arg2 + reserveTotalSupply + (_16586 * stor152.length) > liquidityCap:
                    revert with 0, 'PrizePool/exceeds-liquidity-cap'
                if not prizeStrategyAddress:
                    require ext_code.size(arg3)
                    call arg3.controllerMint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).depositToken() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(64 * stor152.length) + 196] = msg.sender
                    mem[(64 * stor152.length) + 228] = this.address
                    mem[(64 * stor152.length) + 260] = arg2
                    mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                    mem[(64 * stor152.length) + 292] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 462 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 192
                    t = (64 * stor152.length) + 356
                    idx = 100
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 360 len 96]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 360] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 466 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).depositToken() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + 478 len 10]
                        mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + 424] = arg2
                        mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + 456] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + 626 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + 388
                        t = (64 * stor152.length) + 520
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + 524 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + 524] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + 630 len 22]
                        else:
                            mem[(64 * stor152.length) + 520] = return_data.size
                            mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + 552]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                    else:
                        mem[(64 * stor152.length) + 356] = return_data.size
                        mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).depositToken() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + ceil32(return_data.size) + 389
                        t = (64 * stor152.length) + ceil32(return_data.size) + 521
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                        else:
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                    require ext_code.size(address(yieldSourceAddress))
                    call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                         gas gas_remaining wei
                        args arg2, this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                else:
                    require ext_code.size(prizeStrategyAddress)
                    call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                         gas gas_remaining wei
                        args address(arg1), arg2, address(arg3), arg4
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(arg3)
                    call arg3.controllerMint(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), arg2
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(yieldSourceAddress))
                    staticcall address(yieldSourceAddress).depositToken() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[(64 * stor152.length) + 196] = msg.sender
                    mem[(64 * stor152.length) + 228] = this.address
                    mem[(64 * stor152.length) + 260] = arg2
                    mem[(64 * stor152.length) + 192] = 0x23b872dd00000000000000000000000000000000000000000000000000000000 or Mask(224, 32, msg.sender) >> 32
                    mem[(64 * stor152.length) + 292] = 32
                    if eth.balance(this.address) < 0:
                        revert with 0, 
                                    32,
                                    38,
                                    0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                    mem[(64 * stor152.length) + 462 len 26]
                    if not ext_code.size(address(ext_call.return_data[0])):
                        revert with 0, 'Address: call to non-contract'
                    s = (64 * stor152.length) + 192
                    t = (64 * stor152.length) + 356
                    idx = 100
                    while idx >= 32:
                        mem[t] = mem[s]
                        s = s + 32
                        t = t + 32
                        idx = idx - 32
                        continue 
                    mem[(64 * stor152.length) + 452] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 452])
                    call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 356 len 4] with:
                         gas gas_remaining wei
                        args mem[(64 * stor152.length) + 360 len 96]
                    if not return_data.size:
                        if not ext_call.success:
                            if stor152.length:
                                revert with memory
                                  from 128
                                   len stor152.length
                            mem[(64 * stor152.length) + 356] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + 360] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + 424] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if stor152.length:
                            require stor152.length >= 32
                            if not mem[128]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + 466 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        staticcall address(yieldSourceAddress).depositToken() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2:
                            require ext_code.size(address(ext_call.return_data[0]))
                            staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                    gas gas_remaining wei
                                   args this.address, address(yieldSourceAddress)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0]:
                                revert with 0, 
                                            32,
                                            54,
                                            0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                            mem[(64 * stor152.length) + 478 len 10]
                        mem[(64 * stor152.length) + 392] = address(yieldSourceAddress)
                        mem[(64 * stor152.length) + 424] = arg2
                        mem[(64 * stor152.length) + 388] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                        mem[(64 * stor152.length) + 456] = 32
                        if eth.balance(this.address) < 0:
                            revert with 0, 
                                        32,
                                        38,
                                        0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                        mem[(64 * stor152.length) + 626 len 26]
                        if not ext_code.size(address(ext_call.return_data[0])):
                            revert with 0, 'Address: call to non-contract'
                        s = (64 * stor152.length) + 388
                        t = (64 * stor152.length) + 520
                        idx = 68
                        while idx >= 32:
                            mem[t] = mem[s]
                            s = s + 32
                            t = t + 32
                            idx = idx - 32
                            continue 
                        mem[(64 * stor152.length) + 584] = 0 or Mask(224, 32, mem[(64 * stor152.length) + 584])
                        call address(ext_call.return_data[0]).mem[(64 * stor152.length) + 520 len 4] with:
                             gas gas_remaining wei
                            args mem[(64 * stor152.length) + 524 len 64]
                        if not return_data.size:
                            if not ext_call.success:
                                if stor152.length:
                                    revert with memory
                                      from 128
                                       len stor152.length
                                mem[(64 * stor152.length) + 520] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + 524] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + 588] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if stor152.length:
                                require stor152.length >= 32
                                if not mem[128]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + 630 len 22]
                        else:
                            mem[(64 * stor152.length) + 520] = return_data.size
                            mem[(64 * stor152.length) + 552 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                idx = 32
                                while idx < 32:
                                    mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + 488]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(64 * stor152.length) + 552]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                        require ext_code.size(address(yieldSourceAddress))
                        call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                             gas gas_remaining wei
                            args arg2, this.address
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                    else:
                        mem[(64 * stor152.length) + 356] = return_data.size
                        mem[(64 * stor152.length) + 388 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 357] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 361] = 32
                            idx = 32
                            while idx < 32:
                                mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 425] = mem[idx + (64 * stor152.length) + 324]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeERC20: low-level call failed'
                        if not return_data.size:
                            require ext_code.size(address(yieldSourceAddress))
                            staticcall address(yieldSourceAddress).depositToken() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2:
                                require ext_code.size(address(ext_call.return_data[0]))
                                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args this.address, address(yieldSourceAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0]:
                                    revert with 0, 
                                                32,
                                                54,
                                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 489] = 'SafeERC20: low-level call failed'
                            if eth.balance(this.address) < 0:
                                revert with 0, 
                                            32,
                                            38,
                                            0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            s = (64 * stor152.length) + ceil32(return_data.size) + 389
                            t = (64 * stor152.length) + ceil32(return_data.size) + 521
                            idx = 68
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                            call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                 gas gas_remaining wei
                                args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    if stor152.length:
                                        revert with memory
                                          from 128
                                           len stor152.length
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if stor152.length:
                                    require stor152.length >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                     gas gas_remaining wei
                                    args arg2, this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
                            else:
                                mem[64] = (64 * stor152.length) + (2 * ceil32(return_data.size)) + 522
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 558] = 32
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = 'SafeERC20: low-level call failed'
                                    idx = 32
                                    while idx < mem[(64 * stor152.length) + ceil32(return_data.size) + 457]:
                                        mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 
                                                32,
                                                32,
                                                mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 32]
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len (2 * ceil32(return_data.size)) + (-2 * ceil32(return_data.size)) + 22]
                                require ext_code.size(address(yieldSourceAddress))
                                call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                     gas gas_remaining wei
                                    args arg2, this.address, mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 590 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                emit Deposited(address arg1, address arg2, address arg3, uint256 arg4, address arg5):
                                               arg2,
                                               address(arg4),
                                               mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 586 len (2 * ceil32(return_data.size)) - (2 * ceil32(return_data.size))],
                                               msg.sender,
                                               arg1,
                                               arg3,
                        else:
                            require return_data.size >= 32
                            if not mem[(64 * stor152.length) + 388]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 467 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            staticcall address(yieldSourceAddress).depositToken() with:
                                    gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2:
                                require ext_code.size(address(ext_call.return_data[0]))
                                staticcall address(ext_call.return_data[0]).0xdd62ed3e with:
                                        gas gas_remaining wei
                                       args this.address, address(yieldSourceAddress)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if ext_call.return_data[0]:
                                    revert with 0, 
                                                32,
                                                54,
                                                0x735361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f20746f206e6f6e2d7a65726f20616c6c6f77616e63,
                                                mem[(64 * stor152.length) + ceil32(return_data.size) + 479 len 10]
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 393] = address(yieldSourceAddress)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 425] = arg2
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 389] = 0x95ea7b300000000000000000000000000000000000000000000000000000000 or Mask(224, 0, stor160)
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 457] = 32
                            if eth.balance(this.address) < 0:
                                revert with 0, 
                                            32,
                                            38,
                                            0x6f416464726573733a20696e73756666696369656e742062616c616e636520666f722063616c,
                                            mem[(64 * stor152.length) + ceil32(return_data.size) + 627 len 26]
                            if not ext_code.size(address(ext_call.return_data[0])):
                                revert with 0, 'Address: call to non-contract'
                            s = (64 * stor152.length) + ceil32(return_data.size) + 389
                            t = (64 * stor152.length) + ceil32(return_data.size) + 521
                            idx = 68
                            while idx >= 32:
                                mem[t] = mem[s]
                                s = s + 32
                                t = t + 32
                                idx = idx - 32
                                continue 
                            mem[(64 * stor152.length) + ceil32(return_data.size) + 585] = 0 or Mask(224, 32, mem[(64 * stor152.length) + ceil32(return_data.size) + 585])
                            call address(ext_call.return_data[0]).mem[(64 * stor152.length) + ceil32(return_data.size) + 521 len 4] with:
                                 gas gas_remaining wei
                                args mem[(64 * stor152.length) + ceil32(return_data.size) + 525 len 64]
                            if not return_data.size:
                                if not ext_call.success:
                                    if stor152.length:
                                        revert with memory
                                          from 128
                                           len stor152.length
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 525] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 589] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if stor152.length:
                                    require stor152.length >= 32
                                    if not mem[128]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + ceil32(return_data.size) + 631 len 22]
                            else:
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 521] = return_data.size
                                mem[(64 * stor152.length) + ceil32(return_data.size) + 553 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 522] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 526] = 32
                                    idx = 32
                                    while idx < 32:
                                        mem[idx + (64 * stor152.length) + (2 * ceil32(return_data.size)) + 590] = mem[idx + (64 * stor152.length) + ceil32(return_data.size) + 489]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(64 * stor152.length) + ceil32(return_data.size) + 553]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(64 * stor152.length) + (2 * ceil32(return_data.size)) + 632 len 22]
                            require ext_code.size(address(yieldSourceAddress))
                            call address(yieldSourceAddress).supplyTokenTo(uint256 arg1, address arg2) with:
                                 gas gas_remaining wei
                                args arg2, this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            emit Deposited(arg2, arg4, msg.sender, arg1, arg3);
            stor101 = 1
    revert with 0, 'mPrizePool/unknown-token'
}

function calculateEarlyExitFee(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require ext_code.size(arg2)
    staticcall arg2.0x70a08231 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < arg3:
        revert with 0, 'PrizePool/insuff-funds'
    if not stor159[address(arg2)][address(arg1)].field_224:
        if block.timestamp >= 4294967296:
            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[298 len 26]
        stor159[address(arg2)][address(arg1)].field_0 = 0
        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
        stor159[address(arg2)][address(arg1)].field_224 = 1
        stor159[address(arg2)][address(arg1)].field_256 = 0
        if stor159[address(arg2)][address(arg1)].field_0 < 0:
            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
        else:
            if 0 < stor159[address(arg2)][address(arg1)].field_0:
                if 0 > stor159[address(arg2)][address(arg1)].field_0:
                    revert with 0, 'SafeMath: subtraction overflow'
                emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
        if arg3 > ext_call.return_data[0]:
            revert with 0, 'SafeMath: subtraction overflow'
        if not creditPlanOf[address(arg2)].field_0:
            if not maxExitFeeMantissa:
                if 0 > stor159[address(arg2)][address(arg1)].field_0:
                    if not creditPlanOf[address(arg2)].field_0:
                        if not maxExitFeeMantissa:
                            return 0
                        if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                        if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return 0
                    else:
                        if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                        if not maxExitFeeMantissa:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                return 0
                            if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                        if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                            if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return arg3 * maxExitFeeMantissa / 10^18, 0
                    ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                else:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not creditPlanOf[address(arg2)].field_0:
                        if not maxExitFeeMantissa:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                return 0
                            return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                        if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                return 0
                            return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                    else:
                        if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                        if not maxExitFeeMantissa:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                        if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                        return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                               stor159[address(arg2)][address(arg1)].field_0
            else:
                if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]
                if 0 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                   stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                   stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
        else:
            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0] - arg3:
                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]
            if not maxExitFeeMantissa:
                if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= 0:
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                   stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                else:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                   stor159[address(arg2)][address(arg1)].field_0
            else:
                if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]
                if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                   stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                   stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
    else:
        if not stor159[address(arg2)][address(arg1)].field_224:
            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                revert with 0, 'SafeMath: addition overflow'
            if not creditPlanOf[address(arg2)].field_0:
                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                    if block.timestamp >= 4294967296:
                        revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[362 len 26]
                    stor159[address(arg2)][address(arg1)].field_0 = 0
                    stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                    stor159[address(arg2)][address(arg1)].field_224 = 1
                    stor159[address(arg2)][address(arg1)].field_256 = 0
                    if stor159[address(arg2)][address(arg1)].field_0 < 0:
                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                    else:
                        if 0 < stor159[address(arg2)][address(arg1)].field_0:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                else:
                    if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                        revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[363 len 25]
                    if block.timestamp >= 4294967296:
                        revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[362 len 26]
                    stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                    stor159[address(arg2)][address(arg1)].field_128 = 0
                    stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                    stor159[address(arg2)][address(arg1)].field_224 = 1
                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        emit CreditMinted(0, arg1, arg2);
                    else:
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditBurned(0, arg1, arg2);
            else:
                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                    if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                        revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[363 len 25]
                    if block.timestamp >= 4294967296:
                        revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[362 len 26]
                    stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                    stor159[address(arg2)][address(arg1)].field_128 = 0
                    stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                    stor159[address(arg2)][address(arg1)].field_224 = 1
                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        emit CreditMinted(0, arg1, arg2);
                    else:
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditBurned(0, arg1, arg2);
                else:
                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                        revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[363 len 25]
                    if block.timestamp >= 4294967296:
                        revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[362 len 26]
                    stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                    stor159[address(arg2)][address(arg1)].field_128 = 0
                    stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                    stor159[address(arg2)][address(arg1)].field_224 = 1
                    if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                        if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            revert with 0, 'SafeMath: subtraction overflow'
                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
            if arg3 > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if not creditPlanOf[address(arg2)].field_0:
                if not maxExitFeeMantissa:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                   stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                    if 0 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
            else:
                if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0] - arg3:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]
                if not maxExitFeeMantissa:
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= 0:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
        else:
            if stor159[address(arg2)][address(arg1)].field_192 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not block.timestamp - stor159[address(arg2)][address(arg1)].field_192:
                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                if not creditPlanOf[address(arg2)].field_0:
                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                        if block.timestamp >= 4294967296:
                            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        stor159[address(arg2)][address(arg1)].field_256 = 0
                        if stor159[address(arg2)][address(arg1)].field_0 < 0:
                            if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                    else:
                        if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                            revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(0, arg1, arg2);
                else:
                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                        if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                            revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                            if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned(0, arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                            revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                        if block.timestamp >= 4294967296:
                            revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                        stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                        stor159[address(arg2)][address(arg1)].field_128 = 0
                        stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                        stor159[address(arg2)][address(arg1)].field_224 = 1
                        if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
            else:
                if (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128) / block.timestamp - stor159[address(arg2)][address(arg1)].field_192 != creditPlanOf[address(arg2)].field_128:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if not (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128):
                    if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not creditPlanOf[address(arg2)].field_0:
                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            stor159[address(arg2)][address(arg1)].field_256 = 0
                            if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(0, arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = stor159[address(arg2)][address(arg1)].field_0
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(0, arg1, arg2);
                            else:
                                if stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(0, arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
                else:
                    if (block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg2)].field_128) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128) != ext_call.return_data[0]:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not creditPlanOf[address(arg2)].field_0:
                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > 0:
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            stor159[address(arg2)][address(arg1)].field_256 = 0
                            if stor159[address(arg2)][address(arg1)].field_0 < 0:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                            else:
                                if 0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg2)][address(arg1)].field_0, arg1, arg2);
                        else:
                            if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                            else:
                                if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                    else:
                        if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0]:
                            revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                            if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                if stor159[address(arg2)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                            else:
                                if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg2)][address(arg1)].field_0 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) - (stor159[address(arg2)][address(arg1)].field_192 * creditPlanOf[address(arg2)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg2);
                        else:
                            if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                revert with 0, 32, 39, 0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974, mem[427 len 25]
                            if block.timestamp >= 4294967296:
                                revert with 0, 32, 38, 0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400, mem[426 len 26]
                            stor159[address(arg2)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)
                            stor159[address(arg2)][address(arg1)].field_128 = 0
                            stor159[address(arg2)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg2)][address(arg1)].field_224 = 1
                            if stor159[address(arg2)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0), arg1, arg2);
                            else:
                                if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 < stor159[address(arg2)][address(arg1)].field_0:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned((stor159[address(arg2)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0 / 10^18)), arg1, arg2);
            if arg3 > ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction overflow'
            if not creditPlanOf[address(arg2)].field_0:
                if not maxExitFeeMantissa:
                    if 0 > stor159[address(arg2)][address(arg1)].field_0:
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                return 0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return 0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    return 0
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return arg3 * maxExitFeeMantissa / 10^18, 0
                        ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not creditPlanOf[address(arg2)].field_0:
                            if not maxExitFeeMantissa:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                            if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                    return 0
                                return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                        else:
                            if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                            if not maxExitFeeMantissa:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                            if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                           stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                        if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                            return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                   stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                    if 0 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
            else:
                if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / creditPlanOf[address(arg2)].field_0 != ext_call.return_data[0] - arg3:
                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[421 len 31]
                if not maxExitFeeMantissa:
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= 0:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                    else:
                        if 0 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if 0 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0, stor159[address(arg2)][address(arg1)].field_0
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                               stor159[address(arg2)][address(arg1)].field_0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0, 
                                       stor159[address(arg2)][address(arg1)].field_0
                else:
                    if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / maxExitFeeMantissa != ext_call.return_data[0] - arg3:
                        revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[485 len 31]
                    if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 <= (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18:
                        if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * creditPlanOf[address(arg2)].field_0) - (arg3 * creditPlanOf[address(arg2)].field_0) / 10^18)
                    else:
                        if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    return 0
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return 0
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        return 0
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if 0 <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return arg3 * creditPlanOf[address(arg2)].field_0 / 10^18, 0
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    return arg3 * maxExitFeeMantissa / 10^18, 0
                            ('gt', 0, ('div', ('mul', ('param', 'arg3'), ('stor', ('name', 'maxExitFeeMantissa', 154))), 1000000000000000000))
                        else:
                            if (ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18 > stor159[address(arg2)][address(arg1)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not creditPlanOf[address(arg2)].field_0:
                                if not maxExitFeeMantissa:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if 0 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                        return 0
                                    return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                           stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                            else:
                                if arg3 * creditPlanOf[address(arg2)].field_0 / creditPlanOf[address(arg2)].field_0 != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[549 len 31]
                                if not maxExitFeeMantissa:
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > 0:
                                        if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) > 0:
                                            return 0
                                        return -stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                                if arg3 * maxExitFeeMantissa / maxExitFeeMantissa != arg3:
                                    revert with 0, 32, 33, 0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[613 len 31]
                                if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 <= arg3 * maxExitFeeMantissa / 10^18:
                                    if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        return (arg3 * creditPlanOf[address(arg2)].field_0 / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                               stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
                                    if arg3 * creditPlanOf[address(arg2)].field_0 / 10^18 > arg3 * creditPlanOf[address(arg2)].field_0 / 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    return 0, arg3 * creditPlanOf[address(arg2)].field_0 / 10^18
                            if stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18) <= arg3 * maxExitFeeMantissa / 10^18:
                                return (arg3 * maxExitFeeMantissa / 10^18) - stor159[address(arg2)][address(arg1)].field_0 + ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18), 
                                       stor159[address(arg2)][address(arg1)].field_0 - ((ext_call.return_data[0] * maxExitFeeMantissa) - (arg3 * maxExitFeeMantissa) / 10^18)
    if arg3 * maxExitFeeMantissa / 10^18 > arg3 * maxExitFeeMantissa / 10^18:
        revert with 0, 'SafeMath: subtraction overflow'
    return 0, arg3 * maxExitFeeMantissa / 10^18
}

function award(address arg1, uint256 arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    if prizeStrategyAddress != msg.sender:
        revert with 0, 'PrizePool/only-prizeStrategy'
    if stor152.length:
        mem[128] = address(stor152.field_0)
        idx = 128
        s = 0
        while (32 * stor152.length) + 96 > idx:
            mem[idx + 32] = stor152[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    idx = 0
    while idx < stor152.length:
        require idx < stor152.length
        if mem[(32 * idx) + 140 len 20] != arg3:
            idx = idx + 1
            continue 
        if arg2:
            if arg2 > awardBalance:
                revert with 0, 'PrizePool/award-exceeds-avail'
            awardBalance -= arg2
            if not prizeStrategyAddress:
                require ext_code.size(arg3)
                call arg3.controllerMint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not creditPlanOf[address(arg3)].field_0:
                    if not maxExitFeeMantissa:
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not stor159[address(arg3)][address(arg1)].field_224:
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg3)][address(arg1)].field_0 = 0
                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg3)][address(arg1)].field_224 = 1
                            stor159[address(arg3)][address(arg1)].field_256 = 0
                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not creditPlanOf[address(arg3)].field_0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        stor159[address(arg3)][address(arg1)].field_256 = 0
                                        if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                    else:
                                        if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(0, arg1, arg3);
                                else:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * stor152.length) + 357 len 31]
                                    if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                        if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                            else:
                                if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 421 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * stor152.length) + 357 len 31]
                                    if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                    else:
                        if arg2 * maxExitFeeMantissa / maxExitFeeMantissa != arg2:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0 <= arg2 * maxExitFeeMantissa / 10^18:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * maxExitFeeMantissa / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                else:
                    if arg2 * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != arg2:
                        revert with 0, 
                                    32,
                                    33,
                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * stor152.length) + 229 len 31]
                    if not maxExitFeeMantissa:
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 > 0:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                    else:
                        if arg2 * maxExitFeeMantissa / maxExitFeeMantissa != arg2:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 <= arg2 * maxExitFeeMantissa / 10^18:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * maxExitFeeMantissa / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
            else:
                require ext_code.size(prizeStrategyAddress)
                call prizeStrategyAddress.beforeTokenMint(address arg1, uint256 arg2, address arg3, address arg4) with:
                     gas gas_remaining wei
                    args address(arg1), arg2, address(arg3), 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require ext_code.size(arg3)
                call arg3.controllerMint(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg1), arg2
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not creditPlanOf[address(arg3)].field_0:
                    if not maxExitFeeMantissa:
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not stor159[address(arg3)][address(arg1)].field_224:
                            if block.timestamp >= 4294967296:
                                revert with 0, 
                                            32,
                                            38,
                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                            mem[(32 * stor152.length) + 458 len 26]
                            stor159[address(arg3)][address(arg1)].field_0 = 0
                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                            stor159[address(arg3)][address(arg1)].field_224 = 1
                            stor159[address(arg3)][address(arg1)].field_256 = 0
                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not creditPlanOf[address(arg3)].field_0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        stor159[address(arg3)][address(arg1)].field_256 = 0
                                        if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                    else:
                                        if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(0, arg1, arg3);
                                else:
                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * stor152.length) + 357 len 31]
                                    if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                        if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                            revert with 0, 
                                                        32,
                                                        39,
                                                        0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                        mem[(32 * stor152.length) + 523 len 25]
                                        if block.timestamp >= 4294967296:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                        mem[(32 * stor152.length) + 522 len 26]
                                        stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                        stor159[address(arg3)][address(arg1)].field_128 = 0
                                        stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                        stor159[address(arg3)][address(arg1)].field_224 = 1
                                        if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                            else:
                                if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 421 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 587 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 586 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * stor152.length) + 357 len 31]
                                    if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                    else:
                        if arg2 * maxExitFeeMantissa / maxExitFeeMantissa != arg2:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if 0 <= arg2 * maxExitFeeMantissa / 10^18:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * maxExitFeeMantissa / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                else:
                    if arg2 * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != arg2:
                        revert with 0, 'dSafeMath: multiplication overflo'
                    if not maxExitFeeMantissa:
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 > 0:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = stor159[address(arg3)][address(arg1)].field_0
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(0, arg1, arg3);
                                                    else:
                                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(0, arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                    else:
                                                        if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                    else:
                        if arg2 * maxExitFeeMantissa / maxExitFeeMantissa != arg2:
                            revert with 0, 
                                        32,
                                        33,
                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * stor152.length) + 293 len 31]
                        require ext_code.size(arg3)
                        staticcall arg3.0x70a08231 with:
                                gas gas_remaining wei
                               args arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 <= arg2 * maxExitFeeMantissa / 10^18:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * creditPlanOf[address(arg3)].field_0 / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * creditPlanOf[address(arg3)].field_0 / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                        else:
                            if not stor159[address(arg3)][address(arg1)].field_224:
                                if block.timestamp >= 4294967296:
                                    revert with 0, 
                                                32,
                                                38,
                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                mem[(32 * stor152.length) + 458 len 26]
                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                else:
                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                            else:
                                if not stor159[address(arg3)][address(arg1)].field_224:
                                    if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not creditPlanOf[address(arg3)].field_0:
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            stor159[address(arg3)][address(arg1)].field_256 = 0
                                            if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                        else:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                    else:
                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                revert with 0, 
                                                            32,
                                                            39,
                                                            0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                            mem[(32 * stor152.length) + 523 len 25]
                                            if block.timestamp >= 4294967296:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                            mem[(32 * stor152.length) + 522 len 26]
                                            stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                            stor159[address(arg3)][address(arg1)].field_128 = 0
                                            stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                            stor159[address(arg3)][address(arg1)].field_224 = 1
                                            if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    revert with 0, 'SafeMath: subtraction overflow'
                                                emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                else:
                                    if stor159[address(arg3)][address(arg1)].field_192 > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if not block.timestamp - stor159[address(arg3)][address(arg1)].field_192:
                                        if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not creditPlanOf[address(arg3)].field_0:
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                stor159[address(arg3)][address(arg1)].field_256 = 0
                                                if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                            else:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                        else:
                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 421 len 31]
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                    revert with 0, 
                                                                32,
                                                                39,
                                                                0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                mem[(32 * stor152.length) + 587 len 25]
                                                if block.timestamp >= 4294967296:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                mem[(32 * stor152.length) + 586 len 26]
                                                stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                stor159[address(arg3)][address(arg1)].field_128 = 0
                                                stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                stor159[address(arg3)][address(arg1)].field_224 = 1
                                                if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        revert with 0, 'SafeMath: subtraction overflow'
                                                    emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                    else:
                                        if (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) / block.timestamp - stor159[address(arg3)][address(arg1)].field_192 != creditPlanOf[address(arg3)].field_128:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * stor152.length) + 357 len 31]
                                        if not (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128):
                                            if stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted((arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(-(arg2 * maxExitFeeMantissa / 10^18), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
                                        else:
                                            if (block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / (block.timestamp * creditPlanOf[address(arg3)].field_128) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128) != ext_call.return_data[0]:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * stor152.length) + 357 len 31]
                                            if ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if arg2 * maxExitFeeMantissa / 10^18 < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not creditPlanOf[address(arg3)].field_0:
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    stor159[address(arg3)][address(arg1)].field_256 = 0
                                                    if stor159[address(arg3)][address(arg1)].field_0 < 0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > 0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(-stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                    else:
                                                        if 0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if 0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned(stor159[address(arg3)][address(arg1)].field_0, arg1, arg3);
                                                else:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                            else:
                                                if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / creditPlanOf[address(arg3)].field_0 != ext_call.return_data[0]:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x64536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * stor152.length) + 421 len 31]
                                                if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 <= ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                    if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                    else:
                                                        if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if (arg2 * maxExitFeeMantissa / 10^18) + ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18) + stor159[address(arg3)][address(arg1)].field_0 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((-(arg2 * maxExitFeeMantissa / 10^18) - ((block.timestamp * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) - (stor159[address(arg3)][address(arg1)].field_192 * creditPlanOf[address(arg3)].field_128 * ext_call.return_data[0]) / 10^18)), arg1, arg3);
                                                else:
                                                    if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 >= 0x100000000000000000000000000000000:
                                                        revert with 0, 
                                                                    32,
                                                                    39,
                                                                    0x7353616665436173743a2076616c756520646f65736e27742066697420696e2031323820626974,
                                                                    mem[(32 * stor152.length) + 587 len 25]
                                                    if block.timestamp >= 4294967296:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0x53616665436173743a2076616c756520646f65736e27742066697420696e2033322062697400,
                                                                    mem[(32 * stor152.length) + 586 len 26]
                                                    stor159[address(arg3)][address(arg1)].field_0 = uint128(ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)
                                                    stor159[address(arg3)][address(arg1)].field_128 = 0
                                                    stor159[address(arg3)][address(arg1)].field_192 = uint32(block.timestamp)
                                                    stor159[address(arg3)][address(arg1)].field_224 = 1
                                                    if stor159[address(arg3)][address(arg1)].field_0 < ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                        if stor159[address(arg3)][address(arg1)].field_0 > ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18:
                                                            revert with 0, 'SafeMath: subtraction overflow'
                                                        emit CreditMinted(((ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18) - stor159[address(arg3)][address(arg1)].field_0), arg1, arg3);
                                                    else:
                                                        if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 < stor159[address(arg3)][address(arg1)].field_0:
                                                            if ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18 > stor159[address(arg3)][address(arg1)].field_0:
                                                                revert with 0, 'SafeMath: subtraction overflow'
                                                            emit CreditBurned((stor159[address(arg3)][address(arg1)].field_0 - (ext_call.return_data[0] * creditPlanOf[address(arg3)].field_0 / 10^18)), arg1, arg3);
            emit Awarded(arg2, arg1, arg3);
    revert with 0, 'mPrizePool/unknown-token'
}



}
