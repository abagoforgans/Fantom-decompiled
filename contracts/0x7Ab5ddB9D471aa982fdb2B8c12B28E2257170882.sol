contract main {




// =====================  Runtime code  =====================


#
#  - elevateDeposit(uint8 arg1, uint256 arg2, uint8 arg3, address arg4)
#  - rollover(uint8 arg1)
#  - withdraw(uint8 arg1, uint256 arg2, address arg3)
#  - deposit(uint8 arg1, uint256 arg2, uint8 arg3, address arg4)
#  - switchTotem(uint8 arg1, uint8 arg2, address arg3)
#  - elevateWithdraw(uint8 arg1, uint256 arg2, address arg3)
#
bool stor0; offset 256
uint8 stor0; offset 160
uint8 stor0; offset 168
uint128 stor0; offset 168
address owner;
uint256 stor1;
mapping of struct stor10;
mapping of uint8 stor11;
address stor2;
address stor3;
array of uint8 stor4;
mapping of uint8 stor5;
mapping of struct depositFee;
mapping of struct sub_76fa17d2;
mapping of uint8 selectedTotem;
mapping of struct sub_057a3048;

function selectedTotem(uint8 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return selectedTotem[address(arg2)][arg1 << 248]
}

function sub_057a3048(?) payable {
    require calldata.size - 4 >= 64
    return sub_057a3048[arg1][arg2].field_0, sub_057a3048[arg1][arg2].field_256, sub_057a3048[arg1][arg2].field_512
}

function depositFee(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    return depositFee[arg1 << 248].field_1280
}

function lpToken(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    return depositFee[arg1 << 248].field_16
}

function userTotem(address arg1, uint8 arg2) payable {
    require calldata.size - 4 >= 64
    return selectedTotem[arg1][arg2]
}

function sub_2cefc965(?) payable {
    require calldata.size - 4 >= 64
    require arg2 < stor10[arg1].field_0
    return sub_2cefc965[uint8(arg2)]
}

function sub_4290bebf(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < stor4.length
    return sub_4290bebf[uint8(arg1)]
}

function isLive(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    return bool(depositFee[arg1 << 248].field_512)
}

function sub_63a21bf4(?) payable {
    require calldata.size - 4 >= 32
    return depositFee[arg1].field_0, 
           bool(depositFee[arg1].field_8),
           depositFee[arg1].field_0,
           depositFee[arg1].field_256,
           bool(depositFee[arg1].field_512),
           depositFee[arg1].field_768,
           depositFee[arg1].field_1024,
           depositFee[arg1].field_1280,
           depositFee[arg1].field_1280,
           depositFee[arg1].field_1792,
           depositFee[arg1].field_2304,
           depositFee[arg1].field_2560
}

function sub_76fa17d2(?) payable {
    require calldata.size - 4 >= 64
    return sub_76fa17d2[arg1][arg2].field_0, 
           sub_76fa17d2[arg1][arg2].field_256,
           sub_76fa17d2[arg1][arg2].field_512,
           sub_76fa17d2[arg1][arg2].field_768,
           sub_76fa17d2[arg1][arg2].field_1024,
           sub_76fa17d2[arg1][arg2].field_1280,
           sub_76fa17d2[arg1][arg2].field_1536
}

function owner() payable {
    return owner
}

function lpSupply(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    return depositFee[arg1 << 248].field_256
}

function sub_e4be798b(?) payable {
    require calldata.size - 4 >= 32
    return bool(stor5[arg1])
}

function sub_faab07b1(?) payable {
    require calldata.size - 4 >= 64
    return bool(stor11[arg1][arg2])
}

function _fallback() payable {
    revert
}

function enable(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
}

function sub_6ccfed7d(?) payable {
    require calldata.size - 4 >= 160
    if stor2 != msg.sender:
        revert with 0, 'rOnly cartographer'
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061646472657300,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function isTotemInUse(uint8 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    idx = 0
    while uint8(idx) < stor10[arg1 << 248].field_0:
        require uint8(idx) < stor10[arg1 << 248].field_0
        if depositFee[stor10[arg1 << 248][uint8(idx) / 32].field_(8 * idx % 32) - 248].field_8:
            require uint8(idx) < stor10[arg1 << 248].field_0
            if sub_76fa17d2[stor10[arg1 << 248][uint8(idx) / 32].field_(8 * idx % 32) - 248][address(arg2)].field_256 > 0:
                return 1
        mem[0] = arg1
        mem[32] = 10
        idx = idx + 1
        continue 
    return 0
}

function disablePassthrough(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if depositFee[arg1 << 248].field_2560:
        require ext_code.size(stor2)
        call stor2.0x9e403ea7 with:
             gas gas_remaining wei
            args depositFee[arg1 << 248].field_256, depositFee[arg1 << 248].field_2560
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        depositFee[arg1 << 248].field_2560 = 0
}

function initialize(address arg1) payable {
    require calldata.size - 4 >= 32
    if not uint8(stor0.field_168):
        if ext_code.size(this.address):
            if uint8(stor0.field_160):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            46,
                            0x496e697469616c697a61626c653a20636f6e747261637420697320616c726561647920696e697469616c697a6500,
                            mem[210 len 18]
        if not uint8(stor0.field_168):
            uint8(stor0.field_160) = 1
            uint8(stor0.field_168) = 1
            Mask(88, 0, stor0.field_168) = 0
            stor0.field_256 % 1 = 0
    if stor2 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not arg1:
        revert with 0, 'Contract is zero'
    stor3 = arg1
    if not uint8(stor0.field_168):
        uint8(stor0.field_168) = 0
}

function setPassthrough(uint8 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if not arg2:
        revert with 0, 'Passthrough info required'
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if depositFee[arg1 << 248].field_2560:
        require ext_code.size(stor2)
        call stor2.0x9e403ea7 with:
             gas gas_remaining wei
            args depositFee[arg1 << 248].field_256, depositFee[arg1 << 248].field_2560
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        depositFee[arg1 << 248].field_2560 = 0
    depositFee[arg1 << 248].field_2560 = arg2
    require ext_code.size(stor2)
    call stor2.0xce45d3ab with:
         gas gas_remaining wei
        args arg2, depositFee[arg1 << 248].field_0, depositFee[arg1 << 248].field_256
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function set(uint8 arg1, bool arg2, uint16 arg3, bool arg4) payable {
    require calldata.size - 4 >= 128
    if stor2 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if arg3 > 400:
        revert with 0, 'Invalid deposit fee'
    if arg4:
        require ext_code.size(stor2)
        call stor2.0x630b5ba1 with:
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    if arg2 != bool(depositFee[arg1 << 248].field_512):
        require ext_code.size(stor2)
        if not arg2:
            call stor2.0xafd63673 with:
                 gas gas_remaining wei
                args depositFee[arg1 << 248].field_0, depositFee[arg1 << 248].field_1296
        else:
            call stor2.0xa693e013 with:
                 gas gas_remaining wei
                args depositFee[arg1 << 248].field_0, depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    depositFee[arg1 << 248].field_512 = uint8(arg2)
    depositFee[arg1 << 248].field_1280 = arg3
}

function validateElevate(uint8 arg1, address arg2, uint256 arg3, uint8 arg4, address arg5) payable {
    require calldata.size - 4 >= 160
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    if stor2 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if not depositFee[arg1 << 248].field_8:
        revert with 0, 'Pool not available yet'
    require ext_code.size(stor3)
    staticcall stor3.0xc416fa18 with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if arg4 >= ext_call.return_data[31 len 1]:
        revert with 0, 'Invalid totem'
    require ext_code.size(stor3)
    staticcall stor3.getElevationLockedUntilRollover(uint8 arg1) with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'sElev locked until rollover'
    idx = 0
    while uint8(idx) < stor10[stor6[arg1 << 248].field_1280].field_0:
        require uint8(idx) < stor10[stor6[arg1 << 248].field_1280].field_0
        if not depositFee[stor10[depositFee[arg1 << 248].field_1280][uint8(idx) / 32].field_(8 * idx % 32) - 248].field_8:
            mem[0] = depositFee[arg1 << 248].field_1296
            mem[32] = 10
            idx = idx + 1
            continue 
        require uint8(idx) < stor10[stor6[arg1 << 248].field_1280].field_0
        if sub_76fa17d2[stor10[stor6[arg1 << 248].field_1280][uint8(idx) / 32].field_(8 * idx % 32) - 248][address(arg5)].field_256 <= 0:
            mem[0] = depositFee[arg1 << 248].field_1296
            mem[32] = 10
            idx = idx + 1
            continue 
        if arg4 != selectedTotem[address(arg5)][stor6[arg1 << 248].field_1280]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x6443616e742073776974636820746f74656d20647572696e67207472616e736665,
                        mem[197 len 31]
        if depositFee[arg1 << 248].field_16 != arg2:
            revert with 0, 'Different lpToken'
        if arg3 != depositFee[arg1 << 248].field_2560:
            revert with 0, 'Different passthrough targets'
        stor1 = 1
    if depositFee[arg1 << 248].field_16 != arg2:
        revert with 0, 'Different lpToken'
    if arg3 != depositFee[arg1 << 248].field_2560:
        revert with 0, 'Different passthrough targets'
    stor1 = 1
}

function sub_8d2c35b2(?) payable {
    require calldata.size - 4 >= 224
    if stor2 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if stor11[address(arg4)][arg2 << 248]:
        revert with 0, 'Duplicated'
    if arg6:
        require ext_code.size(stor2)
        call stor2.0x630b5ba1 with:
             gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    stor11[address(arg4)][arg2 << 248] = 1
    stor5[arg1 << 248] = 1
    stor10[arg2 << 248].field_0++
    stor10[arg2 << 248][stor10[arg2 << 248].field_5].field_0 = stor10[arg2 << 248][stor10[arg2 << 248].field_5].field_0 and !(255 * 256^stor10[arg2 << 248].field_0) or arg1 * 256^stor10[arg2 << 248].field_0
    stor4.length++
    stor4[stor4.length.field_5].field_0 = !(255 * 256^stor4.length % 32) and stor4[stor4.length.field_5].field_0 or 256^stor4.length % 32 * arg1
    mem[548] = arg2
    require ext_code.size(stor3)
    staticcall stor3.0xc416fa18 with:
            gas gas_remaining wei
           args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[31 len 1] <= test266151307()
    if uint8(ext_call.return_data[0]):
        mem[576 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
    mem[(32 * uint8(ext_call.return_data[0])) + 580] = arg2
    require ext_code.size(stor3)
    staticcall stor3.0xc416fa18 with:
            gas gas_remaining wei
           args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[31 len 1] <= test266151307()
    mem[(32 * uint8(ext_call.return_data[0])) + 576] = ext_call.return_data[31 len 1]
    if uint8(ext_call.return_data[0]):
        mem[(32 * uint8(ext_call.return_data[0])) + 608 len 32 * uint8(ext_call.return_data[0])] = call.data[calldata.size len 32 * uint8(ext_call.return_data[0])]
    mem[(64 * uint8(ext_call.return_data[0])) + 612] = arg2
    require ext_code.size(stor3)
    staticcall stor3.getElevationStartRound(uint8 arg1) with:
            gas gas_remaining wei
           args arg2 << 248, mem[(64 * uint8(ext_call.return_data[0])) + 644 len (64 * uint8(ext_call.return_data[0])) - (2 * 32 * uint8(ext_call.return_data[0]))]
    mem[(64 * uint8(ext_call.return_data[0])) + 608] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    depositFee[arg1 << 248].field_0 = arg1
    depositFee[arg1 << 248].field_8 = 0
    depositFee[arg1 << 248].field_16 = arg4
    depositFee[arg1 << 248].field_176 = 0
    depositFee[arg1 << 248].field_256 = 0
    depositFee[arg1 << 248].field_512 = uint8(arg3)
    depositFee[arg1 << 248].field_768 = block.timestamp
    depositFee[arg1 << 248].field_1024 = 0
    depositFee[arg1 << 248].field_1280 = arg5
    depositFee[arg1 << 248].field_1296 = arg2
    depositFee[arg1 << 248].field_1536 = ext_call.return_data[31 len 1]
    if not ext_call.return_data[31 len 1]:
        idx = 0
        while depositFee[arg1 << 248].field_1536 > idx:
            depositFee[arg1 << 248][idx + 6].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = 576
        while (32 * ext_call.return_data[31 len 1]) + 576 > idx:
            depositFee[arg1 << 248][s + 6].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ext_call.return_data[31 len 1]) + 31) >> 5
        while depositFee[arg1 << 248].field_1536 > idx:
            depositFee[arg1 << 248][idx + 6].field_0 = 0
            idx = idx + 1
            continue 
    depositFee[arg1 << 248].field_1792 = 0
    depositFee[arg1 << 248].field_2048 = ext_call.return_data[31 len 1]
    if not ext_call.return_data[31 len 1]:
        idx = 0
        while depositFee[arg1 << 248].field_2048 > idx:
            depositFee[arg1 << 248][idx + 8].field_0 = 0
            idx = idx + 1
            continue 
    else:
        s = 0
        idx = (32 * uint8(ext_call.return_data[0])) + 608
        while (32 * uint8(ext_call.return_data[0])) + (32 * ext_call.return_data[31 len 1]) + 608 > idx:
            depositFee[arg1 << 248][s + 8].field_0 = mem[idx]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * ext_call.return_data[31 len 1]) + 31) >> 5
        while depositFee[arg1 << 248].field_2048 > idx:
            depositFee[arg1 << 248][idx + 8].field_0 = 0
            idx = idx + 1
            continue 
    depositFee[arg1 << 248].field_2304 = ext_call.return_data[0]
    depositFee[arg1 << 248].field_2560 = arg7
    if arg7:
        require ext_code.size(stor2)
        call stor2.0xce45d3ab with:
             gas gas_remaining wei
            args arg7, address(arg4), 0, mem[(64 * uint8(ext_call.return_data[0])) + 708 len (64 * uint8(ext_call.return_data[0])) - (2 * 32 * uint8(ext_call.return_data[0]))]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function totemRoundRewards(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    require ext_code.size(stor3)
    staticcall stor3.0xc416fa18 with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor2)
    staticcall stor2.0x75d813cd with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_768, depositFee[arg1 << 248].field_0, depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[448 len 352] = call.data[calldata.size len 352]
    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
        revert with 0, 'SafeMath: addition overflow'
    mem[448] = ext_call.return_data[0] + depositFee[arg1 << 248].field_1792
    idx = 0
    while uint8(idx) < 10:
        if uint8(idx) >= uint8(ext_call.return_data[0]):
            require uint8(idx + 1) < 11
            mem[(32 * uint8(idx + 1)) + 448] = 0
        else:
            if not depositFee[arg1 << 248].field_256:
                require uint8(idx) < depositFee[arg1 << 248].field_2048
                mem[0] = sha3(arg1 << 248, 6) + 8
                require uint8(idx + 1) < 11
                mem[(32 * uint8(idx + 1)) + 448] = stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0
            else:
                require uint8(idx) < depositFee[arg1 << 248].field_1536
                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                    require uint8(idx) < depositFee[arg1 << 248].field_2048
                    mem[0] = sha3(arg1 << 248, 6) + 8
                    require uint8(idx + 1) < 11
                    mem[(32 * uint8(idx + 1)) + 448] = stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0
                else:
                    require uint8(idx) < depositFee[arg1 << 248].field_1536
                    if not ext_call.return_data[0]:
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require depositFee[arg1 << 248].field_256
                        require uint8(idx) < depositFee[arg1 << 248].field_2048
                        mem[0] = sha3(arg1 << 248, 6) + 8
                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        require uint8(idx + 1) < 11
                        mem[(32 * uint8(idx + 1)) + 448] = (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0
                    else:
                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[901 len 31]
                        if not 10^12 * ext_call.return_data[0]:
                            if depositFee[arg1 << 248].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require depositFee[arg1 << 248].field_256
                            require uint8(idx) < depositFee[arg1 << 248].field_2048
                            mem[0] = sha3(arg1 << 248, 6) + 8
                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(idx + 1) < 11
                            mem[(32 * uint8(idx + 1)) + 448] = (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0
                        else:
                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[901 len 31]
                            if depositFee[arg1 << 248].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require depositFee[arg1 << 248].field_256
                            require uint8(idx) < depositFee[arg1 << 248].field_2048
                            mem[0] = sha3(arg1 << 248, 6) + 8
                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(idx + 1) < 11
                            mem[(32 * uint8(idx + 1)) + 448] = (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0
        idx = idx + 1
        continue 
    return memory
      from 448
       len 352
}

function updatePool(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if depositFee[arg1 << 248].field_768 != block.timestamp:
        if depositFee[arg1 << 248].field_8:
            if depositFee[arg1 << 248].field_256:
                if depositFee[arg1 << 248].field_512:
                    require ext_code.size(stor2)
                    call stor2.0xc93ac180 with:
                         gas gas_remaining wei
                        args depositFee[arg1 << 248].field_768, depositFee[arg1 << 248].field_0, depositFee[arg1 << 248].field_1296
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require depositFee[arg1 << 248].field_256
                        if (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 < depositFee[arg1 << 248].field_1024:
                            revert with 0, 'SafeMath: addition overflow'
                        depositFee[arg1 << 248].field_1024 += 0 / depositFee[arg1 << 248].field_256
                    else:
                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require depositFee[arg1 << 248].field_256
                        if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 < depositFee[arg1 << 248].field_1024:
                            revert with 0, 'SafeMath: addition overflow'
                        depositFee[arg1 << 248].field_1024 += 10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256
                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                        revert with 0, 'SafeMath: addition overflow'
                    depositFee[arg1 << 248].field_1792 += ext_call.return_data[0]
                    idx = 0
                    while uint8(idx) < depositFee[arg1 << 248].field_2048:
                        require uint8(idx) < depositFee[arg1 << 248].field_1536
                        if not ext_call.return_data[0]:
                            if depositFee[arg1 << 248].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require depositFee[arg1 << 248].field_256
                            require uint8(idx) < depositFee[arg1 << 248].field_2048
                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(idx) < depositFee[arg1 << 248].field_2048
                            mem[0] = sha3(arg1 << 248, 6) + 8
                            stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 += 0 / depositFee[arg1 << 248].field_256 / 10^12
                        else:
                            if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if not 10^12 * ext_call.return_data[0]:
                                if depositFee[arg1 << 248].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require depositFee[arg1 << 248].field_256
                                require uint8(idx) < depositFee[arg1 << 248].field_2048
                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(idx) < depositFee[arg1 << 248].field_2048
                                mem[0] = sha3(arg1 << 248, 6) + 8
                                stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 += 0 / depositFee[arg1 << 248].field_256 / 10^12
                            else:
                                if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if depositFee[arg1 << 248].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require depositFee[arg1 << 248].field_256
                                require uint8(idx) < depositFee[arg1 << 248].field_2048
                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(idx) < depositFee[arg1 << 248].field_2048
                                mem[0] = sha3(arg1 << 248, 6) + 8
                                stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 += 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12
                        idx = idx + 1
                        continue 
        depositFee[arg1 << 248].field_768 = block.timestamp
}

function massUpdatePools() payable {
    if stor2 != msg.sender:
        revert with 0, 'rOnly cartographer'
    idx = 0
    while uint8(idx) < stor4.length:
        if not stor5[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248]:
            revert with 0, 'Pool doesnt exist'
        mem[0] = stor('array', ('mask_shl', 3, 5, -5, ('var', 0)), ('name', 'stor4', 4))[uint8(idx)]
        mem[32] = 6
        if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_768 != block.timestamp:
            if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_8:
                if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256:
                    if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_512:
                        mem[100] = depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_768
                        mem[132] = depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_16
                        mem[164] = depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1296
                        require ext_code.size(stor2)
                        call stor2.0xc93ac180 with:
                             gas gas_remaining wei
                            args depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_768, depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_0, depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1296
                        mem[96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256
                            if (0 / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256) + depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1024 < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1024:
                                revert with 0, 'SafeMath: addition overflow'
                            depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1024 += 0 / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256
                        else:
                            if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                            if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256
                            if (10^12 * ext_call.return_data[0] / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256) + depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1024 < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1024:
                                revert with 0, 'SafeMath: addition overflow'
                            depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1024 += 10^12 * ext_call.return_data[0] / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256
                        if ext_call.return_data[0] + depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1792 < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1792 += ext_call.return_data[0]
                        s = 0
                        while uint8(s) < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_2048:
                            require uint8(s) < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_1536
                            if not ext_call.return_data[0]:
                                if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256
                                require uint8(s) < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_2048
                                if (0 / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 / 10^12) + stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 < stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(s) < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_2048
                                mem[0] = sha3(stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248, 6) + 8
                                stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 += 0 / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 / 10^12
                            else:
                                if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                if not 10^12 * ext_call.return_data[0]:
                                    if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256
                                    require uint8(s) < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_2048
                                    if (0 / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 / 10^12) + stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 < stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require uint8(s) < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_2048
                                    mem[0] = sha3(stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248, 6) + 8
                                    stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 += 0 / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 / 10^12
                                else:
                                    if 10^12 * stor[('array', 6, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[197 len 31]
                                    if depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256
                                    require uint8(s) < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_2048
                                    if (10^12 * stor[('array', 6, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 * ext_call.return_data[0] / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 / 10^12) + stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 < stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require uint8(s) < depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_2048
                                    mem[0] = sha3(stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248, 6) + 8
                                    stor[('array', 8, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 += 10^12 * stor[('array', 6, ('map', ('field', ('add', -248, ('mask_shl', 5, 0, 3, ('var', 0))), ('stor', ('array', ('div', ('mask', 8, 0, ('var', 0)), 32), ('name', 'stor4', 4)))), ('name', 'depositFee', 6))) + uint8(s)].field_0 * ext_call.return_data[0] / depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_256 / 10^12
                            s = s + 1
                            continue 
            depositFee[stor4[uint8(idx) / 32].field_(8 * idx % 32) - 248].field_768 = block.timestamp
        idx = idx + 1
        continue 
}

function emergencyWithdraw(uint8 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if stor1 == 2:
        revert with 0, 32, 31, 0xfe5265656e7472616e637947756172643a207265656e7472616e742063616c6c
    stor1 = 2
    if stor2 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not arg2:
        revert with 0, 'User address is zero'
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if not depositFee[arg1 << 248].field_8:
        revert with 0, 'Pool not available yet'
    require ext_code.size(stor3)
    staticcall stor3.getElevationLockedUntilRollover(uint8 arg1) with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0]:
        revert with 0, 'sElev locked until rollover'
    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
        revert with 0, 'Nothing to emergency withdraw'
    if not stor5[stor6[arg1 << 248].field_0]:
        revert with 0, 'Pool doesnt exist'
    if depositFee[depositFee[arg1 << 248].field_0].field_768 != block.timestamp:
        if depositFee[depositFee[arg1 << 248].field_0].field_8:
            if depositFee[depositFee[arg1 << 248].field_0].field_256:
                if depositFee[depositFee[arg1 << 248].field_0].field_512:
                    require ext_code.size(stor2)
                    call stor2.0xc93ac180 with:
                         gas gas_remaining wei
                        args depositFee[depositFee[arg1 << 248].field_0].field_768, depositFee[depositFee[arg1 << 248].field_0].field_0, depositFee[depositFee[arg1 << 248].field_0].field_1296
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        if depositFee[depositFee[arg1 << 248].field_0].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require depositFee[depositFee[arg1 << 248].field_0].field_256
                        if (0 / depositFee[depositFee[arg1 << 248].field_0].field_256) + depositFee[depositFee[arg1 << 248].field_0].field_1024 < depositFee[depositFee[arg1 << 248].field_0].field_1024:
                            revert with 0, 'SafeMath: addition overflow'
                        depositFee[depositFee[arg1 << 248].field_0].field_1024 += 0 / depositFee[depositFee[arg1 << 248].field_0].field_256
                    else:
                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if depositFee[depositFee[arg1 << 248].field_0].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require depositFee[depositFee[arg1 << 248].field_0].field_256
                        if (10^12 * ext_call.return_data[0] / depositFee[depositFee[arg1 << 248].field_0].field_256) + depositFee[depositFee[arg1 << 248].field_0].field_1024 < depositFee[depositFee[arg1 << 248].field_0].field_1024:
                            revert with 0, 'SafeMath: addition overflow'
                        depositFee[depositFee[arg1 << 248].field_0].field_1024 += 10^12 * ext_call.return_data[0] / depositFee[depositFee[arg1 << 248].field_0].field_256
                    if ext_call.return_data[0] + depositFee[depositFee[arg1 << 248].field_0].field_1792 < depositFee[depositFee[arg1 << 248].field_0].field_1792:
                        revert with 0, 'SafeMath: addition overflow'
                    depositFee[depositFee[arg1 << 248].field_0].field_1792 += ext_call.return_data[0]
                    idx = 0
                    while uint8(idx) < depositFee[depositFee[arg1 << 248].field_0].field_2048:
                        require uint8(idx) < depositFee[depositFee[arg1 << 248].field_0].field_1536
                        if not ext_call.return_data[0]:
                            if depositFee[depositFee[arg1 << 248].field_0].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require depositFee[depositFee[arg1 << 248].field_0].field_256
                            require uint8(idx) < depositFee[depositFee[arg1 << 248].field_0].field_2048
                            if (0 / depositFee[depositFee[arg1 << 248].field_0].field_256 / 10^12) + stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            require uint8(idx) < depositFee[depositFee[arg1 << 248].field_0].field_2048
                            mem[0] = sha3(depositFee[arg1 << 248].field_0, 6) + 8
                            stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 += 0 / depositFee[depositFee[arg1 << 248].field_0].field_256 / 10^12
                        else:
                            if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[197 len 31]
                            if not 10^12 * ext_call.return_data[0]:
                                if depositFee[depositFee[arg1 << 248].field_0].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require depositFee[depositFee[arg1 << 248].field_0].field_256
                                require uint8(idx) < depositFee[depositFee[arg1 << 248].field_0].field_2048
                                if (0 / depositFee[depositFee[arg1 << 248].field_0].field_256 / 10^12) + stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(idx) < depositFee[depositFee[arg1 << 248].field_0].field_2048
                                mem[0] = sha3(depositFee[arg1 << 248].field_0, 6) + 8
                                stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 += 0 / depositFee[depositFee[arg1 << 248].field_0].field_256 / 10^12
                            else:
                                if 10^12 * stor[('array', 6, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[197 len 31]
                                if depositFee[depositFee[arg1 << 248].field_0].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require depositFee[depositFee[arg1 << 248].field_0].field_256
                                require uint8(idx) < depositFee[depositFee[arg1 << 248].field_0].field_2048
                                if (10^12 * stor[('array', 6, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / depositFee[depositFee[arg1 << 248].field_0].field_256 / 10^12) + stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 < stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                require uint8(idx) < depositFee[depositFee[arg1 << 248].field_0].field_2048
                                mem[0] = sha3(depositFee[arg1 << 248].field_0, 6) + 8
                                stor[('array', 8, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 += 10^12 * stor[('array', 6, ('map', ('field', 0, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('name', 'depositFee', 6))) + uint8(idx)].field_0 * ext_call.return_data[0] / depositFee[depositFee[arg1 << 248].field_0].field_256 / 10^12
                        idx = idx + 1
                        continue 
        depositFee[depositFee[arg1 << 248].field_0].field_768 = block.timestamp
    sub_76fa17d2[arg1 << 248][address(arg2)].field_0 = 0
    sub_76fa17d2[arg1 << 248][address(arg2)].field_256 = 0
    require ext_code.size(stor2)
    call stor2.0x3f4af6d0 with:
         gas gas_remaining wei
        args 0, 0, depositFee[arg1 << 248].field_0, sub_76fa17d2[arg1 << 248][address(arg2)].field_256, depositFee[arg1 << 248].field_2560
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_256 > stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
        revert with 0, 'SafeMath: subtraction overflow'
    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
    stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 -= sub_76fa17d2[arg1 << 248][address(arg2)].field_256
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_256 > depositFee[arg1 << 248].field_256:
        revert with 0, 'SafeMath: subtraction overflow'
    depositFee[arg1 << 248].field_256 -= sub_76fa17d2[arg1 << 248][address(arg2)].field_256
    stor1 = 1
    return sub_76fa17d2[arg1 << 248][address(arg2)].field_256
}

function totemLpSupplies(uint8 arg1) payable {
    require calldata.size - 4 >= 32
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if depositFee[arg1 << 248].field_1296 < 1:
        if depositFee[arg1 << 248].field_1296 < 2:
            if depositFee[arg1 << 248].field_1296 < 3:
                return 0
            if 5 < depositFee[arg1 << 248].field_1536:
                if depositFee[arg1 << 248].field_1296 < 3:
                    return 0, 0, 0, 0, 0, depositFee[arg1 << 248][6].field_1280, 0, 0, 0, 0
                if 6 < depositFee[arg1 << 248].field_1536:
                    if depositFee[arg1 << 248].field_1296 < 3:
                        return 0, 0, 0, 0, 0, depositFee[arg1 << 248][6].field_1280, depositFee[arg1 << 248][6].field_1536, 0, 0, 0
                    if 7 < depositFee[arg1 << 248].field_1536:
                        if depositFee[arg1 << 248].field_1296 < 3:
                            return 0, 
                                   0,
                                   0,
                                   0,
                                   0,
                                   depositFee[arg1 << 248][6].field_1280,
                                   depositFee[arg1 << 248][6].field_1536,
                                   depositFee[arg1 << 248][6].field_1792,
                                   0,
                                   0
                        if 8 < depositFee[arg1 << 248].field_1536:
                            if depositFee[arg1 << 248].field_1296 < 3:
                                return 0, 
                                       0,
                                       0,
                                       0,
                                       0,
                                       depositFee[arg1 << 248][6].field_1280,
                                       depositFee[arg1 << 248][6].field_1536,
                                       depositFee[arg1 << 248][6].field_1792,
                                       depositFee[arg1 << 248][6].field_2048,
                                       0
                            if 9 < depositFee[arg1 << 248].field_1536:
                                return 0, 
                                       0,
                                       0,
                                       0,
                                       0,
                                       depositFee[arg1 << 248][6].field_1280,
                                       depositFee[arg1 << 248][6].field_1536,
                                       depositFee[arg1 << 248][6].field_1792,
                                       depositFee[arg1 << 248][6].field_2048,
                                       depositFee[arg1 << 248][6].field_2304
        else:
            if 2 < depositFee[arg1 << 248].field_1536:
                if depositFee[arg1 << 248].field_1296 < 2:
                    if depositFee[arg1 << 248].field_1296 < 3:
                        return 0, 0, depositFee[arg1 << 248][6].field_512, 0, 0, 0, 0, 0, 0, 0
                    if 5 < depositFee[arg1 << 248].field_1536:
                        if depositFee[arg1 << 248].field_1296 < 3:
                            return 0, 0, depositFee[arg1 << 248][6].field_512, 0, 0, depositFee[arg1 << 248][6].field_1280, 0, 0, 0, 0
                        if 6 < depositFee[arg1 << 248].field_1536:
                            if depositFee[arg1 << 248].field_1296 < 3:
                                return 0, 
                                       0,
                                       depositFee[arg1 << 248][6].field_512,
                                       0,
                                       0,
                                       depositFee[arg1 << 248][6].field_1280,
                                       depositFee[arg1 << 248][6].field_1536,
                                       0,
                                       0,
                                       0
                            if 7 < depositFee[arg1 << 248].field_1536:
                                if depositFee[arg1 << 248].field_1296 < 3:
                                    return 0, 
                                           0,
                                           depositFee[arg1 << 248][6].field_512,
                                           0,
                                           0,
                                           depositFee[arg1 << 248][6].field_1280,
                                           depositFee[arg1 << 248][6].field_1536,
                                           depositFee[arg1 << 248][6].field_1792,
                                           0,
                                           0
                                if 8 < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_1296 < 3:
                                        return 0, 
                                               0,
                                               depositFee[arg1 << 248][6].field_512,
                                               0,
                                               0,
                                               depositFee[arg1 << 248][6].field_1280,
                                               depositFee[arg1 << 248][6].field_1536,
                                               depositFee[arg1 << 248][6].field_1792,
                                               depositFee[arg1 << 248][6].field_2048,
                                               0
                                    if 9 < depositFee[arg1 << 248].field_1536:
                                        return 0, 
                                               0,
                                               depositFee[arg1 << 248][6].field_512,
                                               0,
                                               0,
                                               depositFee[arg1 << 248][6].field_1280,
                                               depositFee[arg1 << 248][6].field_1536,
                                               depositFee[arg1 << 248][6].field_1792,
                                               depositFee[arg1 << 248][6].field_2048,
                                               depositFee[arg1 << 248][6].field_2304
                else:
                    if 3 < depositFee[arg1 << 248].field_1536:
                        if depositFee[arg1 << 248].field_1296 < 2:
                            if depositFee[arg1 << 248].field_1296 < 3:
                                return 0, 0, depositFee[arg1 << 248][6].field_512, depositFee[arg1 << 248][6].field_768, 0, 0, 0, 0, 0, 0
                            if 5 < depositFee[arg1 << 248].field_1536:
                                if depositFee[arg1 << 248].field_1296 < 3:
                                    return 0, 
                                           0,
                                           depositFee[arg1 << 248][6].field_512,
                                           depositFee[arg1 << 248][6].field_768,
                                           0,
                                           depositFee[arg1 << 248][6].field_1280,
                                           0,
                                           0,
                                           0,
                                           0
                                if 6 < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_1296 < 3:
                                        return 0, 
                                               0,
                                               depositFee[arg1 << 248][6].field_512,
                                               depositFee[arg1 << 248][6].field_768,
                                               0,
                                               depositFee[arg1 << 248][6].field_1280,
                                               depositFee[arg1 << 248][6].field_1536,
                                               0,
                                               0,
                                               0
                                    if 7 < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_1296 < 3:
                                            return 0, 
                                                   0,
                                                   depositFee[arg1 << 248][6].field_512,
                                                   depositFee[arg1 << 248][6].field_768,
                                                   0,
                                                   depositFee[arg1 << 248][6].field_1280,
                                                   depositFee[arg1 << 248][6].field_1536,
                                                   depositFee[arg1 << 248][6].field_1792,
                                                   0,
                                                   0
                                        if 8 < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                return 0, 
                                                       0,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       depositFee[arg1 << 248][6].field_768,
                                                       0,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       depositFee[arg1 << 248][6].field_1536,
                                                       depositFee[arg1 << 248][6].field_1792,
                                                       depositFee[arg1 << 248][6].field_2048,
                                                       0
                                            if 9 < depositFee[arg1 << 248].field_1536:
                                                return 0, 
                                                       0,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       depositFee[arg1 << 248][6].field_768,
                                                       0,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       depositFee[arg1 << 248][6].field_1536,
                                                       depositFee[arg1 << 248][6].field_1792,
                                                       depositFee[arg1 << 248][6].field_2048,
                                                       depositFee[arg1 << 248][6].field_2304
                        else:
                            if 4 < depositFee[arg1 << 248].field_1536:
                                if depositFee[arg1 << 248].field_1296 < 3:
                                    return 0, 
                                           0,
                                           depositFee[arg1 << 248][6].field_512,
                                           depositFee[arg1 << 248][6].field_768,
                                           depositFee[arg1 << 248][6].field_1024,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0
                                if 5 < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_1296 < 3:
                                        return 0, 
                                               0,
                                               depositFee[arg1 << 248][6].field_512,
                                               depositFee[arg1 << 248][6].field_768,
                                               depositFee[arg1 << 248][6].field_1024,
                                               depositFee[arg1 << 248][6].field_1280,
                                               0,
                                               0,
                                               0,
                                               0
                                    if 6 < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_1296 < 3:
                                            return 0, 
                                                   0,
                                                   depositFee[arg1 << 248][6].field_512,
                                                   depositFee[arg1 << 248][6].field_768,
                                                   depositFee[arg1 << 248][6].field_1024,
                                                   depositFee[arg1 << 248][6].field_1280,
                                                   depositFee[arg1 << 248][6].field_1536,
                                                   0,
                                                   0,
                                                   0
                                        if 7 < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                return 0, 
                                                       0,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       depositFee[arg1 << 248][6].field_768,
                                                       depositFee[arg1 << 248][6].field_1024,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       depositFee[arg1 << 248][6].field_1536,
                                                       depositFee[arg1 << 248][6].field_1792,
                                                       0,
                                                       0
                                            if 8 < depositFee[arg1 << 248].field_1536:
                                                if depositFee[arg1 << 248].field_1296 < 3:
                                                    return 0, 
                                                           0,
                                                           depositFee[arg1 << 248][6].field_512,
                                                           depositFee[arg1 << 248][6].field_768,
                                                           depositFee[arg1 << 248][6].field_1024,
                                                           depositFee[arg1 << 248][6].field_1280,
                                                           depositFee[arg1 << 248][6].field_1536,
                                                           depositFee[arg1 << 248][6].field_1792,
                                                           depositFee[arg1 << 248][6].field_2048,
                                                           0
                                                if 9 < depositFee[arg1 << 248].field_1536:
                                                    return 0, 
                                                           0,
                                                           depositFee[arg1 << 248][6].field_512,
                                                           depositFee[arg1 << 248][6].field_768,
                                                           depositFee[arg1 << 248][6].field_1024,
                                                           depositFee[arg1 << 248][6].field_1280,
                                                           depositFee[arg1 << 248][6].field_1536,
                                                           depositFee[arg1 << 248][6].field_1792,
                                                           depositFee[arg1 << 248][6].field_2048,
                                                           depositFee[arg1 << 248][6].field_2304
    else:
        if 0 < depositFee[arg1 << 248].field_1536:
            if depositFee[arg1 << 248].field_1296 < 1:
                if depositFee[arg1 << 248].field_1296 < 2:
                    if depositFee[arg1 << 248].field_1296 < 3:
                        return depositFee[arg1 << 248][6].field_0, 0
                    if 5 < depositFee[arg1 << 248].field_1536:
                        if depositFee[arg1 << 248].field_1296 < 3:
                            return depositFee[arg1 << 248][6].field_0, 0, 0, 0, 0, depositFee[arg1 << 248][6].field_1280, 0, 0, 0, 0
                        if 6 < depositFee[arg1 << 248].field_1536:
                            if depositFee[arg1 << 248].field_1296 < 3:
                                return depositFee[arg1 << 248][6].field_0, 
                                       0,
                                       0,
                                       0,
                                       0,
                                       depositFee[arg1 << 248][6].field_1280,
                                       depositFee[arg1 << 248][6].field_1536,
                                       0,
                                       0,
                                       0
                            if 7 < depositFee[arg1 << 248].field_1536:
                                if depositFee[arg1 << 248].field_1296 < 3:
                                    return depositFee[arg1 << 248][6].field_0, 
                                           0,
                                           0,
                                           0,
                                           0,
                                           depositFee[arg1 << 248][6].field_1280,
                                           depositFee[arg1 << 248][6].field_1536,
                                           depositFee[arg1 << 248][6].field_1792,
                                           0,
                                           0
                                if 8 < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_1296 < 3:
                                        return depositFee[arg1 << 248][6].field_0, 
                                               0,
                                               0,
                                               0,
                                               0,
                                               depositFee[arg1 << 248][6].field_1280,
                                               depositFee[arg1 << 248][6].field_1536,
                                               depositFee[arg1 << 248][6].field_1792,
                                               depositFee[arg1 << 248][6].field_2048,
                                               0
                                    if 9 < depositFee[arg1 << 248].field_1536:
                                        return depositFee[arg1 << 248][6].field_0, 
                                               0,
                                               0,
                                               0,
                                               0,
                                               depositFee[arg1 << 248][6].field_1280,
                                               depositFee[arg1 << 248][6].field_1536,
                                               depositFee[arg1 << 248][6].field_1792,
                                               depositFee[arg1 << 248][6].field_2048,
                                               depositFee[arg1 << 248][6].field_2304
                else:
                    if 2 < depositFee[arg1 << 248].field_1536:
                        if depositFee[arg1 << 248].field_1296 < 2:
                            if depositFee[arg1 << 248].field_1296 < 3:
                                return depositFee[arg1 << 248][6].field_0, 0, depositFee[arg1 << 248][6].field_512, 0, 0, 0, 0, 0, 0, 0
                            if 5 < depositFee[arg1 << 248].field_1536:
                                if depositFee[arg1 << 248].field_1296 < 3:
                                    return depositFee[arg1 << 248][6].field_0, 
                                           0,
                                           depositFee[arg1 << 248][6].field_512,
                                           0,
                                           0,
                                           depositFee[arg1 << 248][6].field_1280,
                                           0,
                                           0,
                                           0,
                                           0
                                if 6 < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_1296 < 3:
                                        return depositFee[arg1 << 248][6].field_0, 
                                               0,
                                               depositFee[arg1 << 248][6].field_512,
                                               0,
                                               0,
                                               depositFee[arg1 << 248][6].field_1280,
                                               depositFee[arg1 << 248][6].field_1536,
                                               0,
                                               0,
                                               0
                                    if 7 < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_1296 < 3:
                                            return depositFee[arg1 << 248][6].field_0, 
                                                   0,
                                                   depositFee[arg1 << 248][6].field_512,
                                                   0,
                                                   0,
                                                   depositFee[arg1 << 248][6].field_1280,
                                                   depositFee[arg1 << 248][6].field_1536,
                                                   depositFee[arg1 << 248][6].field_1792,
                                                   0,
                                                   0
                                        if 8 < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                return depositFee[arg1 << 248][6].field_0, 
                                                       0,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       0,
                                                       0,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       depositFee[arg1 << 248][6].field_1536,
                                                       depositFee[arg1 << 248][6].field_1792,
                                                       depositFee[arg1 << 248][6].field_2048,
                                                       0
                                            if 9 < depositFee[arg1 << 248].field_1536:
                                                return depositFee[arg1 << 248][6].field_0, 
                                                       0,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       0,
                                                       0,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       depositFee[arg1 << 248][6].field_1536,
                                                       depositFee[arg1 << 248][6].field_1792,
                                                       depositFee[arg1 << 248][6].field_2048,
                                                       depositFee[arg1 << 248][6].field_2304
                        else:
                            if 3 < depositFee[arg1 << 248].field_1536:
                                if depositFee[arg1 << 248].field_1296 < 2:
                                    if depositFee[arg1 << 248].field_1296 < 3:
                                        return depositFee[arg1 << 248][6].field_0, 
                                               0,
                                               depositFee[arg1 << 248][6].field_512,
                                               depositFee[arg1 << 248][6].field_768,
                                               0,
                                               0,
                                               0,
                                               0,
                                               0,
                                               0
                                    if 5 < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_1296 < 3:
                                            return depositFee[arg1 << 248][6].field_0, 
                                                   0,
                                                   depositFee[arg1 << 248][6].field_512,
                                                   depositFee[arg1 << 248][6].field_768,
                                                   0,
                                                   depositFee[arg1 << 248][6].field_1280,
                                                   0,
                                                   0,
                                                   0,
                                                   0
                                        if 6 < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                return depositFee[arg1 << 248][6].field_0, 
                                                       0,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       depositFee[arg1 << 248][6].field_768,
                                                       0,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       depositFee[arg1 << 248][6].field_1536,
                                                       0,
                                                       0,
                                                       0
                                            if 7 < depositFee[arg1 << 248].field_1536:
                                                if depositFee[arg1 << 248].field_1296 < 3:
                                                    return depositFee[arg1 << 248][6].field_0, 
                                                           0,
                                                           depositFee[arg1 << 248][6].field_512,
                                                           depositFee[arg1 << 248][6].field_768,
                                                           0,
                                                           depositFee[arg1 << 248][6].field_1280,
                                                           depositFee[arg1 << 248][6].field_1536,
                                                           depositFee[arg1 << 248][6].field_1792,
                                                           0,
                                                           0
                                                if 8 < depositFee[arg1 << 248].field_1536:
                                                    if depositFee[arg1 << 248].field_1296 < 3:
                                                        return depositFee[arg1 << 248][6].field_0, 
                                                               0,
                                                               depositFee[arg1 << 248][6].field_512,
                                                               depositFee[arg1 << 248][6].field_768,
                                                               0,
                                                               depositFee[arg1 << 248][6].field_1280,
                                                               depositFee[arg1 << 248][6].field_1536,
                                                               depositFee[arg1 << 248][6].field_1792,
                                                               depositFee[arg1 << 248][6].field_2048,
                                                               0
                                                    if 9 < depositFee[arg1 << 248].field_1536:
                                                        return depositFee[arg1 << 248][6].field_0, 
                                                               0,
                                                               depositFee[arg1 << 248][6].field_512,
                                                               depositFee[arg1 << 248][6].field_768,
                                                               0,
                                                               depositFee[arg1 << 248][6].field_1280,
                                                               depositFee[arg1 << 248][6].field_1536,
                                                               depositFee[arg1 << 248][6].field_1792,
                                                               depositFee[arg1 << 248][6].field_2048,
                                                               depositFee[arg1 << 248][6].field_2304
                                else:
                                    if 4 < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_1296 < 3:
                                            return depositFee[arg1 << 248][6].field_0, 
                                                   0,
                                                   depositFee[arg1 << 248][6].field_512,
                                                   depositFee[arg1 << 248][6].field_768,
                                                   depositFee[arg1 << 248][6].field_1024,
                                                   0,
                                                   0,
                                                   0,
                                                   0,
                                                   0
                                        if 5 < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                return depositFee[arg1 << 248][6].field_0, 
                                                       0,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       depositFee[arg1 << 248][6].field_768,
                                                       depositFee[arg1 << 248][6].field_1024,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       0,
                                                       0,
                                                       0,
                                                       0
                                            if 6 < depositFee[arg1 << 248].field_1536:
                                                if depositFee[arg1 << 248].field_1296 < 3:
                                                    return depositFee[arg1 << 248][6].field_0, 
                                                           0,
                                                           depositFee[arg1 << 248][6].field_512,
                                                           depositFee[arg1 << 248][6].field_768,
                                                           depositFee[arg1 << 248][6].field_1024,
                                                           depositFee[arg1 << 248][6].field_1280,
                                                           depositFee[arg1 << 248][6].field_1536,
                                                           0,
                                                           0,
                                                           0
                                                if 7 < depositFee[arg1 << 248].field_1536:
                                                    if depositFee[arg1 << 248].field_1296 < 3:
                                                        return depositFee[arg1 << 248][6].field_0, 
                                                               0,
                                                               depositFee[arg1 << 248][6].field_512,
                                                               depositFee[arg1 << 248][6].field_768,
                                                               depositFee[arg1 << 248][6].field_1024,
                                                               depositFee[arg1 << 248][6].field_1280,
                                                               depositFee[arg1 << 248][6].field_1536,
                                                               depositFee[arg1 << 248][6].field_1792,
                                                               0,
                                                               0
                                                    if 8 < depositFee[arg1 << 248].field_1536:
                                                        if depositFee[arg1 << 248].field_1296 < 3:
                                                            return depositFee[arg1 << 248][6].field_0, 
                                                                   0,
                                                                   depositFee[arg1 << 248][6].field_512,
                                                                   depositFee[arg1 << 248][6].field_768,
                                                                   depositFee[arg1 << 248][6].field_1024,
                                                                   depositFee[arg1 << 248][6].field_1280,
                                                                   depositFee[arg1 << 248][6].field_1536,
                                                                   depositFee[arg1 << 248][6].field_1792,
                                                                   depositFee[arg1 << 248][6].field_2048,
                                                                   0
                                                        if 9 < depositFee[arg1 << 248].field_1536:
                                                            return depositFee[arg1 << 248][6].field_0, 
                                                                   0,
                                                                   depositFee[arg1 << 248][6].field_512,
                                                                   depositFee[arg1 << 248][6].field_768,
                                                                   depositFee[arg1 << 248][6].field_1024,
                                                                   depositFee[arg1 << 248][6].field_1280,
                                                                   depositFee[arg1 << 248][6].field_1536,
                                                                   depositFee[arg1 << 248][6].field_1792,
                                                                   depositFee[arg1 << 248][6].field_2048,
                                                                   depositFee[arg1 << 248][6].field_2304
            else:
                if 1 < depositFee[arg1 << 248].field_1536:
                    if depositFee[arg1 << 248].field_1296 < 2:
                        if depositFee[arg1 << 248].field_1296 < 3:
                            return depositFee[arg1 << 248][6].field_0, depositFee[arg1 << 248][6].field_256, 0, 0, 0, 0, 0, 0, 0, 0
                        if 5 < depositFee[arg1 << 248].field_1536:
                            if depositFee[arg1 << 248].field_1296 < 3:
                                return depositFee[arg1 << 248][6].field_0, 
                                       depositFee[arg1 << 248][6].field_256,
                                       0,
                                       0,
                                       0,
                                       depositFee[arg1 << 248][6].field_1280,
                                       0,
                                       0,
                                       0,
                                       0
                            if 6 < depositFee[arg1 << 248].field_1536:
                                if depositFee[arg1 << 248].field_1296 < 3:
                                    return depositFee[arg1 << 248][6].field_0, 
                                           depositFee[arg1 << 248][6].field_256,
                                           0,
                                           0,
                                           0,
                                           depositFee[arg1 << 248][6].field_1280,
                                           depositFee[arg1 << 248][6].field_1536,
                                           0,
                                           0,
                                           0
                                if 7 < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_1296 < 3:
                                        return depositFee[arg1 << 248][6].field_0, 
                                               depositFee[arg1 << 248][6].field_256,
                                               0,
                                               0,
                                               0,
                                               depositFee[arg1 << 248][6].field_1280,
                                               depositFee[arg1 << 248][6].field_1536,
                                               depositFee[arg1 << 248][6].field_1792,
                                               0,
                                               0
                                    if 8 < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_1296 < 3:
                                            return depositFee[arg1 << 248][6].field_0, 
                                                   depositFee[arg1 << 248][6].field_256,
                                                   0,
                                                   0,
                                                   0,
                                                   depositFee[arg1 << 248][6].field_1280,
                                                   depositFee[arg1 << 248][6].field_1536,
                                                   depositFee[arg1 << 248][6].field_1792,
                                                   depositFee[arg1 << 248][6].field_2048,
                                                   0
                                        if 9 < depositFee[arg1 << 248].field_1536:
                                            return depositFee[arg1 << 248][6].field_0, 
                                                   depositFee[arg1 << 248][6].field_256,
                                                   0,
                                                   0,
                                                   0,
                                                   depositFee[arg1 << 248][6].field_1280,
                                                   depositFee[arg1 << 248][6].field_1536,
                                                   depositFee[arg1 << 248][6].field_1792,
                                                   depositFee[arg1 << 248][6].field_2048,
                                                   depositFee[arg1 << 248][6].field_2304
                    else:
                        if 2 < depositFee[arg1 << 248].field_1536:
                            if depositFee[arg1 << 248].field_1296 < 2:
                                if depositFee[arg1 << 248].field_1296 < 3:
                                    return depositFee[arg1 << 248][6].field_0, 
                                           depositFee[arg1 << 248][6].field_256,
                                           depositFee[arg1 << 248][6].field_512,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0,
                                           0
                                if 5 < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_1296 < 3:
                                        return depositFee[arg1 << 248][6].field_0, 
                                               depositFee[arg1 << 248][6].field_256,
                                               depositFee[arg1 << 248][6].field_512,
                                               0,
                                               0,
                                               depositFee[arg1 << 248][6].field_1280,
                                               0,
                                               0,
                                               0,
                                               0
                                    if 6 < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_1296 < 3:
                                            return depositFee[arg1 << 248][6].field_0, 
                                                   depositFee[arg1 << 248][6].field_256,
                                                   depositFee[arg1 << 248][6].field_512,
                                                   0,
                                                   0,
                                                   depositFee[arg1 << 248][6].field_1280,
                                                   depositFee[arg1 << 248][6].field_1536,
                                                   0,
                                                   0,
                                                   0
                                        if 7 < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                return depositFee[arg1 << 248][6].field_0, 
                                                       depositFee[arg1 << 248][6].field_256,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       0,
                                                       0,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       depositFee[arg1 << 248][6].field_1536,
                                                       depositFee[arg1 << 248][6].field_1792,
                                                       0,
                                                       0
                                            if 8 < depositFee[arg1 << 248].field_1536:
                                                if depositFee[arg1 << 248].field_1296 < 3:
                                                    return depositFee[arg1 << 248][6].field_0, 
                                                           depositFee[arg1 << 248][6].field_256,
                                                           depositFee[arg1 << 248][6].field_512,
                                                           0,
                                                           0,
                                                           depositFee[arg1 << 248][6].field_1280,
                                                           depositFee[arg1 << 248][6].field_1536,
                                                           depositFee[arg1 << 248][6].field_1792,
                                                           depositFee[arg1 << 248][6].field_2048,
                                                           0
                                                if 9 < depositFee[arg1 << 248].field_1536:
                                                    return depositFee[arg1 << 248][6].field_0, 
                                                           depositFee[arg1 << 248][6].field_256,
                                                           depositFee[arg1 << 248][6].field_512,
                                                           0,
                                                           0,
                                                           depositFee[arg1 << 248][6].field_1280,
                                                           depositFee[arg1 << 248][6].field_1536,
                                                           depositFee[arg1 << 248][6].field_1792,
                                                           depositFee[arg1 << 248][6].field_2048,
                                                           depositFee[arg1 << 248][6].field_2304
                            else:
                                if 3 < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_1296 < 2:
                                        if depositFee[arg1 << 248].field_1296 < 3:
                                            return depositFee[arg1 << 248][6].field_0, 
                                                   depositFee[arg1 << 248][6].field_256,
                                                   depositFee[arg1 << 248][6].field_512,
                                                   depositFee[arg1 << 248][6].field_768,
                                                   0,
                                                   0,
                                                   0,
                                                   0,
                                                   0,
                                                   0
                                        if 5 < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                return depositFee[arg1 << 248][6].field_0, 
                                                       depositFee[arg1 << 248][6].field_256,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       depositFee[arg1 << 248][6].field_768,
                                                       0,
                                                       depositFee[arg1 << 248][6].field_1280,
                                                       0,
                                                       0,
                                                       0,
                                                       0
                                            if 6 < depositFee[arg1 << 248].field_1536:
                                                if depositFee[arg1 << 248].field_1296 < 3:
                                                    return depositFee[arg1 << 248][6].field_0, 
                                                           depositFee[arg1 << 248][6].field_256,
                                                           depositFee[arg1 << 248][6].field_512,
                                                           depositFee[arg1 << 248][6].field_768,
                                                           0,
                                                           depositFee[arg1 << 248][6].field_1280,
                                                           depositFee[arg1 << 248][6].field_1536,
                                                           0,
                                                           0,
                                                           0
                                                if 7 < depositFee[arg1 << 248].field_1536:
                                                    if depositFee[arg1 << 248].field_1296 < 3:
                                                        return depositFee[arg1 << 248][6].field_0, 
                                                               depositFee[arg1 << 248][6].field_256,
                                                               depositFee[arg1 << 248][6].field_512,
                                                               depositFee[arg1 << 248][6].field_768,
                                                               0,
                                                               depositFee[arg1 << 248][6].field_1280,
                                                               depositFee[arg1 << 248][6].field_1536,
                                                               depositFee[arg1 << 248][6].field_1792,
                                                               0,
                                                               0
                                                    if 8 < depositFee[arg1 << 248].field_1536:
                                                        if depositFee[arg1 << 248].field_1296 < 3:
                                                            return depositFee[arg1 << 248][6].field_0, 
                                                                   depositFee[arg1 << 248][6].field_256,
                                                                   depositFee[arg1 << 248][6].field_512,
                                                                   depositFee[arg1 << 248][6].field_768,
                                                                   0,
                                                                   depositFee[arg1 << 248][6].field_1280,
                                                                   depositFee[arg1 << 248][6].field_1536,
                                                                   depositFee[arg1 << 248][6].field_1792,
                                                                   depositFee[arg1 << 248][6].field_2048,
                                                                   0
                                                        if 9 < depositFee[arg1 << 248].field_1536:
                                                            return depositFee[arg1 << 248][6].field_0, 
                                                                   depositFee[arg1 << 248][6].field_256,
                                                                   depositFee[arg1 << 248][6].field_512,
                                                                   depositFee[arg1 << 248][6].field_768,
                                                                   0,
                                                                   depositFee[arg1 << 248][6].field_1280,
                                                                   depositFee[arg1 << 248][6].field_1536,
                                                                   depositFee[arg1 << 248][6].field_1792,
                                                                   depositFee[arg1 << 248][6].field_2048,
                                                                   depositFee[arg1 << 248][6].field_2304
                                    else:
                                        if 4 < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                return depositFee[arg1 << 248][6].field_0, 
                                                       depositFee[arg1 << 248][6].field_256,
                                                       depositFee[arg1 << 248][6].field_512,
                                                       depositFee[arg1 << 248][6].field_768,
                                                       depositFee[arg1 << 248][6].field_1024,
                                                       0,
                                                       0,
                                                       0,
                                                       0,
                                                       0
                                            if 5 < depositFee[arg1 << 248].field_1536:
                                                if depositFee[arg1 << 248].field_1296 < 3:
                                                    return depositFee[arg1 << 248][6].field_0, 
                                                           depositFee[arg1 << 248][6].field_256,
                                                           depositFee[arg1 << 248][6].field_512,
                                                           depositFee[arg1 << 248][6].field_768,
                                                           depositFee[arg1 << 248][6].field_1024,
                                                           depositFee[arg1 << 248][6].field_1280,
                                                           0,
                                                           0,
                                                           0,
                                                           0
                                                if 6 < depositFee[arg1 << 248].field_1536:
                                                    if depositFee[arg1 << 248].field_1296 < 3:
                                                        return depositFee[arg1 << 248][6].field_0, 
                                                               depositFee[arg1 << 248][6].field_256,
                                                               depositFee[arg1 << 248][6].field_512,
                                                               depositFee[arg1 << 248][6].field_768,
                                                               depositFee[arg1 << 248][6].field_1024,
                                                               depositFee[arg1 << 248][6].field_1280,
                                                               depositFee[arg1 << 248][6].field_1536,
                                                               0,
                                                               0,
                                                               0
                                                    if 7 < depositFee[arg1 << 248].field_1536:
                                                        if depositFee[arg1 << 248].field_1296 < 3:
                                                            return depositFee[arg1 << 248][6].field_0, 
                                                                   depositFee[arg1 << 248][6].field_256,
                                                                   depositFee[arg1 << 248][6].field_512,
                                                                   depositFee[arg1 << 248][6].field_768,
                                                                   depositFee[arg1 << 248][6].field_1024,
                                                                   depositFee[arg1 << 248][6].field_1280,
                                                                   depositFee[arg1 << 248][6].field_1536,
                                                                   depositFee[arg1 << 248][6].field_1792,
                                                                   0,
                                                                   0
                                                        if 8 < depositFee[arg1 << 248].field_1536:
                                                            if depositFee[arg1 << 248].field_1296 < 3:
                                                                return depositFee[arg1 << 248][6].field_0, 
                                                                       depositFee[arg1 << 248][6].field_256,
                                                                       depositFee[arg1 << 248][6].field_512,
                                                                       depositFee[arg1 << 248][6].field_768,
                                                                       depositFee[arg1 << 248][6].field_1024,
                                                                       depositFee[arg1 << 248][6].field_1280,
                                                                       depositFee[arg1 << 248][6].field_1536,
                                                                       depositFee[arg1 << 248][6].field_1792,
                                                                       depositFee[arg1 << 248][6].field_2048,
                                                                       0
                                                            if 9 < depositFee[arg1 << 248].field_1536:
                                                                return depositFee[arg1 << 248][6].field_0, 
                                                                       depositFee[arg1 << 248][6].field_256,
                                                                       depositFee[arg1 << 248][6].field_512,
                                                                       depositFee[arg1 << 248][6].field_768,
                                                                       depositFee[arg1 << 248][6].field_1024,
                                                                       depositFee[arg1 << 248][6].field_1280,
                                                                       depositFee[arg1 << 248][6].field_1536,
                                                                       depositFee[arg1 << 248][6].field_1792,
                                                                       depositFee[arg1 << 248][6].field_2048,
                                                                       depositFee[arg1 << 248][6].field_2304
    revert
}

function hypotheticalRewards(uint8 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if not arg2:
        revert with 0, 'User address is zero'
    if not depositFee[arg1 << 248].field_1536:
        if depositFee[arg1 << 248].field_2048:
            idx = (32 * depositFee[arg1 << 248].field_1536) + 1056
            s = 0
            while (32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1024 > idx:
                mem[idx + 32] = depositFee[arg1 << 248][s + 8].field_256
                idx = idx + 32
                s = s + 1
                continue 
        if block.timestamp <= depositFee[arg1 << 248].field_768:
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > depositFee[arg1 << 248].field_1024:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                    if not stor5[arg1 << 248]:
                        revert with 0, 'Pool doesnt exist'
                    if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                        revert with 0, 'SafeMath: addition overflow'
                    if not depositFee[arg1 << 248].field_256:
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                        return 0
                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                        return 0
                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                    if depositFee[arg1 << 248].field_256 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require depositFee[arg1 << 248].field_256
                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    else:
                        return 0
                if (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                    revert with 0, 
                                32,
                                33,
                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                if not stor5[arg1 << 248]:
                    revert with 0, 'Pool doesnt exist'
                if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                    revert with 0, 'SafeMath: addition overflow'
                if not depositFee[arg1 << 248].field_256:
                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                        if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                            return 0
                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                            return 0
                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                   (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                        if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                        else:
                            if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                revert with 0, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                       depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                else:
                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if depositFee[arg1 << 248].field_256 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
            else:
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                        revert with 0, 'SafeMath: addition overflow'
                    if not stor5[arg1 << 248]:
                        revert with 0, 'Pool doesnt exist'
                    if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                        revert with 0, 'SafeMath: addition overflow'
                    if not depositFee[arg1 << 248].field_256:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                return 0
                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                return 0
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                    else:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                else:
                    if depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024:
                        revert with 0, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not stor5[arg1 << 248]:
                        revert with 0, 'Pool doesnt exist'
                    if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                        revert with 0, 'SafeMath: addition overflow'
                    if not depositFee[arg1 << 248].field_256:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                return 0
                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                return 0
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                    else:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
        else:
            if depositFee[arg1 << 248].field_256 <= 0:
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > depositFee[arg1 << 248].field_1024:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                            return 0
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                            return 0
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require depositFee[arg1 << 248].field_256
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        else:
                            return 0
                    if (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                        revert with 0, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                    if not stor5[arg1 << 248]:
                        revert with 0, 'Pool doesnt exist'
                    if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                        revert with 0, 'SafeMath: addition overflow'
                    if not depositFee[arg1 << 248].field_256:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                            if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                return 0
                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                return 0
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                       (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                            if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            else:
                                if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                    else:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                    if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                return 0
                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                            if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                else:
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if depositFee[arg1 << 248].field_256:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                    else:
                        if depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024:
                            revert with 0, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if depositFee[arg1 << 248].field_256:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
            else:
                require ext_code.size(stor2)
                staticcall stor2.0x75d813cd with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_768, depositFee[arg1 << 248].field_0, depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    if depositFee[arg1 << 248].field_256 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    if depositFee[arg1 << 248].field_256:
                        if (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 < depositFee[arg1 << 248].field_1024:
                            revert with 0, 'SafeMath: addition overflow'
                        require ext_code.size(stor3)
                        staticcall stor3.0x8b02ea7b with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1296
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                    return 0
                                require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                    return 0
                                require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                if not ext_call.return_data[0]:
                                    if depositFee[arg1 << 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require depositFee[arg1 << 248].field_256
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if not 10^12 * ext_call.return_data[0]:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require depositFee[arg1 << 248].field_256
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require depositFee[arg1 << 248].field_256
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                return 0
                            if (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                            if not stor5[arg1 << 248]:
                                revert with 0, 'Pool doesnt exist'
                            if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                revert with 0, 'SafeMath: addition overflow'
                            if not depositFee[arg1 << 248].field_256:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                    if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                            if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if not ext_call.return_data[0]:
                                                if depositFee[arg1 << 248].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if depositFee[arg1 << 248].field_256:
                                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                            return 0
                                                        if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return 0
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                   (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                        if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                        else:
                                                            if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                        ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                            else:
                                                if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if not 10^12 * ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                        else:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                if not ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if not 10^12 * ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                            else:
                                if (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                        else:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                if not ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if not 10^12 * ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                else:
                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                        revert with 0, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                    if depositFee[arg1 << 248].field_256 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    if depositFee[arg1 << 248].field_256:
                        if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 < depositFee[arg1 << 248].field_1024:
                            revert with 0, 'SafeMath: addition overflow'
                        require ext_code.size(stor3)
                        staticcall stor3.0x8b02ea7b with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1296
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                    return 0
                                require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                    return 0
                                require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                if not ext_call.return_data[0]:
                                    if depositFee[arg1 << 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require depositFee[arg1 << 248].field_256
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if not 10^12 * ext_call.return_data[0]:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require depositFee[arg1 << 248].field_256
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require depositFee[arg1 << 248].field_256
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                return 0
                            if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                                revert with 0, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                            if not stor5[arg1 << 248]:
                                revert with 0, 'Pool doesnt exist'
                            if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                revert with 0, 'SafeMath: addition overflow'
                            if not depositFee[arg1 << 248].field_256:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                    if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                            if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if not ext_call.return_data[0]:
                                                if depositFee[arg1 << 248].field_256 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if depositFee[arg1 << 248].field_256:
                                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                            return 0
                                                        if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return 0
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                   (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                        if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                        else:
                                                            if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                        ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                            else:
                                                if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if not 10^12 * ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                        else:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                if not ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if not 10^12 * ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                            else:
                                if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                        else:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                if not ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if not 10^12 * ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
    else:
        idx = 1024
        s = 0
        while (32 * depositFee[arg1 << 248].field_1536) + 992 > idx:
            mem[idx + 32] = depositFee[arg1 << 248][s + 6].field_256
            idx = idx + 32
            s = s + 1
            continue 
        if not depositFee[arg1 << 248].field_2048:
            if block.timestamp <= depositFee[arg1 << 248].field_768:
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > depositFee[arg1 << 248].field_1024:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                            return 0
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                            return 0
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require depositFee[arg1 << 248].field_256
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        else:
                            return 0
                    if (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                        revert with 0, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                    if not stor5[arg1 << 248]:
                        revert with 0, 'Pool doesnt exist'
                    if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                        revert with 0, 'SafeMath: addition overflow'
                    if not depositFee[arg1 << 248].field_256:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                            if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                return 0
                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                return 0
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                       (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                            if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            else:
                                if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                    else:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                    if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                return 0
                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                            if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                else:
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if depositFee[arg1 << 248].field_256:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                    else:
                        if depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024:
                            revert with 0, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if depositFee[arg1 << 248].field_256:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
            else:
                if depositFee[arg1 << 248].field_256 <= 0:
                    require ext_code.size(stor3)
                    staticcall stor3.0x8b02ea7b with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1296
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > depositFee[arg1 << 248].field_1024:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if not stor5[arg1 << 248]:
                                revert with 0, 'Pool doesnt exist'
                            if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                revert with 0, 'SafeMath: addition overflow'
                            if not depositFee[arg1 << 248].field_256:
                                require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                return 0
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                return 0
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                            if depositFee[arg1 << 248].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require depositFee[arg1 << 248].field_256
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            else:
                                return 0
                        if (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                            revert with 0, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if depositFee[arg1 << 248].field_256:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    return 0
                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not stor5[arg1 << 248]:
                                revert with 0, 'Pool doesnt exist'
                            if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                revert with 0, 'SafeMath: addition overflow'
                            if not depositFee[arg1 << 248].field_256:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if depositFee[arg1 << 248].field_256:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                        else:
                            if depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024:
                                revert with 0, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not stor5[arg1 << 248]:
                                revert with 0, 'Pool doesnt exist'
                            if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                revert with 0, 'SafeMath: addition overflow'
                            if not depositFee[arg1 << 248].field_256:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if depositFee[arg1 << 248].field_256:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                else:
                    require ext_code.size(stor2)
                    staticcall stor2.0x75d813cd with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_768, depositFee[arg1 << 248].field_0, depositFee[arg1 << 248].field_1296
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        if depositFee[arg1 << 248].field_256:
                            if (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 < depositFee[arg1 << 248].field_1024:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(stor3)
                            staticcall stor3.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1296
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        return 0
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        return 0
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                    if not ext_call.return_data[0]:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require depositFee[arg1 << 248].field_256
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if not 10^12 * ext_call.return_data[0]:
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require depositFee[arg1 << 248].field_256
                                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require depositFee[arg1 << 248].field_256
                                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    return 0
                                if (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    return 0
                                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                        else:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                if not ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if not 10^12 * ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                                if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    return 0
                                                                if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                                if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                            else:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                    if not ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if not 10^12 * ext_call.return_data[0]:
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                        else:
                                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                else:
                                    if (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                            else:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                    if not ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if not 10^12 * ext_call.return_data[0]:
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                        else:
                                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                    else:
                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                            revert with 0, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        if depositFee[arg1 << 248].field_256:
                            if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 < depositFee[arg1 << 248].field_1024:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(stor3)
                            staticcall stor3.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1296
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        return 0
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        return 0
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                    if not ext_call.return_data[0]:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require depositFee[arg1 << 248].field_256
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if not 10^12 * ext_call.return_data[0]:
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require depositFee[arg1 << 248].field_256
                                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require depositFee[arg1 << 248].field_256
                                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    return 0
                                if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    return 0
                                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                        else:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                if not ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if not 10^12 * ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                                if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    return 0
                                                                if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                                if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                            else:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                    if not ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if not 10^12 * ext_call.return_data[0]:
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                        else:
                                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                else:
                                    if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                            else:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                    if not ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if not 10^12 * ext_call.return_data[0]:
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                        else:
                                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
        else:
            idx = (32 * depositFee[arg1 << 248].field_1536) + 1056
            s = 0
            while (32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1024 > idx:
                mem[idx + 32] = depositFee[arg1 << 248][s + 8].field_256
                idx = idx + 32
                s = s + 1
                continue 
            if block.timestamp <= depositFee[arg1 << 248].field_768:
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args (depositFee[arg1 << 248].field_1296 << 248)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > depositFee[arg1 << 248].field_1024:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                            return 0
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                            return 0
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require depositFee[arg1 << 248].field_256
                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                            revert with 0, 'SafeMath: addition overflow'
                        else:
                            return 0
                    if (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                        revert with 0, 
                                    32,
                                    33,
                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                    if not stor5[arg1 << 248]:
                        revert with 0, 'Pool doesnt exist'
                    if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                        revert with 0, 'SafeMath: addition overflow'
                    if not depositFee[arg1 << 248].field_256:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                            if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                return 0
                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                return 0
                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                       (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                            if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            else:
                                if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                    else:
                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                    if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if depositFee[arg1 << 248].field_256 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                return 0
                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                            if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                else:
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if depositFee[arg1 << 248].field_256:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                    else:
                        if depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024:
                            revert with 0, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if depositFee[arg1 << 248].field_256:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    return 0
                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
            else:
                if depositFee[arg1 << 248].field_256 <= 0:
                    require ext_code.size(stor3)
                    staticcall stor3.0x8b02ea7b with:
                            gas gas_remaining wei
                           args (depositFee[arg1 << 248].field_1296 << 248)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > depositFee[arg1 << 248].field_1024:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if not stor5[arg1 << 248]:
                                revert with 0, 'Pool doesnt exist'
                            if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                revert with 0, 'SafeMath: addition overflow'
                            if not depositFee[arg1 << 248].field_256:
                                require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                return 0
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                return 0
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                            if depositFee[arg1 << 248].field_256 <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require depositFee[arg1 << 248].field_256
                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            else:
                                return 0
                        if (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                            revert with 0, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                        if not stor5[arg1 << 248]:
                            revert with 0, 'Pool doesnt exist'
                        if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                            revert with 0, 'SafeMath: addition overflow'
                        if not depositFee[arg1 << 248].field_256:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    return 0
                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    return 0
                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                           (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                else:
                                    if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                               depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                        else:
                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if depositFee[arg1 << 248].field_256:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if 0 == (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    return 0
                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                if not (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               depositFee[arg1 << 248].field_1792 * (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not stor5[arg1 << 248]:
                                revert with 0, 'Pool doesnt exist'
                            if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                revert with 0, 'SafeMath: addition overflow'
                            if not depositFee[arg1 << 248].field_256:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if depositFee[arg1 << 248].field_256:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                        else:
                            if depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != depositFee[arg1 << 248].field_1024:
                                revert with 0, 
                                            32,
                                            33,
                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not stor5[arg1 << 248]:
                                revert with 0, 'Pool doesnt exist'
                            if depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                revert with 0, 'SafeMath: addition overflow'
                            if not depositFee[arg1 << 248].field_256:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        return 0
                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        return 0
                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                            else:
                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if depositFee[arg1 << 248].field_256:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                else:
                    require ext_code.size(stor2)
                    staticcall stor2.0x75d813cd with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_768, address(depositFee[arg1 << 248].field_16), depositFee[arg1 << 248].field_1296
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        if depositFee[arg1 << 248].field_256:
                            if (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 < depositFee[arg1 << 248].field_1024:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(stor3)
                            staticcall stor3.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args (depositFee[arg1 << 248].field_1296 << 248)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        return 0
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        return 0
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                    if not ext_call.return_data[0]:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require depositFee[arg1 << 248].field_256
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if not 10^12 * ext_call.return_data[0]:
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require depositFee[arg1 << 248].field_256
                                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require depositFee[arg1 << 248].field_256
                                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    return 0
                                if (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    return 0
                                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                        else:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                if not ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if not 10^12 * ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                                if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    return 0
                                                                if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                                if not (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               (ext_call.return_data[0] * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                            else:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                    if not ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if not 10^12 * ext_call.return_data[0]:
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                        else:
                                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                else:
                                    if (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (0 / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                            else:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                    if not ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if not 10^12 * ext_call.return_data[0]:
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                        else:
                                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((0 / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                    else:
                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                            revert with 0, 
                                        32,
                                        33,
                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                        if depositFee[arg1 << 248].field_256 <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        if depositFee[arg1 << 248].field_256:
                            if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 < depositFee[arg1 << 248].field_1024:
                                revert with 0, 'SafeMath: addition overflow'
                            require ext_code.size(stor3)
                            staticcall stor3.0x8b02ea7b with:
                                    gas gas_remaining wei
                                   args (depositFee[arg1 << 248].field_1296 << 248)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 > (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        return 0
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                    if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        return 0
                                    require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536
                                    if not ext_call.return_data[0]:
                                        if depositFee[arg1 << 248].field_256 <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require depositFee[arg1 << 248].field_256
                                        require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                        if not 10^12 * ext_call.return_data[0]:
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require depositFee[arg1 << 248].field_256
                                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require depositFee[arg1 << 248].field_256
                                            require selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048
                                            if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                revert with 0, 'SafeMath: addition overflow'
                                    return 0
                                if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024 - sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                if not stor5[arg1 << 248]:
                                    revert with 0, 'Pool doesnt exist'
                                if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not depositFee[arg1 << 248].field_256:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                        if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            return 0
                                        if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            return 0
                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                            return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                   (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                        if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        else:
                                            if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                       (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                        ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                else:
                                    if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                        if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    return 0
                                                if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return 0
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                           (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                else:
                                                    if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                               (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                        else:
                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                if not ext_call.return_data[0]:
                                                    if depositFee[arg1 << 248].field_256 <= 0:
                                                        revert with 0, 'SafeMath: division by zero'
                                                    if depositFee[arg1 << 248].field_256:
                                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                return 0
                                                            if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                return 0
                                                            if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                       (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                            if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            else:
                                                                if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                    revert with 0, 
                                                                                32,
                                                                                33,
                                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    revert with 0, 'SafeMath: division by zero'
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                            ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                else:
                                                    if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                        revert with 0, 
                                                                    32,
                                                                    33,
                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                    if not 10^12 * ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                                if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    return 0
                                                                if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                           (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12
                                                                if not (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12, 
                                                                               (ext_call.return_data[0] * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) + (depositFee[arg1 << 248].field_1792 * (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) - (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                            else:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                    if not ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if not 10^12 * ext_call.return_data[0]:
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                        else:
                                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                else:
                                    if (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256) + depositFee[arg1 << 248].field_1024:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > (10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not stor5[arg1 << 248]:
                                        revert with 0, 'Pool doesnt exist'
                                    if ext_call.return_data[0] + depositFee[arg1 << 248].field_1792 < depositFee[arg1 << 248].field_1792:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not depositFee[arg1 << 248].field_256:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                return 0
                                            if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                return 0
                                            if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                       sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            else:
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                           (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                            ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                    else:
                                        if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                            if 0 == stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        return 0
                                                    if not stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                        return 0
                                                    if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   0 / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    else:
                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                    ('iszero', ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))))
                                            else:
                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_1536:
                                                    if not ext_call.return_data[0]:
                                                        if depositFee[arg1 << 248].field_256 <= 0:
                                                            revert with 0, 'SafeMath: division by zero'
                                                        if depositFee[arg1 << 248].field_256:
                                                            if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    return 0
                                                                if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                    return 0
                                                                if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                           sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                else:
                                                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    33,
                                                                                    0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                    mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        revert with 0, 'SafeMath: division by zero'
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                    else:
                                                        if 10^12 * ext_call.return_data[0] / ext_call.return_data[0] != 10^12:
                                                            revert with 0, 
                                                                        32,
                                                                        33,
                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                        if not 10^12 * ext_call.return_data[0]:
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (0 / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', 0, ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
                                                        else:
                                                            if 10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / 10^12 * ext_call.return_data[0] != stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            33,
                                                                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                            mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                            if depositFee[arg1 << 248].field_256 <= 0:
                                                                revert with 0, 'SafeMath: division by zero'
                                                            if depositFee[arg1 << 248].field_256:
                                                                if selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280] < depositFee[arg1 << 248].field_2048:
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 < stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        return 0
                                                                    if not (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                        return 0
                                                                    if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                        return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                               sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512
                                                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   0 / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    else:
                                                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != ext_call.return_data[0] + depositFee[arg1 << 248].field_1792:
                                                                            revert with 0, 
                                                                                        32,
                                                                                        33,
                                                                                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                                        mem[(32 * depositFee[arg1 << 248].field_1536) + (32 * depositFee[arg1 << 248].field_2048) + 1157 len 31]
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 <= 0:
                                                                            revert with 0, 'SafeMath: division by zero'
                                                                        if (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0:
                                                                            return sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512, 
                                                                                   (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * ext_call.return_data[0]) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * ext_call.return_data[0]) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * ext_call.return_data[0]) + (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * depositFee[arg1 << 248].field_1792) + ((10^12 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) + (depositFee[arg1 << 248].field_1024 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256) / 10^12 * depositFee[arg1 << 248].field_1792) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * depositFee[arg1 << 248].field_1792) / (10^12 * stor[('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0 * ext_call.return_data[0] / depositFee[arg1 << 248].field_256 / 10^12) + stor[('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))) + stor8[address(arg2)][depositFee[arg1 << 248].field_1280]].field_0
                                                                    ('iszero', ('add', ('div', ('div', ('mul', 1000000000000, ('field', 0, ('stor', ('add', ('array', 6, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8))))))), ('ext_call.return_data', 0, 32)), ('field', 256, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))))), 1000000000000), ('field', 0, ('stor', ('add', ('array', 8, ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6))), ('stor', ('map', ('field', 1280, ('stor', ('map', ('mask_shl', 8, 0, 248, ('param', 'arg1')), ('name', 'depositFee', 6)))), ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('name', 'stor8', 8)))))))))
    revert
}

function rewards(uint8 arg1, address arg2) payable {
    mem[64] = 96
    require calldata.size - 4 >= 64
    if stor2 != msg.sender:
        revert with 0, 'rOnly cartographer'
    if not stor5[arg1 << 248]:
        revert with 0, 'Pool doesnt exist'
    if not arg2:
        revert with 0, 'User address is zero'
    require ext_code.size(stor3)
    staticcall stor3.0x8b02ea7b with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] == depositFee[arg1 << 248].field_2304:
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10447 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10447] = 0
                        mem[_10447 + 32] = 0
                        mem[_10447 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10591 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10591] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10591 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10591 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
                return 0
            else:
                return 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10446 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10446] = 0
                        mem[_10446 + 32] = 0
                        mem[_10446 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10588 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10588] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10588 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10588 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10445 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10445] = 0
                        mem[_10445 + 32] = 0
                        mem[_10445 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10585 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10585] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10585 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10585 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10444 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10444] = 0
                    mem[_10444 + 32] = 0
                    mem[_10444 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10582 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10582] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10582 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10582 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               0,
               0,
               0
    if not ext_call.return_data[0]:
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10579 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10579] = 0
                        mem[_10579 + 32] = 0
                        mem[_10579 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10987 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10987] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10987 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10987 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
                return 0
            else:
                return 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10578 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10578] = 0
                        mem[_10578 + 32] = 0
                        mem[_10578 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10984 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10984] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10984 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10984 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10577 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10577] = 0
                        mem[_10577 + 32] = 0
                        mem[_10577 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10981 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10981] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10981 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10981 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10576 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10576] = 0
                    mem[_10576 + 32] = 0
                    mem[_10576 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10978 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10978] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10978 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10978 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               0,
               0,
               0
    if ext_call.return_data[0] == sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if 0 > sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(stor3)
            staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0, 
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1024,
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10575 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10575] = 0
                            mem[_10575 + 32] = 0
                            mem[_10575 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10975 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10975] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10975 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10975 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0, 
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1024,
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10574 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10574] = 0
                            mem[_10574 + 32] = 0
                            mem[_10574 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10972 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10972] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10972 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10972 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1024,
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10573 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10573] = 0
                            mem[_10573 + 32] = 0
                            mem[_10573 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10969 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10969] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10969 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10969 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1024,
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10572 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10572] = 0
                        mem[_10572 + 32] = 0
                        mem[_10572 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10966 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10966] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10966 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10966 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1024,
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 > sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(stor3)
            staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0, 0, sub_76fa17d2[arg1 << 248][address(arg2)].field_1280, ext_call.return_data[0]
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10571 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10571] = 0
                            mem[_10571 + 32] = 0
                            mem[_10571 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10963 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10963] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10963 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10963 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0, 0, sub_76fa17d2[arg1 << 248][address(arg2)].field_1280, ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10570 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10570] = 0
                            mem[_10570 + 32] = 0
                            mem[_10570 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10960 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10960] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10960 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10960 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                       0,
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10569 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10569] = 0
                            mem[_10569 + 32] = 0
                            mem[_10569 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10957 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10957] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10957 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10957 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       0,
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10568 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10568] = 0
                        mem[_10568 + 32] = 0
                        mem[_10568 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10954 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10954] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10954 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10954 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 > sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(stor3)
            staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0, 
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - (0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10567 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10567] = 0
                            mem[_10567 + 32] = 0
                            mem[_10567 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10951 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10951] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10951 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10951 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0, 
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - (0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10566 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10566] = 0
                            mem[_10566 + 32] = 0
                            mem[_10566 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10948 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10948] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10948 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10948 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - (0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10565 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10565] = 0
                            mem[_10565 + 32] = 0
                            mem[_10565 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10945 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10945] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10945 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10945 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - (0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                       sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                       ext_call.return_data[0]
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10564 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10564] = 0
                        mem[_10564 + 32] = 0
                        mem[_10564 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10942 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10942] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10942 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10942 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - (0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                   ext_call.return_data[0]
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 > sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            revert with 0, 'SafeMath: subtraction overflow'
        require ext_code.size(stor3)
        staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0, 
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - ((block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                   ext_call.return_data[0]
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10563 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10563] = 0
                        mem[_10563 + 32] = 0
                        mem[_10563 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10939 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10939] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10939 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10939 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0, 
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - ((block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10562 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10562] = 0
                        mem[_10562 + 32] = 0
                        mem[_10562 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10936 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10936] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10936 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10936 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - ((block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10561 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10561] = 0
                        mem[_10561 + 32] = 0
                        mem[_10561 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10933 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10933] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10933 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10933 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - ((block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
                   sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
                   ext_call.return_data[0]
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10560 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10560] = 0
                    mem[_10560 + 32] = 0
                    mem[_10560 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10930 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10930] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10930 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10930 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 - ((block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536),
               sub_76fa17d2[arg1 << 248][address(arg2)].field_1280,
               ext_call.return_data[0]
    require ext_code.size(stor3)
    staticcall stor3.0xcb4b3022 with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1280, ext_call.return_data[0] - 1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if uint8(ext_call.return_data[0]) != selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10559 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10559] = 0
                        mem[_10559 + 32] = 0
                        mem[_10559 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10927 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10927] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10927 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10927 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
                return 0
            else:
                return 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10558 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10558] = 0
                        mem[_10558 + 32] = 0
                        mem[_10558 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10924 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10924] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10924 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10924 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10557 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10557] = 0
                        mem[_10557 + 32] = 0
                        mem[_10557 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10921 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10921] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10921 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10921 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10556 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10556] = 0
                    mem[_10556 + 32] = 0
                    mem[_10556 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10918 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10918] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10918 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10918 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               0,
               0,
               0
    mem[64] = 288
    mem[192] = sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0
    mem[224] = sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256
    mem[256] = sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512
    if ext_call.return_data[0] - 1 != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
            if ext_call.return_data[0] - 1 != ext_call.return_data[0]:
                mem[292] = depositFee[arg1 << 248].field_1296
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                mem[288] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                    return 0
                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10555 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10555] = 0
                                mem[_10555 + 32] = 0
                                mem[_10555 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10915 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10915] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10915 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10915 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                        return 0
                    else:
                        return 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 'SafeMath: addition overflow'
                if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10554 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10554] = 0
                                mem[_10554 + 32] = 0
                                mem[_10554 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10912 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10912] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10912 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10912 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10553 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10553] = 0
                                mem[_10553 + 32] = 0
                                mem[_10553 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10909 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10909] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10909 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10909 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
                if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10552 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10552] = 0
                            mem[_10552 + 32] = 0
                            mem[_10552 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10906 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10906] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10906 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10906 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
            else:
                require ext_code.size(stor3)
                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[292] = depositFee[arg1 << 248].field_1296
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                mem[288] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                    return 0
                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10551 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10551] = 0
                                mem[_10551 + 32] = 0
                                mem[_10551 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10903 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10903] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10903 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10903 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                        return 0
                    else:
                        return 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 'SafeMath: addition overflow'
                if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10550 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10550] = 0
                                mem[_10550 + 32] = 0
                                mem[_10550 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10900 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10900] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10900 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10900 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10549 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10549] = 0
                                mem[_10549 + 32] = 0
                                mem[_10549 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10897 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10897] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10897 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10897 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
                if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10548 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10548] = 0
                            mem[_10548 + 32] = 0
                            mem[_10548 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10894 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10894] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10894 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10894 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   0,
                   0
        if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if ext_call.return_data[0] - 1 != ext_call.return_data[0]:
            if not sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                mem[292] = depositFee[arg1 << 248].field_1296
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                mem[288] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                    return 0
                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10547 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10547] = 0
                                mem[_10547 + 32] = 0
                                mem[_10547 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10891 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10891] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10891 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10891 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                        return 0
                    else:
                        return 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 'SafeMath: addition overflow'
                if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10546 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10546] = 0
                                mem[_10546 + 32] = 0
                                mem[_10546 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10888 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10888] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10888 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10888 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10545 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10545] = 0
                                mem[_10545 + 32] = 0
                                mem[_10545 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10885 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10885] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10885 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10885 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
                if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10544 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10544] = 0
                            mem[_10544 + 32] = 0
                            mem[_10544 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10882 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10882] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10882 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10882 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       0,
                       0,
                       0
            require ext_code.size(stor3)
            staticcall stor3.getElevationFracRoundRemaining(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                require ext_code.size(stor3)
                staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(stor3)
                staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[292] = depositFee[arg1 << 248].field_1296
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                mem[288] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                    return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10543 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10543] = 0
                                mem[_10543 + 32] = 0
                                mem[_10543 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10879 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10879] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10879 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10879 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 'SafeMath: addition overflow'
                if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10542 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10542] = 0
                                mem[_10542 + 32] = 0
                                mem[_10542 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10876 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10876] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10876 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10876 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, ext_call.return_data[0], ext_call.return_data[0]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10541 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10541] = 0
                                mem[_10541 + 32] = 0
                                mem[_10541 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10873 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10873] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10873 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10873 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, ext_call.return_data[0], ext_call.return_data[0]
                if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10540 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10540] = 0
                            mem[_10540 + 32] = 0
                            mem[_10540 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10870 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10870] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10870 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10870 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       0,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            require ext_code.size(stor3)
            staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(stor3)
            staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0, 
                       ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10539 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10539] = 0
                            mem[_10539 + 32] = 0
                            mem[_10539 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10867 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10867] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10867 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10867 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0, 
                       ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10538 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10538] = 0
                            mem[_10538 + 32] = 0
                            mem[_10538 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10864 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10864] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10864 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10864 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                       ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10537 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10537] = 0
                            mem[_10537 + 32] = 0
                            mem[_10537 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10861 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10861] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10861 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10861 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10536 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10536] = 0
                        mem[_10536 + 32] = 0
                        mem[_10536 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10858 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10858] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10858 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10858 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        require ext_code.size(stor3)
        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10535 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10535] = 0
                            mem[_10535 + 32] = 0
                            mem[_10535 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10855 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10855] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10855 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10855 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                    return 0
                else:
                    return 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10534 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10534] = 0
                            mem[_10534 + 32] = 0
                            mem[_10534 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10852 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10852] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10852 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10852 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10533 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10533] = 0
                            mem[_10533 + 32] = 0
                            mem[_10533 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10849 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10849] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10849 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10849 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10532 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10532] = 0
                        mem[_10532 + 32] = 0
                        mem[_10532 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10846 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10846] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10846 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10846 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   0,
                   0
        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12:
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10531 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10531] = 0
                            mem[_10531 + 32] = 0
                            mem[_10531 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10843 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10843] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10843 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10843 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                    return 0
                else:
                    return 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10530 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10530] = 0
                            mem[_10530 + 32] = 0
                            mem[_10530 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10840 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10840] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10840 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10840 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10529 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10529] = 0
                            mem[_10529 + 32] = 0
                            mem[_10529 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10837 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10837] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10837 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10837 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10528 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10528] = 0
                        mem[_10528 + 32] = 0
                        mem[_10528 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10834 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10834] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10834 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10834 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   0,
                   0
        require ext_code.size(stor3)
        staticcall stor3.getElevationFracRoundRemaining(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12:
            require ext_code.size(stor3)
            staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(stor3)
            staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10527 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10527] = 0
                            mem[_10527 + 32] = 0
                            mem[_10527 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10831 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10831] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10831 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10831 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10526 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10526] = 0
                            mem[_10526 + 32] = 0
                            mem[_10526 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10828 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10828] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10828 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10828 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, ext_call.return_data[0], ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10525 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10525] = 0
                            mem[_10525 + 32] = 0
                            mem[_10525 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10825 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10825] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10825 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10825 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, ext_call.return_data[0], ext_call.return_data[0]
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10524 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10524] = 0
                        mem[_10524 + 32] = 0
                        mem[_10524 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10822 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10822] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10822 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10822 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if ext_call.return_data[0] * ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12 / ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12 != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        require ext_code.size(stor3)
        staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(stor3)
        staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[292] = depositFee[arg1 << 248].field_1296
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        mem[288] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0, 
                   ext_call.return_data[0] * ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10523 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10523] = 0
                        mem[_10523 + 32] = 0
                        mem[_10523 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10819 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10819] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10819 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10819 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0, 
                   ext_call.return_data[0] * ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10522 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10522] = 0
                        mem[_10522 + 32] = 0
                        mem[_10522 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10816 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10816] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10816 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10816 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                   ext_call.return_data[0] * ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10521 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10521] = 0
                        mem[_10521 + 32] = 0
                        mem[_10521 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10813 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10813] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10813 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10813 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   ext_call.return_data[0] * ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10520 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10520] = 0
                    mem[_10520 + 32] = 0
                    mem[_10520 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10810 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10810] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10810 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10810 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               ext_call.return_data[0] * ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / 10^12 / 10^12,
               ext_call.return_data[0],
               ext_call.return_data[0]
    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
            revert with 0, 'SafeMath: addition overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
            if ext_call.return_data[0] - 1 != ext_call.return_data[0]:
                mem[292] = depositFee[arg1 << 248].field_1296
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                mem[288] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                    return 0
                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10519 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10519] = 0
                                mem[_10519 + 32] = 0
                                mem[_10519 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10807 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10807] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10807 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10807 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                        return 0
                    else:
                        return 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 'SafeMath: addition overflow'
                if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10518 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10518] = 0
                                mem[_10518 + 32] = 0
                                mem[_10518 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10804 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10804] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10804 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10804 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10517 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10517] = 0
                                mem[_10517 + 32] = 0
                                mem[_10517 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10801 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10801] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10801 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10801 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
                if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10516 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10516] = 0
                            mem[_10516 + 32] = 0
                            mem[_10516 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10798 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10798] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10798 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10798 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
            else:
                require ext_code.size(stor3)
                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[292] = depositFee[arg1 << 248].field_1296
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                mem[288] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                    return 0
                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10515 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10515] = 0
                                mem[_10515 + 32] = 0
                                mem[_10515 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10795 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10795] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10795 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10795 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                        return 0
                    else:
                        return 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 'SafeMath: addition overflow'
                if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10514 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10514] = 0
                                mem[_10514 + 32] = 0
                                mem[_10514 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10792 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10792] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10792 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10792 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10513 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10513] = 0
                                mem[_10513 + 32] = 0
                                mem[_10513 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10789 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10789] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10789 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10789 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
                if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10512 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10512] = 0
                            mem[_10512 + 32] = 0
                            mem[_10512 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10786 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10786] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10786 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10786 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   0,
                   0
        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if ext_call.return_data[0] - 1 != ext_call.return_data[0]:
            if not (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12:
                mem[292] = depositFee[arg1 << 248].field_1296
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                mem[288] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                    return 0
                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10511 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10511] = 0
                                mem[_10511 + 32] = 0
                                mem[_10511 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10783 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10783] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10783 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10783 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                        return 0
                    else:
                        return 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 'SafeMath: addition overflow'
                if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10510 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10510] = 0
                                mem[_10510 + 32] = 0
                                mem[_10510 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10780 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10780] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10780 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10780 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10509 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10509] = 0
                                mem[_10509 + 32] = 0
                                mem[_10509 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10777 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10777] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10777 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10777 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
                if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10508 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10508] = 0
                            mem[_10508 + 32] = 0
                            mem[_10508 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10774 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10774] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10774 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10774 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       0,
                       0,
                       0
            require ext_code.size(stor3)
            staticcall stor3.getElevationFracRoundRemaining(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12:
                require ext_code.size(stor3)
                staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(stor3)
                staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[292] = depositFee[arg1 << 248].field_1296
                require ext_code.size(stor3)
                staticcall stor3.0x8b02ea7b with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1296
                mem[288] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                    return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
                if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10507 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10507] = 0
                                mem[_10507 + 32] = 0
                                mem[_10507 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10771 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10771] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10771 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10771 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 'SafeMath: addition overflow'
                if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10506 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10506] = 0
                                mem[_10506 + 32] = 0
                                mem[_10506 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10768 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10768] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10768 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10768 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, ext_call.return_data[0], ext_call.return_data[0]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                        while idx < ext_call.return_data[0]:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            mem[mem[64] + 36] = idx
                            require ext_code.size(stor3)
                            staticcall stor3.0xcb4b3022 with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280, idx
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[0] = depositFee[arg1 << 248].field_1296
                            mem[32] = sha3(address(arg2), 8)
                            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                                _10505 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10505] = 0
                                mem[_10505 + 32] = 0
                                mem[_10505 + 64] = 0
                                mem[0] = idx
                                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                                _10765 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_10765] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                                mem[_10765 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                                mem[_10765 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    else:
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                        else:
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if idx == ext_call.return_data[0] - 1:
                                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                                require ext_code.size(stor3)
                                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                        gas gas_remaining wei
                                                       args depositFee[arg1 << 248].field_1280
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            idx = idx + 1
                            continue 
                    return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, ext_call.return_data[0], ext_call.return_data[0]
                if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10504 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10504] = 0
                            mem[_10504 + 32] = 0
                            mem[_10504 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10762 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10762] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10762 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10762 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       0,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 != ext_call.return_data[0]:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            require ext_code.size(stor3)
            staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(stor3)
            staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0, 
                       ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10503 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10503] = 0
                            mem[_10503 + 32] = 0
                            mem[_10503 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10759 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10759] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10759 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10759 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0, 
                       ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10502 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10502] = 0
                            mem[_10502 + 32] = 0
                            mem[_10502 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10756 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10756] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10756 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10756 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                       ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10501 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10501] = 0
                            mem[_10501 + 32] = 0
                            mem[_10501 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10753 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10753] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10753 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10753 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                       ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                       ext_call.return_data[0],
                       ext_call.return_data[0]
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10500 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10500] = 0
                        mem[_10500 + 32] = 0
                        mem[_10500 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10750 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10750] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10750 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10750 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        require ext_code.size(stor3)
        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12:
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10499 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10499] = 0
                            mem[_10499 + 32] = 0
                            mem[_10499 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10747 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10747] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10747 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10747 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                    return 0
                else:
                    return 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10498 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10498] = 0
                            mem[_10498 + 32] = 0
                            mem[_10498 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10744 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10744] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10744 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10744 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10497 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10497] = 0
                            mem[_10497 + 32] = 0
                            mem[_10497 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10741 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10741] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10741 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10741 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10496 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10496] = 0
                        mem[_10496 + 32] = 0
                        mem[_10496 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10738 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10738] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10738 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10738 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   0,
                   0
        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12:
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10495 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10495] = 0
                            mem[_10495 + 32] = 0
                            mem[_10495 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10735 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10735] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10735 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10735 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                    return 0
                else:
                    return 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10494 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10494] = 0
                            mem[_10494 + 32] = 0
                            mem[_10494 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10732 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10732] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10732 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10732 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10493 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10493] = 0
                            mem[_10493 + 32] = 0
                            mem[_10493 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10729 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10729] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10729 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10729 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10492 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10492] = 0
                        mem[_10492 + 32] = 0
                        mem[_10492 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10726 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10726] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10726 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10726 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   0,
                   0
        require ext_code.size(stor3)
        staticcall stor3.getElevationFracRoundRemaining(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12:
            require ext_code.size(stor3)
            staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(stor3)
            staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10491 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10491] = 0
                            mem[_10491 + 32] = 0
                            mem[_10491 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10723 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10723] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10723 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10723 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10490 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10490] = 0
                            mem[_10490 + 32] = 0
                            mem[_10490 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10720 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10720] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10720 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10720 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, ext_call.return_data[0], ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10489 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10489] = 0
                            mem[_10489 + 32] = 0
                            mem[_10489 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10717 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10717] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10717 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10717 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, ext_call.return_data[0], ext_call.return_data[0]
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10488 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10488] = 0
                        mem[_10488 + 32] = 0
                        mem[_10488 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10714 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10714] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10714 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10714 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        require ext_code.size(stor3)
        staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(stor3)
        staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[292] = depositFee[arg1 << 248].field_1296
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        mem[288] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0, 
                   ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10487 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10487] = 0
                        mem[_10487 + 32] = 0
                        mem[_10487 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10711 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10711] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10711 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10711 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0, 
                   ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10486 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10486] = 0
                        mem[_10486 + 32] = 0
                        mem[_10486 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10708 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10708] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10708 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10708 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                   ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10485 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10485] = 0
                        mem[_10485 + 32] = 0
                        mem[_10485 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10705 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10705] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10705 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10705 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10484 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10484] = 0
                    mem[_10484 + 32] = 0
                    mem[_10484 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10702 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10702] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10702 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10702 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
               ext_call.return_data[0],
               ext_call.return_data[0]
    if sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0:
        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
        revert with 0, 'SafeMath: addition overflow'
    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
        if ext_call.return_data[0] - 1 != ext_call.return_data[0]:
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10483 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10483] = 0
                            mem[_10483 + 32] = 0
                            mem[_10483 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10699 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10699] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10699 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10699 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                    return 0
                else:
                    return 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10482 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10482] = 0
                            mem[_10482 + 32] = 0
                            mem[_10482 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10696 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10696] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10696 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10696 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10481 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10481] = 0
                            mem[_10481 + 32] = 0
                            mem[_10481 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10693 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10693] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10693 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10693 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10480 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10480] = 0
                        mem[_10480 + 32] = 0
                        mem[_10480 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10690 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10690] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10690 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10690 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
        else:
            require ext_code.size(stor3)
            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10479 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10479] = 0
                            mem[_10479 + 32] = 0
                            mem[_10479 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10687 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10687] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10687 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10687 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                    return 0
                else:
                    return 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10478 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10478] = 0
                            mem[_10478 + 32] = 0
                            mem[_10478 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10684 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10684] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10684 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10684 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10477 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10477] = 0
                            mem[_10477 + 32] = 0
                            mem[_10477 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10681 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10681] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10681 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10681 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10476 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10476] = 0
                        mem[_10476 + 32] = 0
                        mem[_10476 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10678 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10678] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10678 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10678 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               0,
               0,
               0
    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256:
        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if ext_call.return_data[0] - 1 != ext_call.return_data[0]:
        if not (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12:
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10475 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10475] = 0
                            mem[_10475 + 32] = 0
                            mem[_10475 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10675 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10675] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10675 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10675 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                    return 0
                else:
                    return 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10474 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10474] = 0
                            mem[_10474 + 32] = 0
                            mem[_10474 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10672 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10672] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10672 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10672 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10473 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10473] = 0
                            mem[_10473 + 32] = 0
                            mem[_10473 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10669 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10669] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10669 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10669 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10472 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10472] = 0
                        mem[_10472 + 32] = 0
                        mem[_10472 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10666 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10666] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10666 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10666 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   0,
                   0
        require ext_code.size(stor3)
        staticcall stor3.getElevationFracRoundRemaining(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12:
            require ext_code.size(stor3)
            staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(stor3)
            staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[292] = depositFee[arg1 << 248].field_1296
            require ext_code.size(stor3)
            staticcall stor3.0x8b02ea7b with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1296
            mem[288] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
                return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
            if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10471 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10471] = 0
                            mem[_10471 + 32] = 0
                            mem[_10471 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10663 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10663] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10663 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10663 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 'SafeMath: addition overflow'
            if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10470 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10470] = 0
                            mem[_10470 + 32] = 0
                            mem[_10470 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10660 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10660] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10660 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10660 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, ext_call.return_data[0], ext_call.return_data[0]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
                revert with 0, 'SafeMath: subtraction overflow'
            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
                if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
                if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                    while idx < ext_call.return_data[0]:
                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                        mem[mem[64] + 36] = idx
                        require ext_code.size(stor3)
                        staticcall stor3.0xcb4b3022 with:
                                gas gas_remaining wei
                               args depositFee[arg1 << 248].field_1280, idx
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[0] = depositFee[arg1 << 248].field_1296
                        mem[32] = sha3(address(arg2), 8)
                        if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                            _10469 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10469] = 0
                            mem[_10469 + 32] = 0
                            mem[_10469 + 64] = 0
                            mem[0] = idx
                            mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                            _10657 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_10657] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                            mem[_10657 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                            mem[_10657 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                            if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                            if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                else:
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                    else:
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if idx == ext_call.return_data[0] - 1:
                                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                            require ext_code.size(stor3)
                                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                    gas gas_remaining wei
                                                   args depositFee[arg1 << 248].field_1280
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                                if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        idx = idx + 1
                        continue 
                return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, ext_call.return_data[0], ext_call.return_data[0]
            if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10468 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10468] = 0
                        mem[_10468 + 32] = 0
                        mem[_10468 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10654 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10654] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10654 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10654 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   0,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 != ext_call.return_data[0]:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        require ext_code.size(stor3)
        staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(stor3)
        staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[292] = depositFee[arg1 << 248].field_1296
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        mem[288] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0, 
                   ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10467 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10467] = 0
                        mem[_10467 + 32] = 0
                        mem[_10467 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10651 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10651] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10651 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10651 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0, 
                   ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10466 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10466] = 0
                        mem[_10466 + 32] = 0
                        mem[_10466 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10648 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10648] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10648 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10648 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
                   ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10465 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10465] = 0
                        mem[_10465 + 32] = 0
                        mem[_10465 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10645 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10645] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10645 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10645 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
                   ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
                   ext_call.return_data[0],
                   ext_call.return_data[0]
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10464 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10464] = 0
                    mem[_10464 + 32] = 0
                    mem[_10464 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10642 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10642] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10642 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10642 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12,
               ext_call.return_data[0],
               ext_call.return_data[0]
    require ext_code.size(stor3)
    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12:
        mem[292] = depositFee[arg1 << 248].field_1296
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        mem[288] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10463 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10463] = 0
                        mem[_10463 + 32] = 0
                        mem[_10463 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10639 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10639] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10639 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10639 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
                return 0
            else:
                return 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10462 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10462] = 0
                        mem[_10462 + 32] = 0
                        mem[_10462 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10636 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10636] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10636 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10636 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10461 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10461] = 0
                        mem[_10461 + 32] = 0
                        mem[_10461 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10633 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10633] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10633 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10633 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10460 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10460] = 0
                    mem[_10460 + 32] = 0
                    mem[_10460 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10630 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10630] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10630 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10630 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               0,
               0,
               0
    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 != ext_call.return_data[0]:
        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if not ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12:
        mem[292] = depositFee[arg1 << 248].field_1296
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        mem[288] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10459 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10459] = 0
                        mem[_10459 + 32] = 0
                        mem[_10459 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10627 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10627] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10627 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10627 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
                return 0
            else:
                return 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10458 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10458] = 0
                        mem[_10458 + 32] = 0
                        mem[_10458 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10624 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10624] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10624 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10624 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, 0, 0
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10457 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10457] = 0
                        mem[_10457 + 32] = 0
                        mem[_10457 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10621 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10621] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10621 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10621 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, 0, 0
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10456 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10456] = 0
                    mem[_10456 + 32] = 0
                    mem[_10456 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10618 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10618] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10618 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10618 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               0,
               0,
               0
    require ext_code.size(stor3)
    staticcall stor3.getElevationFracRoundRemaining(uint8 arg1) with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if not ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12:
        require ext_code.size(stor3)
        staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(stor3)
        staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[292] = depositFee[arg1 << 248].field_1296
        require ext_code.size(stor3)
        staticcall stor3.0x8b02ea7b with:
                gas gas_remaining wei
               args depositFee[arg1 << 248].field_1296
        mem[288] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
            return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
        if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10455 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10455] = 0
                        mem[_10455 + 32] = 0
                        mem[_10455 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10615 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10615] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10615 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10615 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0, 0, ext_call.return_data[0], ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 'SafeMath: addition overflow'
        if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10454 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10454] = 0
                        mem[_10454 + 32] = 0
                        mem[_10454 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10612 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10612] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10612 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10612 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 0, ext_call.return_data[0], ext_call.return_data[0]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow'
        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
            if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
            if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
                while idx < ext_call.return_data[0]:
                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                    mem[mem[64] + 36] = idx
                    require ext_code.size(stor3)
                    staticcall stor3.0xcb4b3022 with:
                            gas gas_remaining wei
                           args depositFee[arg1 << 248].field_1280, idx
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[0] = depositFee[arg1 << 248].field_1296
                    mem[32] = sha3(address(arg2), 8)
                    if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                        _10453 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10453] = 0
                        mem[_10453 + 32] = 0
                        mem[_10453 + 64] = 0
                        mem[0] = idx
                        mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                        _10609 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_10609] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                        mem[_10609 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                        mem[_10609 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                        if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                        if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            else:
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                else:
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if idx == ext_call.return_data[0] - 1:
                                        mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                        require ext_code.size(stor3)
                                        staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                                gas gas_remaining wei
                                               args depositFee[arg1 << 248].field_1280
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                            if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    idx = idx + 1
                    continue 
            return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 0, ext_call.return_data[0], ext_call.return_data[0]
        if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10452 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10452] = 0
                    mem[_10452 + 32] = 0
                    mem[_10452 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10606 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10606] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10606 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10606 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               0,
               ext_call.return_data[0],
               ext_call.return_data[0]
    if ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 != ext_call.return_data[0]:
        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    require ext_code.size(stor3)
    staticcall stor3.getElevationTimeRemainingInRound(uint8 arg1) with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor3)
    staticcall stor3.getElevationCurrentRoundStartTime(uint8 arg1) with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    mem[292] = depositFee[arg1 << 248].field_1296
    require ext_code.size(stor3)
    staticcall stor3.0x8b02ea7b with:
            gas gas_remaining wei
           args depositFee[arg1 << 248].field_1296
    mem[288] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= depositFee[arg1 << 248].field_2304:
        return 0, 
               ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
               ext_call.return_data[0],
               ext_call.return_data[0]
    if 0 == sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10451 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10451] = 0
                    mem[_10451 + 32] = 0
                    mem[_10451 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10603 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10603] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10603 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10603 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return 0, 
               ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
               ext_call.return_data[0],
               ext_call.return_data[0]
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 < sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
        revert with 0, 'SafeMath: addition overflow'
    if block.timestamp >= sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 + sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10450 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10450] = 0
                    mem[_10450 + 32] = 0
                    mem[_10450 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10600 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10600] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10600 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10600 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return sub_76fa17d2[arg1 << 248][address(arg2)].field_1024, 
               ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
               ext_call.return_data[0],
               ext_call.return_data[0]
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 > block.timestamp:
        revert with 0, 'SafeMath: subtraction overflow'
    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_1024:
        if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
            revert with 0, 'SafeMath: division by zero'
        require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
        if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
            idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
            while idx < ext_call.return_data[0]:
                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                mem[mem[64] + 36] = idx
                require ext_code.size(stor3)
                staticcall stor3.0xcb4b3022 with:
                        gas gas_remaining wei
                       args depositFee[arg1 << 248].field_1280, idx
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[0] = depositFee[arg1 << 248].field_1296
                mem[32] = sha3(address(arg2), 8)
                if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                    _10449 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10449] = 0
                    mem[_10449 + 32] = 0
                    mem[_10449 + 64] = 0
                    mem[0] = idx
                    mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                    _10597 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_10597] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                    mem[_10597 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                    mem[_10597 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                    if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                    if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        else:
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                            else:
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if idx == ext_call.return_data[0] - 1:
                                    mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                    require ext_code.size(stor3)
                                    staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                            gas gas_remaining wei
                                           args depositFee[arg1 << 248].field_1280
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                        if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                idx = idx + 1
                continue 
        return 0 / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
               ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
               ext_call.return_data[0],
               ext_call.return_data[0]
    if (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1024 != block.timestamp - sub_76fa17d2[arg1 << 248][address(arg2)].field_1280:
        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if sub_76fa17d2[arg1 << 248][address(arg2)].field_1536 <= 0:
        revert with 0, 'SafeMath: division by zero'
    require sub_76fa17d2[arg1 << 248][address(arg2)].field_1536
    if ext_call.return_data[0] != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
        idx = sub_76fa17d2[arg1 << 248][address(arg2)].field_0
        while idx < ext_call.return_data[0]:
            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
            mem[mem[64] + 36] = idx
            require ext_code.size(stor3)
            staticcall stor3.0xcb4b3022 with:
                    gas gas_remaining wei
                   args depositFee[arg1 << 248].field_1280, idx
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[0] = depositFee[arg1 << 248].field_1296
            mem[32] = sha3(address(arg2), 8)
            if uint8(ext_call.return_data[0]) == selectedTotem[address(arg2)][stor6[arg1 << 248].field_1280]:
                _10448 = mem[64]
                mem[64] = mem[64] + 96
                mem[_10448] = 0
                mem[_10448 + 32] = 0
                mem[_10448 + 64] = 0
                mem[0] = idx
                mem[32] = sha3(depositFee[arg1 << 248].field_0, 9)
                _10594 = mem[64]
                mem[64] = mem[64] + 96
                mem[_10594] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0
                mem[_10594 + 32] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256
                mem[_10594 + 64] = sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512
                if idx != sub_76fa17d2[arg1 << 248][address(arg2)].field_0:
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if idx == ext_call.return_data[0] - 1:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            require ext_code.size(stor3)
                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                    else:
                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if idx == ext_call.return_data[0] - 1:
                            mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                            require ext_code.size(stor3)
                            staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                    gas gas_remaining wei
                                   args depositFee[arg1 << 248].field_1280
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                                if ext_call.return_data[0] * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 / sub_057a3048[stor6[arg1 << 248].field_0][idx].field_512 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 != ext_call.return_data[0]:
                                    revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                else:
                    if not sub_76fa17d2[arg1 << 248][address(arg2)].field_256:
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 < -sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            revert with 0, 'SafeMath: addition overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    else:
                        if sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / sub_76fa17d2[arg1 << 248][address(arg2)].field_256 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0:
                            revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_512 > sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if sub_76fa17d2[arg1 << 248][address(arg2)].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512:
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                        else:
                            if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / sub_76fa17d2[arg1 << 248][address(arg2)].field_768 + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12) - sub_76fa17d2[arg1 << 248][address(arg2)].field_512 != sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256:
                                revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if idx == ext_call.return_data[0] - 1:
                                mem[mem[64] + 4] = depositFee[arg1 << 248].field_1296
                                require ext_code.size(stor3)
                                staticcall stor3.getElevationFracRoundProgress(uint8 arg1) with:
                                        gas gas_remaining wei
                                       args depositFee[arg1 << 248].field_1280
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12:
                                    if ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 / (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][idx].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][idx].field_256) / 10^12 != ext_call.return_data[0]:
                                        revert with 0, 32, 33, 0x72536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            idx = idx + 1
            continue 
    return (block.timestamp * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_1280 * sub_76fa17d2[arg1 << 248][address(arg2)].field_1024) / sub_76fa17d2[arg1 << 248][address(arg2)].field_1536, 
           ext_call.return_data[0] * ext_call.return_data[0] * (sub_76fa17d2[arg1 << 248][address(arg2)].field_768 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) + (sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_0 * sub_76fa17d2[arg1 << 248][address(arg2)].field_256 / 10^12 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) - (sub_76fa17d2[arg1 << 248][address(arg2)].field_512 * sub_057a3048[stor6[arg1 << 248].field_0][ext_call.return_data[0] - 1].field_256) / 10^12 / 10^12 / 10^12,
           ext_call.return_data[0],
           ext_call.return_data[0]
}



}
